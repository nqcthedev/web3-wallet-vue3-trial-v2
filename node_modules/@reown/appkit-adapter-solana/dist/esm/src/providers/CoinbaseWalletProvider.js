import { ConstantsUtil as CommonConstantsUtil, ConstantsUtil, PresetsUtil, UserRejectedRequestError } from '@reown/appkit-common';
import {} from '@reown/appkit-utils/solana';
import { solana } from '@reown/appkit/networks';
import { ProviderEventEmitter } from './shared/ProviderEventEmitter.js';
export class CoinbaseWalletProvider extends ProviderEventEmitter {
    constructor(params) {
        super();
        this.name = 'Coinbase Wallet';
        this.id = PresetsUtil.ConnectorExplorerIds[ConstantsUtil.CONNECTOR_ID.COINBASE_SDK] || this.name;
        this.explorerId = PresetsUtil.ConnectorExplorerIds[ConstantsUtil.CONNECTOR_ID.COINBASE_SDK];
        this.type = 'ANNOUNCED';
        this.imageUrl = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8Y2lyY2xlIGN4PSI1MTIiIGN5PSI1MTIiIHI9IjUxMiIgZmlsbD0iIzAwNTJGRiIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1MiA1MTJDMTUyIDcxMC44MjMgMzEzLjE3NyA4NzIgNTEyIDg3MkM3MTAuODIzIDg3MiA4NzIgNzEwLjgyMyA4NzIgNTEyQzg3MiAzMTMuMTc3IDcxMC44MjMgMTUyIDUxMiAxNTJDMzEzLjE3NyAxNTIgMTUyIDMxMy4xNzcgMTUyIDUxMlpNNDIwIDM5NkM0MDYuNzQ1IDM5NiAzOTYgNDA2Ljc0NSAzOTYgNDIwVjYwNEMzOTYgNjE3LjI1NSA0MDYuNzQ1IDYyOCA0MjAgNjI4SDYwNEM2MTcuMjU1IDYyOCA2MjggNjE3LjI1NSA2MjggNjA0VjQyMEM2MjggNDA2Ljc0NSA2MTcuMjU1IDM5NiA2MDQgMzk2SDQyMFoiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=';
        this.chain = ConstantsUtil.CHAIN.SOLANA;
        this.provider = this;
        this.coinbase = params.provider;
        this.requestedChains = params.chains;
    }
    get chains() {
        return this.requestedChains.filter(chain => chain.id === solana.id);
    }
    get publicKey() {
        return this.coinbase.publicKey;
    }
    get imageId() {
        return PresetsUtil.ConnectorImageIds[CommonConstantsUtil.CONNECTOR_ID.COINBASE];
    }
    async connect() {
        try {
            await this.coinbase.connect();
            const account = this.getAccount(true);
            this.coinbase.emit('connect', this.coinbase.publicKey);
            this.emit('connect', account);
            return account.toBase58();
        }
        catch (error) {
            this.coinbase.emit('error', error);
            throw new UserRejectedRequestError(error);
        }
    }
    async disconnect() {
        await this.coinbase.disconnect();
        this.coinbase.emit('disconnect', undefined);
        this.emit('disconnect', undefined);
    }
    async signMessage(message) {
        const result = await this.coinbase.signMessage(message);
        return result.signature;
    }
    async signTransaction(transaction) {
        return this.coinbase.signTransaction(transaction);
    }
    async signAndSendTransaction(transaction, sendOptions) {
        const result = await this.coinbase.signAndSendTransaction(transaction, sendOptions);
        return result.signature;
    }
    async sendTransaction(transaction, connection, options) {
        const signedTransaction = await this.signTransaction(transaction);
        const signature = await connection.sendRawTransaction(signedTransaction.serialize(), options);
        return signature;
    }
    async signAllTransactions(transactions) {
        return (await this.coinbase.signAllTransactions(transactions));
    }
    async request(_args) {
        return Promise.reject(new Error('The "request" method is not supported on Coinbase Wallet'));
    }
    async getAccounts() {
        const account = this.getAccount();
        if (!account) {
            return Promise.resolve([]);
        }
        return Promise.resolve([
            {
                namespace: this.chain,
                address: account.toBase58(),
                type: 'eoa'
            }
        ]);
    }
    getAccount(required) {
        const account = this.coinbase.publicKey;
        if (required && !account) {
            throw new Error('Not connected');
        }
        return account;
    }
}
//# sourceMappingURL=CoinbaseWalletProvider.js.map