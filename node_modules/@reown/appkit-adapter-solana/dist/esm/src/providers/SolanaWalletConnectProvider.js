var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SolanaWalletConnectProvider_version;
import { isVersionedTransaction } from '@solana/wallet-adapter-base';
import { Connection, PublicKey, Transaction, VersionedTransaction } from '@solana/web3.js';
import UniversalProvider from '@walletconnect/universal-provider';
import base58 from 'bs58';
import {} from '@reown/appkit';
import { ParseUtil } from '@reown/appkit-common';
import { AssetController, WalletConnectConnector, WcHelpersUtil } from '@reown/appkit-controllers';
import { SolConstantsUtil } from '@reown/appkit-utils/solana';
import { WalletConnectMethodNotSupportedError } from './shared/Errors.js';
import { ProviderEventEmitter } from './shared/ProviderEventEmitter.js';
export class SolanaWalletConnectProvider extends WalletConnectConnector {
    constructor({ provider, chains, getActiveChain }) {
        super({ caipNetworks: chains, namespace: 'solana', provider });
        this.eventEmitter = new ProviderEventEmitter();
        this.emit = this.eventEmitter.emit.bind(this.eventEmitter);
        this.on = this.eventEmitter.on.bind(this.eventEmitter);
        this.removeListener = this.eventEmitter.removeListener.bind(this.eventEmitter);
        _SolanaWalletConnectProvider_version.set(this, '1.0.0');
        this.getActiveChain = getActiveChain;
    }
    get session() {
        return this.provider.session;
    }
    get chains() {
        return this.sessionChains
            .map(sessionChainId => {
            let chainId = sessionChainId;
            if (chainId === SolConstantsUtil.CHAIN_IDS.Deprecated_Mainnet) {
                chainId = SolConstantsUtil.CHAIN_IDS.Mainnet;
            }
            else if (chainId === SolConstantsUtil.CHAIN_IDS.Deprecated_Devnet) {
                chainId = SolConstantsUtil.CHAIN_IDS.Devnet;
            }
            return this.caipNetworks.find(chain => chain.caipNetworkId === chainId);
        })
            .filter(Boolean);
    }
    get icon() {
        return AssetController.state.connectorImages[this.id];
    }
    get version() {
        return __classPrivateFieldGet(this, _SolanaWalletConnectProvider_version, "f");
    }
    get publicKey() {
        const account = this.getAccount(false);
        if (account) {
            return new PublicKey(account.publicKey);
        }
        return undefined;
    }
    async connect() {
        await super.connectWalletConnect();
        const account = this.getAccount(true);
        this.emit('connect', new PublicKey(account.publicKey));
        return account.address;
    }
    async disconnect() {
        await super.disconnect();
        this.emit('disconnect', undefined);
    }
    async signMessage(message) {
        this.checkIfMethodIsSupported('solana_signMessage');
        const signedMessage = await this.internalRequest('solana_signMessage', {
            message: base58.encode(message),
            pubkey: this.getAccount(true).address
        });
        return base58.decode(signedMessage.signature);
    }
    async signTransaction(transaction) {
        this.checkIfMethodIsSupported('solana_signTransaction');
        const serializedTransaction = this.serializeTransaction(transaction);
        const result = await this.internalRequest('solana_signTransaction', {
            transaction: serializedTransaction,
            pubkey: this.getAccount(true).address,
            ...this.getRawRPCParams(transaction)
        });
        if ('signature' in result) {
            const decoded = base58.decode(result.signature);
            transaction.addSignature(new PublicKey(this.getAccount(true).publicKey), Buffer.from(decoded));
            return transaction;
        }
        const decodedTransaction = Buffer.from(result.transaction, 'base64');
        if (isVersionedTransaction(transaction)) {
            return VersionedTransaction.deserialize(new Uint8Array(decodedTransaction));
        }
        return Transaction.from(decodedTransaction);
    }
    async signAndSendTransaction(transaction, sendOptions) {
        this.checkIfMethodIsSupported('solana_signAndSendTransaction');
        const serializedTransaction = this.serializeTransaction(transaction);
        const result = await this.internalRequest('solana_signAndSendTransaction', {
            transaction: serializedTransaction,
            pubkey: this.getAccount(true).address,
            sendOptions
        });
        this.emit('pendingTransaction', undefined);
        return result.signature;
    }
    async sendTransaction(transaction, connection, options) {
        const signedTransaction = await this.signTransaction(transaction);
        const signature = await connection.sendRawTransaction(signedTransaction.serialize(), options);
        this.emit('pendingTransaction', undefined);
        return signature;
    }
    async signAllTransactions(transactions) {
        try {
            this.checkIfMethodIsSupported('solana_signAllTransactions');
            const result = await this.internalRequest('solana_signAllTransactions', {
                transactions: transactions.map(transaction => this.serializeTransaction(transaction))
            });
            return result.transactions.map((serializedTransaction, index) => {
                const transaction = transactions[index];
                if (!transaction) {
                    throw new Error('Invalid transactions response');
                }
                const decodedTransaction = Buffer.from(serializedTransaction, 'base64');
                if (isVersionedTransaction(transaction)) {
                    return VersionedTransaction.deserialize(new Uint8Array(decodedTransaction));
                }
                this.emit('pendingTransaction', undefined);
                return Transaction.from(decodedTransaction);
            });
        }
        catch (error) {
            if (error instanceof WalletConnectMethodNotSupportedError) {
                const signedTransactions = [];
                for (const transaction of transactions) {
                    signedTransactions.push(await this.signTransaction(transaction));
                }
                return signedTransactions;
            }
            throw error;
        }
    }
    request(args) {
        return this.internalRequest(args.method, args.params);
    }
    async getAccounts() {
        const accounts = (this.session?.namespaces['solana']?.accounts || []);
        return Promise.resolve(accounts.map(account => ({
            namespace: this.chain,
            address: ParseUtil.parseCaipAddress(account).address,
            type: 'eoa'
        })));
    }
    setDefaultChain(chainId) {
        this.provider.setDefaultChain(chainId);
    }
    internalRequest(method, params) {
        const chain = this.chains.find(c => this.getActiveChain()?.id === c.id);
        let chainId = chain?.caipNetworkId;
        switch (chainId) {
            case SolConstantsUtil.CHAIN_IDS.Mainnet:
                if (!this.sessionChains.includes(SolConstantsUtil.CHAIN_IDS.Mainnet)) {
                    chainId = SolConstantsUtil.CHAIN_IDS.Deprecated_Mainnet;
                }
                break;
            case SolConstantsUtil.CHAIN_IDS.Devnet:
                if (!this.sessionChains.includes(SolConstantsUtil.CHAIN_IDS.Devnet)) {
                    chainId = SolConstantsUtil.CHAIN_IDS.Deprecated_Devnet;
                }
                break;
            default:
                break;
        }
        return this.provider?.request({
            method,
            params
        }, chainId);
    }
    get sessionChains() {
        return WcHelpersUtil.getChainsFromNamespaces(this.session?.namespaces);
    }
    serializeTransaction(transaction) {
        return Buffer.from(new Uint8Array(transaction.serialize({ verifySignatures: false }))).toString('base64');
    }
    getAccount(required) {
        const account = this.session?.namespaces['solana']?.accounts[0];
        if (!account) {
            if (required) {
                throw new Error('Account not found');
            }
            return undefined;
        }
        const address = account.split(':')[2];
        if (!address) {
            if (required) {
                throw new Error('Address not found');
            }
            return undefined;
        }
        return {
            address,
            publicKey: base58.decode(address)
        };
    }
    getRawRPCParams(transaction) {
        if (isVersionedTransaction(transaction)) {
            return {};
        }
        return {
            feePayer: transaction.feePayer?.toBase58() ?? '',
            instructions: transaction.instructions.map(instruction => ({
                data: base58.encode(new Uint8Array(instruction.data)),
                keys: instruction.keys.map(key => ({
                    isWritable: key.isWritable,
                    isSigner: key.isSigner,
                    pubkey: key.pubkey.toBase58()
                })),
                programId: instruction.programId.toBase58()
            })),
            recentBlockhash: transaction.recentBlockhash ?? ''
        };
    }
    checkIfMethodIsSupported(method) {
        if (!this.session?.namespaces['solana']?.methods.includes(method)) {
            throw new WalletConnectMethodNotSupportedError(method);
        }
    }
}
_SolanaWalletConnectProvider_version = new WeakMap();
//# sourceMappingURL=SolanaWalletConnectProvider.js.map