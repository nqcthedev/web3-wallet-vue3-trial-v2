{
  "version": 3,
  "sources": ["../../@wagmi/vue/src/plugin.ts", "../../@wagmi/vue/src/version.ts", "../../@wagmi/vue/src/utils/getVersion.ts", "../../@wagmi/vue/src/errors/base.ts", "../../@wagmi/vue/src/errors/plugin.ts", "../../@wagmi/core/src/query/utils.ts", "../../@wagmi/core/src/query/connect.ts", "../../@wagmi/core/src/query/disconnect.ts", "../../@wagmi/core/src/query/estimateGas.ts", "../../@wagmi/core/src/query/getBalance.ts", "../../@wagmi/core/src/query/getBlockNumber.ts", "../../@wagmi/core/src/query/getBytecode.ts", "../../@wagmi/core/src/query/getConnectorClient.ts", "../../@wagmi/core/src/query/getEnsAddress.ts", "../../@wagmi/core/src/query/getEnsAvatar.ts", "../../@wagmi/core/src/query/getEnsName.ts", "../../@wagmi/core/src/query/getTransaction.ts", "../../@wagmi/core/src/query/getTransactionReceipt.ts", "../../@wagmi/core/src/query/readContract.ts", "../../@wagmi/core/src/query/reconnect.ts", "../../@wagmi/core/src/query/sendTransaction.ts", "../../@wagmi/core/src/query/signMessage.ts", "../../@wagmi/core/src/query/signTypedData.ts", "../../@wagmi/core/src/query/simulateContract.ts", "../../@wagmi/core/src/query/switchChain.ts", "../../@wagmi/core/src/query/switchConnection.ts", "../../@wagmi/core/src/query/waitForTransactionReceipt.ts", "../../@wagmi/core/src/query/writeContract.ts", "../../@wagmi/vue/src/utils/cloneDeep.ts", "../../@wagmi/vue/src/utils/query.ts", "../../@wagmi/vue/src/composables/useConfig.ts", "../../@wagmi/vue/src/composables/useChainId.ts", "../../@wagmi/vue/src/composables/useBalance.ts", "../../@wagmi/vue/src/composables/useWatchBlockNumber.ts", "../../@wagmi/vue/src/composables/useBlockNumber.ts", "../../@wagmi/vue/src/composables/useBytecode.ts", "../../@wagmi/core/src/actions/watchChains.ts", "../../@wagmi/vue/src/composables/useChains.ts", "../../@wagmi/vue/src/composables/useClient.ts", "../../@wagmi/vue/src/composables/useConnectors.ts", "../../@wagmi/vue/src/composables/useConnect.ts", "../../@wagmi/vue/src/utils/updateState.ts", "../../@wagmi/vue/src/composables/useConnection.ts", "../../@wagmi/vue/src/composables/useConnectionEffect.ts", "../../@wagmi/vue/src/composables/useConnections.ts", "../../@wagmi/vue/src/composables/useConnectorClient.ts", "../../@wagmi/vue/src/composables/useDisconnect.ts", "../../@wagmi/vue/src/composables/useEnsAddress.ts", "../../@wagmi/vue/src/composables/useEnsAvatar.ts", "../../@wagmi/vue/src/composables/useEnsName.ts", "../../@wagmi/vue/src/composables/useEstimateGas.ts", "../../@wagmi/vue/src/composables/useReadContract.ts", "../../@wagmi/vue/src/composables/useReconnect.ts", "../../@wagmi/vue/src/composables/useSendTransaction.ts", "../../@wagmi/vue/src/composables/useSignMessage.ts", "../../@wagmi/vue/src/composables/useSignTypedData.ts", "../../@wagmi/vue/src/composables/useSimulateContract.ts", "../../@wagmi/vue/src/composables/useSwitchChain.ts", "../../@wagmi/vue/src/composables/useSwitchConnection.ts", "../../@wagmi/vue/src/composables/useTransaction.ts", "../../@wagmi/vue/src/composables/useTransactionReceipt.ts", "../../@wagmi/vue/src/composables/useWaitForTransactionReceipt.ts", "../../@wagmi/vue/src/composables/useWatchContractEvent.ts", "../../@wagmi/vue/src/composables/useWriteContract.ts"],
  "sourcesContent": ["import { hydrate, type ResolvedRegister, type State } from '@wagmi/core'\nimport type { Plugin } from 'vue'\n\nexport const configKey = Symbol()\n\nexport type WagmiPluginOptions = {\n  config: ResolvedRegister['config']\n  initialState?: State | undefined\n  reconnectOnMount?: boolean | undefined\n}\n\nexport const WagmiPlugin = {\n  install(app, options) {\n    const { config, reconnectOnMount = true } = options\n    app.provide(configKey, config)\n    // TODO: check this works in SSR env.\n    // - reconnect on mount.\n    // - hydrate initial state.\n    const { onMount } = hydrate(config, { ...options, reconnectOnMount })\n    onMount()\n  },\n} satisfies Plugin<WagmiPluginOptions>\n", "export const version = '0.4.11'\n", "import { version } from '../version.js'\n\nexport const getVersion = () => `@wagmi/vue@${version}`\n", "import { BaseError as CoreError } from '@wagmi/core'\n\nimport { getVersion } from '../utils/getVersion.js'\n\nexport type BaseErrorType = BaseError & { name: 'WagmiError' }\nexport class BaseError extends CoreError {\n  override name = 'WagmiError'\n  override get docsBaseUrl() {\n    return 'https://wagmi.sh/vue'\n  }\n  override get version() {\n    return getVersion()\n  }\n}\n", "import { BaseError } from './base.js'\n\nexport type WagmiPluginNotFoundErrorType = WagmiPluginNotFoundError & {\n  name: 'WagmiPluginNotFoundError'\n}\nexport class WagmiPluginNotFoundError extends BaseError {\n  override name = 'WagmiPluginNotFoundError'\n  constructor() {\n    super(\n      'No `config` found in Vue context, use `WagmiPlugin` to properly initialize the library.',\n      {\n        docsPath: '/api/TODO',\n      },\n    )\n  }\n}\n\nexport type WagmiInjectionContextErrorType = WagmiInjectionContextError & {\n  name: 'WagmiInjectionContextError'\n}\nexport class WagmiInjectionContextError extends BaseError {\n  override name = 'WagmiInjectionContextError'\n  constructor() {\n    super(\n      'Wagmi composables can only be used inside `setup()` function or functions that support injection context.',\n      {\n        docsPath: '/api/TODO',\n      },\n    )\n  }\n}\n", "import { type QueryKey, replaceEqualDeep } from '@tanstack/query-core'\nimport type { Connector } from '../createConfig.js'\nimport type { Compute, StrictOmit } from '../types/utils.js'\n\nexport function structuralSharing<data>(\n  oldData: data | undefined,\n  newData: data,\n): data {\n  return replaceEqualDeep(oldData, newData)\n}\n\nexport function hashFn(queryKey: QueryKey): string {\n  return JSON.stringify(queryKey, (_, value) => {\n    if (isPlainObject(value))\n      return Object.keys(value)\n        .sort()\n        .reduce((result, key) => {\n          result[key] = value[key]\n          return result\n        }, {} as any)\n    if (typeof value === 'bigint') return value.toString()\n    return value\n  })\n}\n\n// biome-ignore lint/complexity/noBannedTypes: using\nfunction isPlainObject(value: any): value is Object {\n  if (!hasObjectPrototype(value)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = value.constructor\n  if (typeof ctor === 'undefined') return true\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) return false\n\n  // If constructor does not have an Object-specific method\n  // biome-ignore lint/suspicious/noPrototypeBuiltins: using\n  if (!prot.hasOwnProperty('isPrototypeOf')) return false\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function filterQueryOptions<\n  type extends Record<string, unknown> & { connector?: Connector | undefined },\n>(\n  options: type,\n): Compute<\n  StrictOmit<type, 'abi' | 'config' | 'connector' | 'query' | 'watch'> &\n    (type extends { connector?: Connector | undefined }\n      ? { connectorUid?: string }\n      : unknown)\n> {\n  // destructuring is super fast\n  // biome-ignore format: no formatting\n  const {\n    // import('@tanstack/query-core').QueryOptions\n    // biome-ignore lint/correctness/noUnusedVariables: tossing\n    _defaulted, behavior, gcTime, initialData, initialDataUpdatedAt, maxPages, meta, networkMode, queryFn, queryHash, queryKey, queryKeyHashFn, retry, retryDelay, structuralSharing,\n\n    // import('@tanstack/query-core').InfiniteQueryObserverOptions\n    // biome-ignore lint/correctness/noUnusedVariables: tossing\n    getPreviousPageParam, getNextPageParam, initialPageParam,\n\n    // import('@tanstack/react-query').UseQueryOptions\n    // biome-ignore lint/correctness/noUnusedVariables: tossing\n    _optimisticResults, enabled, notifyOnChangeProps, placeholderData, refetchInterval, refetchIntervalInBackground, refetchOnMount, refetchOnReconnect, refetchOnWindowFocus, retryOnMount, select, staleTime, suspense, throwOnError,\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // wagmi\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // biome-ignore lint/correctness/noUnusedVariables: tossing\n    abi, config, connector, query, watch,\n    ...rest\n  } = options\n  if (connector) return { connectorUid: connector?.uid, ...rest } as never\n  return rest as never\n}\n", "import type { MutateOptions, MutationOptions } from '@tanstack/query-core'\n\nimport {\n  type ConnectErrorType,\n  type ConnectParameters,\n  type ConnectReturnType,\n  connect,\n} from '../actions/connect.js'\nimport type { CreateConnectorFn } from '../connectors/createConnector.js'\nimport type { Config, Connector } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\n\nexport function connectMutationOptions<config extends Config>(config: config) {\n  return {\n    mutationFn(variables) {\n      return connect(config, variables)\n    },\n    mutationKey: ['connect'],\n  } as const satisfies MutationOptions<\n    ConnectData<config, Connector | CreateConnectorFn, boolean>,\n    ConnectErrorType,\n    ConnectVariables<config, Connector | CreateConnectorFn, boolean>\n  >\n}\n\nexport type ConnectData<\n  config extends Config,\n  connector extends Connector | CreateConnectorFn,\n  withCapabilities extends boolean,\n> = ConnectReturnType<config, connector, withCapabilities>\n\nexport type ConnectVariables<\n  config extends Config,\n  connector extends Connector | CreateConnectorFn,\n  withCapabilities extends boolean,\n> = ConnectParameters<config, connector, withCapabilities>\n\nexport type ConnectMutate<config extends Config, context = unknown> = <\n  connector extends\n    | config['connectors'][number]\n    | Connector\n    | CreateConnectorFn,\n  withCapabilities extends boolean = false,\n>(\n  variables: ConnectVariables<config, connector, withCapabilities>,\n  options?:\n    | Compute<\n        MutateOptions<\n          ConnectData<config, connector, withCapabilities>,\n          ConnectErrorType,\n          Compute<ConnectVariables<config, connector, withCapabilities>>,\n          context\n        >\n      >\n    | undefined,\n) => void\n\nexport type ConnectMutateAsync<config extends Config, context = unknown> = <\n  connector extends\n    | config['connectors'][number]\n    | Connector\n    | CreateConnectorFn,\n  withCapabilities extends boolean = false,\n>(\n  variables: ConnectVariables<config, connector, withCapabilities>,\n  options?:\n    | Compute<\n        MutateOptions<\n          ConnectData<config, connector, withCapabilities>,\n          ConnectErrorType,\n          Compute<ConnectVariables<config, connector, withCapabilities>>,\n          context\n        >\n      >\n    | undefined,\n) => Promise<ConnectData<config, connector, withCapabilities>>\n", "import type { MutationOptions } from '@tanstack/query-core'\n\nimport {\n  type DisconnectErrorType,\n  type DisconnectParameters,\n  type DisconnectReturnType,\n  disconnect,\n} from '../actions/disconnect.js'\nimport type { Config } from '../createConfig.js'\nimport type { Mutate, MutateAsync } from './types.js'\n\nexport function disconnectMutationOptions<config extends Config>(\n  config: config,\n) {\n  return {\n    mutationFn(variables) {\n      return disconnect(config, variables)\n    },\n    mutationKey: ['disconnect'],\n  } as const satisfies MutationOptions<\n    DisconnectData,\n    DisconnectErrorType,\n    DisconnectVariables\n  >\n}\n\nexport type DisconnectData = DisconnectReturnType\n\nexport type DisconnectVariables = DisconnectParameters | undefined\n\nexport type DisconnectMutate<context = unknown> = Mutate<\n  DisconnectData,\n  DisconnectErrorType,\n  DisconnectVariables,\n  context\n>\n\nexport type DisconnectMutateAsync<context = unknown> = MutateAsync<\n  DisconnectData,\n  DisconnectErrorType,\n  DisconnectVariables,\n  context\n>\n", "import {\n  type EstimateGasErrorType,\n  type EstimateGasParameters,\n  type EstimateGasReturnType,\n  estimateGas,\n} from '../actions/estimateGas.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, UnionExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type EstimateGasOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = EstimateGasData,\n> = Compute<\n  UnionExactPartial<EstimateGasParameters<config, chainId>> & ScopeKeyParameter\n> &\n  QueryParameter<\n    EstimateGasQueryFnData,\n    EstimateGasErrorType,\n    selectData,\n    EstimateGasQueryKey<config, chainId>\n  >\n\nexport function estimateGasQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = EstimateGasData,\n>(\n  config: config,\n  options: EstimateGasOptions<config, chainId, selectData> = {} as any,\n): EstimateGasQueryOptions<config, chainId, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      (options.account || options.connector) &&\n        (options.query?.enabled ?? true),\n    ),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.account && !options.connector)\n        throw new Error('account or connector is required')\n      return estimateGas(config, {\n        ...(parameters as any),\n        account: parameters.account,\n        connector: options.connector,\n      })\n    },\n    queryKey: estimateGasQueryKey(options),\n  }\n}\n\nexport type EstimateGasQueryFnData = EstimateGasReturnType\n\nexport type EstimateGasData = EstimateGasQueryFnData\n\nexport function estimateGasQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n>(\n  options: Compute<\n    UnionExactPartial<EstimateGasParameters<config, chainId>> &\n      ScopeKeyParameter\n  > = {} as any,\n) {\n  return ['estimateGas', filterQueryOptions(options)] as const\n}\n\nexport type EstimateGasQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n> = ReturnType<typeof estimateGasQueryKey<config, chainId>>\n\nexport type EstimateGasQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = EstimateGasData,\n> = QueryOptions<\n  EstimateGasQueryFnData,\n  EstimateGasErrorType,\n  selectData,\n  EstimateGasQueryKey<config, chainId>\n>\n", "import {\n  type GetBalanceErrorType,\n  type GetBalanceParameters,\n  type GetBalanceReturnType,\n  getBalance,\n} from '../actions/getBalance.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetBalanceOptions<\n  config extends Config,\n  selectData = GetBalanceData,\n> = Compute<ExactPartial<GetBalanceParameters<config>> & ScopeKeyParameter> &\n  QueryParameter<\n    GetBalanceQueryFnData,\n    GetBalanceErrorType,\n    selectData,\n    GetBalanceQueryKey<config>\n  >\n\nexport function getBalanceQueryOptions<\n  config extends Config,\n  selectData = GetBalanceData,\n>(\n  config: config,\n  options: GetBalanceOptions<config, selectData> = {},\n): GetBalanceQueryOptions<config, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(options.address && (options.query?.enabled ?? true)),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.address) throw new Error('address is required')\n      const balance = await getBalance(config, {\n        ...(parameters as GetBalanceParameters),\n        address: parameters.address,\n      })\n      return balance ?? null\n    },\n    queryKey: getBalanceQueryKey(options),\n  }\n}\n\nexport type GetBalanceQueryFnData = Compute<GetBalanceReturnType>\n\nexport type GetBalanceData = GetBalanceQueryFnData\n\nexport function getBalanceQueryKey<config extends Config>(\n  options: Compute<\n    ExactPartial<GetBalanceParameters<config>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['balance', filterQueryOptions(options)] as const\n}\n\nexport type GetBalanceQueryKey<config extends Config> = ReturnType<\n  typeof getBalanceQueryKey<config>\n>\n\nexport type GetBalanceQueryOptions<\n  config extends Config,\n  selectData = GetBalanceData,\n> = QueryOptions<\n  GetBalanceQueryFnData,\n  GetBalanceErrorType,\n  selectData,\n  GetBalanceQueryKey<config>\n>\n", "import {\n  type GetBlockNumberErrorType,\n  type GetBlockNumberParameters,\n  type GetBlockNumberReturnType,\n  getBlockNumber,\n} from '../actions/getBlockNumber.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetBlockNumberOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetBlockNumberData,\n> = Compute<\n  ExactPartial<GetBlockNumberParameters<config, chainId>> & ScopeKeyParameter\n> &\n  QueryParameter<\n    GetBlockNumberQueryFnData,\n    GetBlockNumberErrorType,\n    selectData,\n    GetBlockNumberQueryKey<config, chainId>\n  >\n\nexport function getBlockNumberQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetBlockNumberData,\n>(\n  config: config,\n  options: GetBlockNumberOptions<config, chainId, selectData> = {},\n): GetBlockNumberQueryOptions<config, chainId, selectData> {\n  return {\n    ...options.query,\n    gcTime: 0,\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      const blockNumber = await getBlockNumber(config, parameters)\n      return blockNumber ?? null\n    },\n    queryKey: getBlockNumberQueryKey(options),\n  }\n}\n\nexport type GetBlockNumberQueryFnData = GetBlockNumberReturnType\n\nexport type GetBlockNumberData = GetBlockNumberQueryFnData\n\nexport function getBlockNumberQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(\n  options: Compute<\n    ExactPartial<GetBlockNumberParameters<config, chainId>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['blockNumber', filterQueryOptions(options)] as const\n}\n\nexport type GetBlockNumberQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = ReturnType<typeof getBlockNumberQueryKey<config, chainId>>\n\nexport type GetBlockNumberQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetBlockNumberData,\n> = QueryOptions<\n  GetBlockNumberQueryFnData,\n  GetBlockNumberErrorType,\n  selectData,\n  GetBlockNumberQueryKey<config, chainId>\n>\n", "import {\n  type GetBytecodeErrorType,\n  type GetBytecodeParameters,\n  type GetBytecodeReturnType,\n  getBytecode,\n} from '../actions/getBytecode.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetBytecodeOptions<\n  config extends Config,\n  selectData = GetBytecodeData,\n> = Compute<ExactPartial<GetBytecodeParameters<config>> & ScopeKeyParameter> &\n  QueryParameter<\n    GetBytecodeQueryFnData,\n    GetBytecodeErrorType,\n    selectData,\n    GetBytecodeQueryKey<config>\n  >\n\nexport function getBytecodeQueryOptions<\n  config extends Config,\n  selectData = GetBytecodeData,\n>(\n  config: config,\n  options: GetBytecodeOptions<config, selectData> = {},\n): GetBytecodeQueryOptions<config, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(options.address && (options.query?.enabled ?? true)),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.address) throw new Error('address is required')\n      const bytecode = await getBytecode(config, {\n        ...(parameters as any),\n        address: parameters.address,\n      })\n      return (bytecode ?? null) as any\n    },\n    queryKey: getBytecodeQueryKey(options),\n  }\n}\n\nexport type GetBytecodeQueryFnData = GetBytecodeReturnType\n\nexport type GetBytecodeData = GetBytecodeQueryFnData\n\nexport function getBytecodeQueryKey<config extends Config>(\n  options: Compute<\n    ExactPartial<GetBytecodeParameters<config>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['getBytecode', filterQueryOptions(options)] as const\n}\n\nexport type GetBytecodeQueryKey<config extends Config> = ReturnType<\n  typeof getBytecodeQueryKey<config>\n>\n\nexport type GetBytecodeQueryOptions<\n  config extends Config,\n  selectData = GetBytecodeData,\n> = QueryOptions<\n  GetBytecodeQueryFnData,\n  GetBytecodeErrorType,\n  selectData,\n  GetBytecodeQueryKey<config>\n>\n", "import {\n  type GetConnectorClientErrorType,\n  type GetConnectorClientParameters,\n  type GetConnectorClientReturnType,\n  getConnectorClient,\n} from '../actions/getConnectorClient.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetConnectorClientOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetConnectorClientData<config, chainId>,\n> = Compute<\n  ExactPartial<GetConnectorClientParameters<config, chainId>> &\n    ScopeKeyParameter\n> &\n  Omit<\n    QueryParameter<\n      GetConnectorClientQueryFnData<config, chainId>,\n      GetConnectorClientErrorType,\n      selectData,\n      GetConnectorClientQueryKey<config, chainId>\n    >,\n    'gcTime' | 'staleTime'\n  >\n\nexport function getConnectorClientQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetConnectorClientData<config, chainId>,\n>(\n  config: config,\n  options: GetConnectorClientOptions<config, chainId, selectData> = {},\n): GetConnectorClientQueryOptions<config, chainId, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      options.connector?.getProvider && (options.query?.enabled ?? true),\n    ),\n    gcTime: 0,\n    queryFn: async (context) => {\n      const [, { connectorUid: _, scopeKey: __, ...parameters }] =\n        context.queryKey\n      return getConnectorClient(config, {\n        ...parameters,\n        connector: options.connector,\n      }) as unknown as Promise<GetConnectorClientReturnType<config, chainId>>\n    },\n    queryKey: getConnectorClientQueryKey(options),\n    staleTime: Number.POSITIVE_INFINITY,\n  }\n}\n\nexport type GetConnectorClientQueryFnData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = GetConnectorClientReturnType<config, chainId>\n\nexport type GetConnectorClientData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = GetConnectorClientQueryFnData<config, chainId>\n\nexport function getConnectorClientQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(\n  options: Compute<\n    ExactPartial<GetConnectorClientParameters<config, chainId>> &\n      ScopeKeyParameter\n  > = {},\n) {\n  return ['connectorClient', filterQueryOptions(options)] as const\n}\n\nexport type GetConnectorClientQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = ReturnType<typeof getConnectorClientQueryKey<config, chainId>>\n\nexport type GetConnectorClientQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetConnectorClientData<config, chainId>,\n> = QueryOptions<\n  GetConnectorClientQueryFnData<config, chainId>,\n  GetConnectorClientErrorType,\n  selectData,\n  GetConnectorClientQueryKey<config, chainId>\n>\n", "import {\n  type GetEnsAddressErrorType,\n  type GetEnsAddressParameters,\n  type GetEnsAddressReturnType,\n  getEnsAddress,\n} from '../actions/getEnsAddress.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetEnsAddressOptions<\n  config extends Config,\n  selectData = GetEnsAddressData,\n> = Compute<ExactPartial<GetEnsAddressParameters<config>> & ScopeKeyParameter> &\n  QueryParameter<\n    GetEnsAddressQueryFnData,\n    GetEnsAddressErrorType,\n    selectData,\n    GetEnsAddressQueryKey<config>\n  >\n\nexport function getEnsAddressQueryOptions<\n  config extends Config,\n  selectData = GetEnsAddressData,\n>(\n  config: config,\n  options: GetEnsAddressOptions<config, selectData> = {},\n): GetEnsAddressQueryOptions<config, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(options.name && (options.query?.enabled ?? true)),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.name) throw new Error('name is required')\n      return getEnsAddress(config, { ...parameters, name: parameters.name })\n    },\n    queryKey: getEnsAddressQueryKey(options),\n  }\n}\n\nexport type GetEnsAddressQueryFnData = GetEnsAddressReturnType\n\nexport type GetEnsAddressData = GetEnsAddressQueryFnData\n\nexport function getEnsAddressQueryKey<config extends Config>(\n  options: Compute<\n    ExactPartial<GetEnsAddressParameters<config>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['ensAddress', filterQueryOptions(options)] as const\n}\n\nexport type GetEnsAddressQueryKey<config extends Config> = ReturnType<\n  typeof getEnsAddressQueryKey<config>\n>\n\nexport type GetEnsAddressQueryOptions<\n  config extends Config,\n  selectData = GetEnsAddressData,\n> = QueryOptions<\n  GetEnsAddressQueryFnData,\n  GetEnsAddressErrorType,\n  selectData,\n  GetEnsAddressQueryKey<config>\n>\n", "import {\n  type GetEnsAvatarErrorType,\n  type GetEnsAvatarParameters,\n  type GetEnsAvatarReturnType,\n  getEnsAvatar,\n} from '../actions/getEnsAvatar.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetEnsAvatarOptions<\n  config extends Config,\n  selectData = GetEnsAvatarData,\n> = Compute<ExactPartial<GetEnsAvatarParameters<config>> & ScopeKeyParameter> &\n  QueryParameter<\n    GetEnsAvatarQueryFnData,\n    GetEnsAvatarErrorType,\n    selectData,\n    GetEnsAvatarQueryKey<config>\n  >\n\nexport function getEnsAvatarQueryOptions<\n  config extends Config,\n  selectData = GetEnsAvatarData,\n>(\n  config: config,\n  options: GetEnsAvatarOptions<config, selectData> = {},\n): GetEnsAvatarQueryOptions<config, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(options.name && (options.query?.enabled ?? true)),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.name) throw new Error('name is required')\n      return getEnsAvatar(config, { ...parameters, name: parameters.name })\n    },\n    queryKey: getEnsAvatarQueryKey(options),\n  }\n}\n\nexport type GetEnsAvatarQueryFnData = GetEnsAvatarReturnType\n\nexport type GetEnsAvatarData = GetEnsAvatarQueryFnData\n\nexport function getEnsAvatarQueryKey<config extends Config>(\n  options: Compute<\n    ExactPartial<GetEnsAvatarParameters<config>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['ensAvatar', filterQueryOptions(options)] as const\n}\n\nexport type GetEnsAvatarQueryKey<config extends Config> = ReturnType<\n  typeof getEnsAvatarQueryKey<config>\n>\n\nexport type GetEnsAvatarQueryOptions<\n  config extends Config,\n  selectData = GetEnsAvatarData,\n> = QueryOptions<\n  GetEnsAvatarQueryFnData,\n  GetEnsAvatarErrorType,\n  selectData,\n  GetEnsAvatarQueryKey<config>\n>\n", "import {\n  type GetEnsNameErrorType,\n  type GetEnsNameParameters,\n  type GetEnsNameReturnType,\n  getEnsName,\n} from '../actions/getEnsName.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetEnsNameOptions<\n  config extends Config,\n  selectData = GetEnsNameData,\n> = Compute<ExactPartial<GetEnsNameParameters<config>> & ScopeKeyParameter> &\n  QueryParameter<\n    GetEnsNameQueryFnData,\n    GetEnsNameErrorType,\n    selectData,\n    GetEnsNameQueryKey<config>\n  >\n\nexport function getEnsNameQueryOptions<\n  config extends Config,\n  selectData = GetEnsNameData,\n>(\n  config: config,\n  options: GetEnsNameOptions<config, selectData> = {},\n): GetEnsNameQueryOptions<config, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(options.address && (options.query?.enabled ?? true)),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.address) throw new Error('address is required')\n      return getEnsName(config, { ...parameters, address: parameters.address })\n    },\n    queryKey: getEnsNameQueryKey(options),\n  }\n}\n\nexport type GetEnsNameQueryFnData = GetEnsNameReturnType\n\nexport type GetEnsNameData = GetEnsNameQueryFnData\n\nexport function getEnsNameQueryKey<config extends Config>(\n  options: Compute<\n    ExactPartial<GetEnsNameParameters<config>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['ensName', filterQueryOptions(options)] as const\n}\n\nexport type GetEnsNameQueryKey<config extends Config> = ReturnType<\n  typeof getEnsNameQueryKey<config>\n>\n\nexport type GetEnsNameQueryOptions<\n  config extends Config,\n  selectData = GetEnsNameData,\n> = QueryOptions<\n  GetEnsNameQueryFnData,\n  GetEnsNameErrorType,\n  selectData,\n  GetEnsNameQueryKey<config>\n>\n", "import {\n  type GetTransactionErrorType,\n  type GetTransactionParameters,\n  type GetTransactionReturnType,\n  getTransaction,\n} from '../actions/getTransaction.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetTransactionOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetTransactionData<config, chainId>,\n> = Compute<\n  ExactPartial<GetTransactionParameters<config, chainId>> & ScopeKeyParameter\n> &\n  QueryParameter<\n    GetTransactionQueryFnData<config, chainId>,\n    GetTransactionErrorType,\n    selectData,\n    GetTransactionQueryKey<config, chainId>\n  >\n\nexport function getTransactionQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetTransactionData<config, chainId>,\n>(\n  config: config,\n  options: GetTransactionOptions<config, chainId, selectData> = {},\n): GetTransactionQueryOptions<config, chainId, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      (options.hash ||\n        (options.index &&\n          (options.blockHash || options.blockNumber || options.blockTag))) &&\n        (options.query?.enabled ?? true),\n    ),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (\n        !(\n          parameters.hash ||\n          (parameters.index &&\n            (parameters.blockHash ||\n              parameters.blockNumber ||\n              parameters.blockTag))\n        )\n      )\n        throw new Error(\n          'hash OR index AND blockHash, blockNumber, blockTag is required',\n        )\n      return getTransaction(\n        config,\n        parameters as GetTransactionParameters,\n      ) as unknown as Promise<GetTransactionQueryFnData<config, chainId>>\n    },\n    queryKey: getTransactionQueryKey(options),\n  }\n}\n\nexport type GetTransactionQueryFnData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = GetTransactionReturnType<config, chainId>\n\nexport type GetTransactionData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = GetTransactionQueryFnData<config, chainId>\n\nexport function getTransactionQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(\n  options: Compute<\n    ExactPartial<GetTransactionParameters<config, chainId>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['transaction', filterQueryOptions(options)] as const\n}\n\nexport type GetTransactionQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = ReturnType<typeof getTransactionQueryKey<config, chainId>>\n\nexport type GetTransactionQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetTransactionData<config, chainId>,\n> = QueryOptions<\n  GetTransactionQueryFnData<config, chainId>,\n  GetTransactionErrorType,\n  selectData,\n  GetTransactionQueryKey<config, chainId>\n>\n", "import type { GetTransactionReceiptReturnType } from '../actions/getTransactionReceipt.js'\nimport {\n  type GetTransactionReceiptErrorType,\n  type GetTransactionReceiptParameters,\n  getTransactionReceipt,\n} from '../actions/getTransactionReceipt.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetTransactionReceiptOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetTransactionReceiptData<config, chainId>,\n> = Compute<\n  ExactPartial<GetTransactionReceiptParameters<config, chainId>> &\n    ScopeKeyParameter\n> &\n  QueryParameter<\n    GetTransactionReceiptQueryFnData<config, chainId>,\n    GetTransactionReceiptErrorType,\n    selectData,\n    GetTransactionReceiptQueryKey<config, chainId>\n  >\n\nexport function getTransactionReceiptQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetTransactionReceiptData<config, chainId>,\n>(\n  config: config,\n  options: GetTransactionReceiptOptions<config, chainId, selectData> = {},\n): GetTransactionReceiptQueryOptions<config, chainId, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(options.hash && (options.query?.enabled ?? true)),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.hash) throw new Error('hash is required')\n      return getTransactionReceipt(config, {\n        ...(parameters as any),\n        hash: parameters.hash,\n      })\n    },\n    queryKey: getTransactionReceiptQueryKey(options),\n  }\n}\n\nexport type GetTransactionReceiptQueryFnData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = GetTransactionReceiptReturnType<config, chainId>\n\nexport type GetTransactionReceiptData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = GetTransactionReceiptQueryFnData<config, chainId>\n\nexport function getTransactionReceiptQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(\n  options: Compute<\n    ExactPartial<GetTransactionReceiptParameters<config, chainId>> &\n      ScopeKeyParameter\n  > = {},\n) {\n  return ['getTransactionReceipt', filterQueryOptions(options)] as const\n}\n\nexport type GetTransactionReceiptQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = ReturnType<typeof getTransactionReceiptQueryKey<config, chainId>>\n\nexport type GetTransactionReceiptQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetTransactionReceiptData<config, chainId>,\n> = QueryOptions<\n  GetTransactionReceiptQueryFnData<config, chainId>,\n  GetTransactionReceiptErrorType,\n  selectData,\n  GetTransactionReceiptQueryKey<config, chainId>\n>\n", "import type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'\nimport {\n  type ReadContractErrorType,\n  type ReadContractParameters,\n  type ReadContractReturnType,\n  readContract,\n} from '../actions/readContract.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { UnionExactPartial } from '../types/utils.js'\nimport { filterQueryOptions, structuralSharing } from './utils.js'\n\nexport type ReadContractOptions<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config,\n  selectData = ReadContractData<abi, functionName, args>,\n> = UnionExactPartial<ReadContractParameters<abi, functionName, args, config>> &\n  ScopeKeyParameter &\n  QueryParameter<\n    ReadContractQueryFnData<abi, functionName, args>,\n    ReadContractErrorType,\n    selectData,\n    ReadContractQueryKey<abi, functionName, args, config>\n  >\n\nexport function readContractQueryOptions<\n  config extends Config,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  selectData = ReadContractData<abi, functionName, args>,\n>(\n  config: config,\n  options: ReadContractOptions<abi, functionName, args, config> = {} as any,\n): ReadContractQueryOptions<abi, functionName, args, config, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      Boolean(options.address || ('code' in options && options.code)) &&\n        options.abi &&\n        options.functionName &&\n        (options.query?.enabled ?? true),\n    ),\n    // TODO: Support `signal` once Viem actions allow passthrough\n    // https://tkdodo.eu/blog/why-you-want-react-query#bonus-cancellation\n    queryFn: async (context) => {\n      if (!options.abi) throw new Error('abi is required')\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.functionName) throw new Error('functionName is required')\n      const result = await readContract(config, {\n        ...(parameters as any),\n        abi: options.abi,\n        address: parameters.address,\n        code:\n          'code' in parameters && parameters.code ? parameters.code : undefined,\n        functionName: parameters.functionName,\n      })\n      return result as ReadContractData<abi, functionName, args>\n    },\n    queryKey: readContractQueryKey(options as any) as any,\n    structuralSharing,\n  } as ReadContractQueryOptions<abi, functionName, args, config, selectData>\n}\n\nexport type ReadContractQueryFnData<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n> = ReadContractReturnType<abi, functionName, args>\n\nexport type ReadContractData<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n> = ReadContractQueryFnData<abi, functionName, args>\n\nexport function readContractQueryKey<\n  config extends Config,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n>(\n  options: UnionExactPartial<\n    ReadContractParameters<abi, functionName, args, config>\n  > &\n    ScopeKeyParameter = {} as any,\n) {\n  return ['readContract', filterQueryOptions(options)] as const\n}\n\nexport type ReadContractQueryKey<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config,\n> = ReturnType<typeof readContractQueryKey<config, abi, functionName, args>>\n\nexport type ReadContractQueryOptions<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config,\n  selectData = ReadContractData<abi, functionName, args>,\n> = QueryOptions<\n  ReadContractQueryFnData<abi, functionName, args>,\n  ReadContractErrorType,\n  selectData,\n  ReadContractQueryKey<abi, functionName, args, config>\n>\n", "import type { MutationOptions } from '@tanstack/query-core'\n\nimport {\n  type ReconnectErrorType,\n  type ReconnectParameters,\n  type ReconnectReturnType,\n  reconnect,\n} from '../actions/reconnect.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\nimport type { Mutate, MutateAsync } from './types.js'\n\nexport function reconnectMutationOptions(config: Config) {\n  return {\n    mutationFn(variables) {\n      return reconnect(config, variables)\n    },\n    mutationKey: ['reconnect'],\n  } as const satisfies MutationOptions<\n    ReconnectData,\n    ReconnectErrorType,\n    ReconnectVariables\n  >\n}\n\nexport type ReconnectData = Compute<ReconnectReturnType>\n\nexport type ReconnectVariables = ReconnectParameters | undefined\n\nexport type ReconnectMutate<context = unknown> = Mutate<\n  ReconnectData,\n  ReconnectErrorType,\n  ReconnectVariables,\n  context\n>\n\nexport type ReconnectMutateAsync<context = unknown> = MutateAsync<\n  ReconnectData,\n  ReconnectErrorType,\n  ReconnectVariables,\n  context\n>\n", "import type { MutateOptions, MutationOptions } from '@tanstack/query-core'\n\nimport {\n  type SendTransactionErrorType,\n  type SendTransactionParameters,\n  type SendTransactionReturnType,\n  sendTransaction,\n} from '../actions/sendTransaction.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\n\nexport function sendTransactionMutationOptions<config extends Config>(\n  config: config,\n) {\n  return {\n    mutationFn(variables) {\n      return sendTransaction(config, variables)\n    },\n    mutationKey: ['sendTransaction'],\n  } as const satisfies MutationOptions<\n    SendTransactionData,\n    SendTransactionErrorType,\n    SendTransactionVariables<config, config['chains'][number]['id']>\n  >\n}\n\nexport type SendTransactionData = Compute<SendTransactionReturnType>\n\nexport type SendTransactionVariables<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = SendTransactionParameters<config, chainId>\n\nexport type SendTransactionMutate<config extends Config, context = unknown> = <\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: SendTransactionVariables<config, chainId>,\n  options?:\n    | Compute<\n        MutateOptions<\n          SendTransactionData,\n          SendTransactionErrorType,\n          Compute<SendTransactionVariables<config, chainId>>,\n          context\n        >\n      >\n    | undefined,\n) => void\n\nexport type SendTransactionMutateAsync<\n  config extends Config,\n  context = unknown,\n> = <chainId extends config['chains'][number]['id']>(\n  variables: SendTransactionVariables<config, chainId>,\n  options?:\n    | Compute<\n        MutateOptions<\n          SendTransactionData,\n          SendTransactionErrorType,\n          Compute<SendTransactionVariables<config, chainId>>,\n          context\n        >\n      >\n    | undefined,\n) => Promise<SendTransactionData>\n", "import type { MutationOptions } from '@tanstack/query-core'\n\nimport {\n  type SignMessageErrorType,\n  type SignMessageParameters,\n  type SignMessageReturnType,\n  signMessage,\n} from '../actions/signMessage.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\nimport type { Mutate, MutateAsync } from './types.js'\n\nexport function signMessageMutationOptions(config: Config) {\n  return {\n    mutationFn(variables) {\n      return signMessage(config, variables)\n    },\n    mutationKey: ['signMessage'],\n  } as const satisfies MutationOptions<\n    SignMessageData,\n    SignMessageErrorType,\n    SignMessageVariables\n  >\n}\n\nexport type SignMessageData = SignMessageReturnType\n\nexport type SignMessageVariables = Compute<SignMessageParameters>\n\nexport type SignMessageMutate<context = unknown> = Mutate<\n  SignMessageData,\n  SignMessageErrorType,\n  SignMessageVariables,\n  context\n>\n\nexport type SignMessageMutateAsync<context = unknown> = MutateAsync<\n  SignMessageData,\n  SignMessageErrorType,\n  SignMessageVariables,\n  context\n>\n", "import type { MutateOptions, MutationOptions } from '@tanstack/query-core'\n\nimport type { TypedData } from 'viem'\nimport {\n  type SignTypedDataErrorType,\n  type SignTypedDataParameters,\n  type SignTypedDataReturnType,\n  signTypedData,\n} from '../actions/signTypedData.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\n\nexport function signTypedDataMutationOptions<config extends Config>(\n  config: config,\n) {\n  return {\n    mutationFn(variables) {\n      return signTypedData(config, variables)\n    },\n    mutationKey: ['signTypedData'],\n  } as const satisfies MutationOptions<\n    SignTypedDataData,\n    SignTypedDataErrorType,\n    SignTypedDataVariables\n  >\n}\n\nexport type SignTypedDataData = Compute<SignTypedDataReturnType>\n\nexport type SignTypedDataVariables<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  ///\n  primaryTypes = typedData extends TypedData ? keyof typedData : string,\n> = SignTypedDataParameters<typedData, primaryType, primaryTypes>\n\nexport type SignTypedDataMutate<context = unknown> = <\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  variables: SignTypedDataVariables<typedData, primaryType>,\n  options?:\n    | MutateOptions<\n        SignTypedDataData,\n        SignTypedDataErrorType,\n        SignTypedDataVariables<\n          typedData,\n          primaryType,\n          // use `primaryType` to make sure it's not union of all possible primary types\n          primaryType\n        >,\n        context\n      >\n    | undefined,\n) => void\n\nexport type SignTypedDataMutateAsync<context = unknown> = <\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  variables: SignTypedDataVariables<typedData, primaryType>,\n  options?:\n    | MutateOptions<\n        SignTypedDataData,\n        SignTypedDataErrorType,\n        SignTypedDataVariables<\n          typedData,\n          primaryType,\n          // use `primaryType` to make sure it's not union of all possible primary types\n          primaryType\n        >,\n        context\n      >\n    | undefined,\n) => Promise<SignTypedDataData>\n", "import type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'\n\nimport {\n  type SimulateContractErrorType,\n  type SimulateContractParameters,\n  type SimulateContractReturnType,\n  simulateContract,\n} from '../actions/simulateContract.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { UnionExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type SimulateContractOptions<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n  selectData = SimulateContractData<abi, functionName, args, config, chainId>,\n> = UnionExactPartial<\n  SimulateContractParameters<abi, functionName, args, config, chainId>\n> &\n  ScopeKeyParameter &\n  QueryParameter<\n    SimulateContractQueryFnData<abi, functionName, args, config, chainId>,\n    SimulateContractErrorType,\n    selectData,\n    SimulateContractQueryKey<abi, functionName, args, config, chainId>\n  >\n\nexport function simulateContractQueryOptions<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  const args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n  selectData = SimulateContractData<abi, functionName, args, config, chainId>,\n>(\n  config: config,\n  options: SimulateContractOptions<\n    abi,\n    functionName,\n    args,\n    config,\n    chainId,\n    selectData\n  > = {} as any,\n): SimulateContractQueryOptions<\n  abi,\n  functionName,\n  args,\n  config,\n  chainId,\n  selectData\n> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      options.abi &&\n        options.address &&\n        options.connector &&\n        options.functionName &&\n        (options.query?.enabled ?? true),\n    ),\n    queryFn: async (context) => {\n      if (!options.abi) throw new Error('abi is required')\n      if (!options.connector) throw new Error('connector is required')\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.address) throw new Error('address is required')\n      if (!parameters.functionName) throw new Error('functionName is required')\n      return simulateContract(config, {\n        ...(parameters as any),\n        abi: options.abi,\n        address: parameters.address,\n        connector: options.connector,\n        functionName: parameters.functionName,\n      })\n    },\n    queryKey: simulateContractQueryKey(options as any),\n  }\n}\n\nexport type SimulateContractQueryFnData<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n> = SimulateContractReturnType<abi, functionName, args, config, chainId>\n\nexport type SimulateContractData<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n> = SimulateContractQueryFnData<abi, functionName, args, config, chainId>\n\nexport function simulateContractQueryKey<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  const args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  const config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n>(\n  options: UnionExactPartial<\n    SimulateContractParameters<abi, functionName, args, config, chainId>\n  > &\n    ScopeKeyParameter = {} as any,\n) {\n  const { connector: _, ...rest } = options\n  return ['simulateContract', filterQueryOptions(rest)] as const\n}\n\nexport type SimulateContractQueryKey<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n> = ReturnType<\n  typeof simulateContractQueryKey<abi, functionName, args, config, chainId>\n>\n\nexport type SimulateContractQueryOptions<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n  selectData = SimulateContractData<abi, functionName, args, config, chainId>,\n> = QueryOptions<\n  SimulateContractQueryFnData<abi, functionName, args, config, chainId>,\n  SimulateContractErrorType,\n  selectData,\n  SimulateContractQueryKey<abi, functionName, args, config, chainId>\n>\n", "import type { MutateOptions, MutationOptions } from '@tanstack/query-core'\n\nimport {\n  type SwitchChainErrorType,\n  type SwitchChainParameters,\n  type SwitchChainReturnType,\n  switchChain,\n} from '../actions/switchChain.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\n\nexport function switchChainMutationOptions<config extends Config>(\n  config: config,\n) {\n  return {\n    mutationFn(variables) {\n      return switchChain(config, variables)\n    },\n    mutationKey: ['switchChain'],\n  } as const satisfies MutationOptions<\n    SwitchChainData<config, config['chains'][number]['id']>,\n    SwitchChainErrorType,\n    SwitchChainVariables<config, config['chains'][number]['id']>\n  >\n}\n\nexport type SwitchChainData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = Compute<SwitchChainReturnType<config, chainId>>\n\nexport type SwitchChainVariables<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = Compute<SwitchChainParameters<config, chainId>>\n\nexport type SwitchChainMutate<config extends Config, context = unknown> = <\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: SwitchChainVariables<config, chainId>,\n  options?:\n    | Compute<\n        MutateOptions<\n          SwitchChainData<config, chainId>,\n          SwitchChainErrorType,\n          Compute<SwitchChainVariables<config, chainId>>,\n          context\n        >\n      >\n    | undefined,\n) => void\n\nexport type SwitchChainMutateAsync<config extends Config, context = unknown> = <\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: SwitchChainVariables<config, chainId>,\n  options?:\n    | Compute<\n        MutateOptions<\n          SwitchChainData<config, chainId>,\n          SwitchChainErrorType,\n          Compute<SwitchChainVariables<config, chainId>>,\n          context\n        >\n      >\n    | undefined,\n) => Promise<SwitchChainData<config, chainId>>\n", "import type { MutationOptions } from '@tanstack/query-core'\n\nimport {\n  type SwitchConnectionErrorType,\n  type SwitchConnectionParameters,\n  type SwitchConnectionReturnType,\n  switchConnection,\n} from '../actions/switchConnection.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\nimport type { Mutate, MutateAsync } from './types.js'\n\nexport function switchConnectionMutationOptions<config extends Config>(\n  config: config,\n) {\n  return {\n    mutationFn(variables) {\n      return switchConnection(config, variables)\n    },\n    mutationKey: ['switchConnection'],\n  } as const satisfies MutationOptions<\n    SwitchConnectionData<config>,\n    SwitchConnectionErrorType,\n    SwitchConnectionVariables\n  >\n}\n\nexport type SwitchConnectionData<config extends Config> = Compute<\n  SwitchConnectionReturnType<config>\n>\n\nexport type SwitchConnectionVariables = Compute<SwitchConnectionParameters>\n\nexport type SwitchConnectionMutate<\n  config extends Config,\n  context = unknown,\n> = Mutate<\n  SwitchConnectionData<config>,\n  SwitchConnectionErrorType,\n  SwitchConnectionVariables,\n  context\n>\n\nexport type SwitchConnectionMutateAsync<\n  config extends Config,\n  context = unknown,\n> = MutateAsync<\n  SwitchConnectionData<config>,\n  SwitchConnectionErrorType,\n  SwitchConnectionVariables,\n  context\n>\n", "import {\n  type WaitForTransactionReceiptErrorType,\n  type WaitForTransactionReceiptParameters,\n  type WaitForTransactionReceiptReturnType,\n  waitForTransactionReceipt,\n} from '../actions/waitForTransactionReceipt.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type WaitForTransactionReceiptOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = WaitForTransactionReceiptData<config, chainId>,\n> = Compute<\n  ExactPartial<WaitForTransactionReceiptParameters<config, chainId>> &\n    ScopeKeyParameter\n> &\n  QueryParameter<\n    WaitForTransactionReceiptQueryFnData<config, chainId>,\n    WaitForTransactionReceiptErrorType,\n    selectData,\n    WaitForTransactionReceiptQueryKey<config, chainId>\n  >\n\nexport function waitForTransactionReceiptQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = WaitForTransactionReceiptData<config, chainId>,\n>(\n  config: config,\n  options: WaitForTransactionReceiptOptions<config, chainId, selectData> = {},\n): WaitForTransactionReceiptQueryOptions<config, chainId, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(options.hash && (options.query?.enabled ?? true)),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.hash) throw new Error('hash is required')\n      return waitForTransactionReceipt(config, {\n        ...parameters,\n        onReplaced: options.onReplaced,\n        hash: parameters.hash,\n      }) as unknown as Promise<\n        WaitForTransactionReceiptReturnType<config, chainId>\n      >\n    },\n    queryKey: waitForTransactionReceiptQueryKey(options),\n  }\n}\n\nexport type WaitForTransactionReceiptQueryFnData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = WaitForTransactionReceiptReturnType<config, chainId>\n\nexport type WaitForTransactionReceiptData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = WaitForTransactionReceiptQueryFnData<config, chainId>\n\nexport function waitForTransactionReceiptQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(\n  options: Compute<\n    ExactPartial<WaitForTransactionReceiptParameters<config, chainId>> &\n      ScopeKeyParameter\n  > = {},\n) {\n  const { onReplaced: _, ...rest } = options\n  return ['waitForTransactionReceipt', filterQueryOptions(rest)] as const\n}\n\nexport type WaitForTransactionReceiptQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = ReturnType<typeof waitForTransactionReceiptQueryKey<config, chainId>>\n\nexport type WaitForTransactionReceiptQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = WaitForTransactionReceiptData<config, chainId>,\n> = QueryOptions<\n  WaitForTransactionReceiptQueryFnData<config, chainId>,\n  WaitForTransactionReceiptErrorType,\n  selectData,\n  WaitForTransactionReceiptQueryKey<config, chainId>\n>\n", "import type { MutateOptions, MutationOptions } from '@tanstack/query-core'\nimport type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'\n\nimport {\n  type WriteContractErrorType,\n  type WriteContractParameters,\n  type WriteContractReturnType,\n  writeContract,\n} from '../actions/writeContract.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\n\nexport function writeContractMutationOptions<config extends Config>(\n  config: config,\n) {\n  return {\n    mutationFn(variables) {\n      return writeContract(config, variables)\n    },\n    mutationKey: ['writeContract'],\n  } as const satisfies MutationOptions<\n    WriteContractData,\n    WriteContractErrorType,\n    WriteContractVariables<\n      Abi,\n      string,\n      readonly unknown[],\n      config,\n      config['chains'][number]['id']\n    >\n  >\n}\n\nexport type WriteContractData = Compute<WriteContractReturnType>\n\nexport type WriteContractVariables<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  ///\n  allFunctionNames = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n> = WriteContractParameters<\n  abi,\n  functionName,\n  args,\n  config,\n  chainId,\n  allFunctionNames\n>\n\nexport type WriteContractMutate<config extends Config, context = unknown> = <\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: WriteContractVariables<abi, functionName, args, config, chainId>,\n  options?:\n    | MutateOptions<\n        WriteContractData,\n        WriteContractErrorType,\n        WriteContractVariables<\n          abi,\n          functionName,\n          args,\n          config,\n          chainId,\n          // use `functionName` to make sure it's not union of all possible function names\n          functionName\n        >,\n        context\n      >\n    | undefined,\n) => void\n\nexport type WriteContractMutateAsync<\n  config extends Config,\n  context = unknown,\n> = <\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: WriteContractVariables<abi, functionName, args, config, chainId>,\n  options?:\n    | MutateOptions<\n        WriteContractData,\n        WriteContractErrorType,\n        WriteContractVariables<\n          abi,\n          functionName,\n          args,\n          config,\n          chainId,\n          // use `functionName` to make sure it's not union of all possible function names\n          functionName\n        >,\n        context\n      >\n    | undefined,\n) => Promise<WriteContractData>\n", "// Credit: https://github.com/TanStack/query/blob/01ce023826b81e6c41e354f27691f65c9725af67/packages/vue-query/src/utils.ts\n\nimport { isRef, unref } from 'vue'\n\nimport type { DeepMaybeRef, DeepUnwrapRef } from '../types/ref.js'\n\nfunction cloneDeep<value>(\n  value: DeepMaybeRef<value>,\n  customize?: (val: DeepMaybeRef<value>) => value | undefined,\n): value {\n  if (customize) {\n    const result = customize(value)\n    // If it's a ref of undefined, return undefined\n    if (result === undefined && isRef(value)) return result as value\n    if (result !== undefined) return result\n  }\n\n  if (Array.isArray(value))\n    return value.map((val) => cloneDeep(val, customize)) as unknown as value\n\n  if (typeof value === 'object' && isPlainObject(value)) {\n    const entries = Object.entries(value).map(([key, val]) => [\n      key,\n      cloneDeep(val, customize),\n    ])\n    return Object.fromEntries(entries)\n  }\n\n  return value as value\n}\n\nexport function deepUnref<value>(value: value): DeepUnwrapRef<value> {\n  return cloneDeep(value as any, (val) => {\n    if (isRef(val)) return deepUnref(unref(val))\n    return undefined\n  })\n}\n\n// biome-ignore lint/complexity/noBannedTypes: allowed\nfunction isPlainObject(value: unknown): value is Object {\n  if (Object.prototype.toString.call(value) !== '[object Object]') return false\n  const prototype = Object.getPrototypeOf(value)\n  return prototype === null || prototype === Object.prototype\n}\n", "import {\n  type DefaultError,\n  type MutationObserverOptions,\n  type QueryKey,\n  type UseMutationReturnType as tanstack_UseMutationReturnType,\n  type UseQueryReturnType as tanstack_UseQueryReturnType,\n  useQuery as tanstack_useQuery,\n  type UseQueryOptions,\n  useMutation,\n} from '@tanstack/vue-query'\nimport type {\n  Compute,\n  ExactPartial,\n  Omit,\n  UnionStrictOmit,\n} from '@wagmi/core/internal'\nimport { hashFn } from '@wagmi/core/query'\nimport { computed, type MaybeRef, unref } from 'vue'\n\nimport type { DeepMaybeRef, DeepUnwrapRef } from '../types/ref.js'\n\nexport type UseMutationParameters<\n  data = unknown,\n  error = Error,\n  variables = void,\n  context = unknown,\n> = Compute<\n  DeepMaybeRef<\n    Omit<\n      DeepUnwrapRef<\n        MutationObserverOptions<data, error, Compute<variables>, context>\n      >,\n      'mutationFn' | 'mutationKey' | 'throwOnError'\n    >\n  >\n>\n\nexport type UseMutationReturnType<\n  data = unknown,\n  error = Error,\n  variables = void,\n  context = unknown,\n> = Compute<\n  UnionStrictOmit<\n    tanstack_UseMutationReturnType<data, error, variables, context>,\n    'mutate' | 'mutateAsync'\n  >\n>\n\nexport { useMutation }\n\n////////////////////////////////////////////////////////////////////////////////\n\nexport type UseQueryParameters<\n  queryFnData = unknown,\n  error = DefaultError,\n  data = queryFnData,\n  queryKey extends QueryKey = QueryKey,\n> = Compute<\n  DeepMaybeRef<\n    ExactPartial<\n      Omit<\n        DeepUnwrapRef<\n          UseQueryOptions<queryFnData, error, data, queryFnData, queryKey>\n        >,\n        'initialData'\n      >\n    > & {\n      // Fix `initialData` type\n      initialData?:\n        | DeepUnwrapRef<\n            UseQueryOptions<queryFnData, error, data, queryFnData, queryKey>\n          >['initialData']\n        | undefined\n    }\n  >\n>\n\nexport type UseQueryReturnType<data = unknown, error = DefaultError> = Compute<\n  tanstack_UseQueryReturnType<data, error> & {\n    queryKey: QueryKey\n  }\n>\n\n// Adding some basic customization.\n// Ideally we don't have this function, but `import('@tanstack/vue-query').useQuery` currently has some quirks where it is super hard to\n// pass down the inferred `initialData` type because of it's discriminated overload in the on `useQuery`.\nexport function useQuery<queryFnData, error, data, queryKey extends QueryKey>(\n  parameters: MaybeRef<\n    UseQueryParameters<queryFnData, error, data, queryKey> & {\n      queryKey: QueryKey\n    }\n  >,\n): UseQueryReturnType<data, error> {\n  const options = computed(() => ({\n    ...(unref(parameters) as any),\n    queryKeyHashFn: hashFn,\n  }))\n  const result = tanstack_useQuery(options) as UseQueryReturnType<data, error>\n  result.queryKey = unref(options).queryKey as QueryKey\n  return result\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// export type UseInfiniteQueryParameters<\n//   queryFnData = unknown,\n//   error = DefaultError,\n//   data = queryFnData,\n//   queryData = queryFnData,\n//   queryKey extends QueryKey = QueryKey,\n//   pageParam = unknown,\n// > = Compute<\n//   Omit<\n//     UseInfiniteQueryOptions<\n//       queryFnData,\n//       error,\n//       data,\n//       queryData,\n//       queryKey,\n//       pageParam\n//     >,\n//     'initialData'\n//   > & {\n//     // Fix `initialData` type\n//     initialData?:\n//       | UseInfiniteQueryOptions<\n//           queryFnData,\n//           error,\n//           data,\n//           queryKey\n//         >['initialData']\n//       | undefined\n//   }\n// >\n\n// export type UseInfiniteQueryReturnType<\n//   data = unknown,\n//   error = DefaultError,\n// > = import('@tanstack/vue-query').UseInfiniteQueryReturnType<data, error> & {\n//   queryKey: QueryKey\n// }\n\n// // Adding some basic customization.\n// export function useInfiniteQuery<\n//   queryFnData,\n//   error,\n//   data,\n//   queryKey extends QueryKey,\n// >(\n//   parameters: UseInfiniteQueryParameters<queryFnData, error, data, queryKey> & {\n//     queryKey: QueryKey\n//   },\n// ): UseInfiniteQueryReturnType<data, error> {\n//   const result = tanstack_useInfiniteQuery({\n//     ...(parameters as any),\n//     queryKeyHashFn: hashFn, // for bigint support\n//   }) as UseInfiniteQueryReturnType<data, error>\n//   result.queryKey = parameters.queryKey\n//   return result\n// }\n", "import type { Config, ResolvedRegister } from '@wagmi/core'\nimport { hasInjectionContext, inject, unref } from 'vue'\n\nimport {\n  WagmiInjectionContextError,\n  WagmiPluginNotFoundError,\n} from '../errors/plugin.js'\nimport { configKey } from '../plugin.js'\nimport type { ConfigParameter } from '../types/properties.js'\nimport type { DeepMaybeRef } from '../types/ref.js'\n\nexport type UseConfigParameters<config extends Config = Config> = DeepMaybeRef<\n  ConfigParameter<config>\n>\n\nexport type UseConfigReturnType<config extends Config = Config> = config\n\n/** https://wagmi.sh/vue/api/composables/useConfig */\nexport function useConfig<config extends Config = ResolvedRegister['config']>(\n  parameters_: UseConfigParameters<config> = {},\n): UseConfigReturnType<config> {\n  const parameters = unref(parameters_)\n\n  // passthrough config if provided\n  if (parameters.config) return parameters.config as UseConfigReturnType<config>\n\n  // ensures that `inject()` can be used\n  if (!hasInjectionContext()) throw new WagmiInjectionContextError()\n\n  const config = inject<Config | undefined>(configKey)\n  if (!config) throw new WagmiPluginNotFoundError()\n\n  return config as UseConfigReturnType<config>\n}\n", "import {\n  type Config,\n  type GetChainIdReturnType,\n  getChainId,\n  type ResolvedRegister,\n  watchChainId,\n} from '@wagmi/core'\nimport { onScopeDispose, type Ref, readonly, ref } from 'vue'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseChainIdParameters<config extends Config = Config> =\n  ConfigParameter<config>\n\nexport type UseChainIdReturnType<config extends Config = Config> = Ref<\n  GetChainIdReturnType<config>\n>\n\n/** https://wagmi.sh/vue/api/composables/useChainId */\nexport function useChainId<config extends Config = ResolvedRegister['config']>(\n  parameters: UseChainIdParameters<config> = {},\n): UseChainIdReturnType<config> {\n  const config = useConfig(parameters)\n\n  const chainId = ref<GetChainIdReturnType>(getChainId(config))\n  const unsubscribe = watchChainId(config, {\n    onChange(data) {\n      chainId.value = data\n    },\n  })\n  onScopeDispose(() => unsubscribe())\n\n  return readonly(chainId)\n}\n", "import type { Config, GetBalanceErrorType, ResolvedRegister } from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetBalanceData,\n  type GetBalanceOptions,\n  getBalanceQueryOptions,\n} from '@wagmi/core/query'\nimport { computed } from 'vue'\nimport type { ConfigParameter } from '../types/properties.js'\nimport type { DeepMaybeRef } from '../types/ref.js'\nimport { deepUnref } from '../utils/cloneDeep.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseBalanceParameters<\n  config extends Config = Config,\n  selectData = GetBalanceData,\n> = Compute<\n  DeepMaybeRef<GetBalanceOptions<config, selectData> & ConfigParameter<config>>\n>\n\nexport type UseBalanceReturnType<selectData = GetBalanceData> =\n  UseQueryReturnType<selectData, GetBalanceErrorType>\n\n/** https://wagmi.sh/vue/api/composables/useBalance */\nexport function useBalance<\n  config extends Config = ResolvedRegister['config'],\n  selectData = GetBalanceData,\n>(\n  parameters: UseBalanceParameters<config, selectData> = {},\n): UseBalanceReturnType<selectData> {\n  const params = computed(() => deepUnref(parameters))\n  const config = useConfig(params)\n  const chainId = useChainId({ config })\n  const options = computed(() =>\n    getBalanceQueryOptions(config as any, {\n      ...params.value,\n      chainId: params.value.chainId ?? chainId.value,\n      query: params.value.query,\n    }),\n  )\n  return useQuery(options as any) as any\n}\n", "import {\n  type Config,\n  type ResolvedRegister,\n  type WatchBlockNumberParameters,\n  watchBlockNumber,\n} from '@wagmi/core'\nimport type { UnionCompute, UnionExactPartial } from '@wagmi/core/internal'\nimport { computed, watchEffect } from 'vue'\n\nimport type { ConfigParameter, EnabledParameter } from '../types/properties.js'\nimport type { DeepMaybeRef } from '../types/ref.js'\nimport { deepUnref } from '../utils/cloneDeep.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseWatchBlockNumberParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n> = DeepMaybeRef<\n  UnionCompute<\n    UnionExactPartial<WatchBlockNumberParameters<config, chainId>> &\n      ConfigParameter<config> &\n      EnabledParameter\n  >\n>\n\nexport type UseWatchBlockNumberReturnType = void\n\n/** https://wagmi.sh/vue/api/composables/useWatchBlockNumber */\nexport function useWatchBlockNumber<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n>(\n  parameters_: UseWatchBlockNumberParameters<config, chainId> = {} as any,\n): UseWatchBlockNumberReturnType {\n  const parameters = computed(() => deepUnref(parameters_))\n\n  const config = useConfig(parameters)\n  const configChainId = useChainId({ config })\n\n  watchEffect((onCleanup) => {\n    const {\n      chainId = configChainId.value,\n      enabled = true,\n      onBlockNumber,\n      config: _,\n      ...rest\n    } = parameters.value\n\n    if (!enabled) return\n    if (!onBlockNumber) return\n\n    const unwatch = watchBlockNumber(config, {\n      ...(rest as any),\n      chainId,\n      onBlockNumber,\n      emitOnBegin: true,\n    })\n    onCleanup(unwatch)\n  })\n}\n", "import { useQueryClient } from '@tanstack/vue-query'\nimport type {\n  Config,\n  GetBlockNumberErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type {\n  Compute,\n  UnionCompute,\n  UnionStrictOmit,\n} from '@wagmi/core/internal'\nimport {\n  type GetBlockNumberData,\n  type GetBlockNumberOptions,\n  getBlockNumberQueryOptions,\n} from '@wagmi/core/query'\nimport { computed } from 'vue'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type { DeepMaybeRef, DeepUnwrapRef } from '../types/ref.js'\nimport { deepUnref } from '../utils/cloneDeep.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\nimport {\n  type UseWatchBlockNumberParameters,\n  useWatchBlockNumber,\n} from './useWatchBlockNumber.js'\n\nexport type UseBlockNumberParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetBlockNumberData,\n> = Compute<\n  DeepMaybeRef<\n    GetBlockNumberOptions<config, chainId, selectData> &\n      ConfigParameter<config> & {\n        watch?:\n          | boolean\n          | UnionCompute<\n              UnionStrictOmit<\n                DeepUnwrapRef<UseWatchBlockNumberParameters<config, chainId>>,\n                'chainId' | 'config' | 'onBlockNumber' | 'onError'\n              >\n            >\n          | undefined\n      }\n  >\n>\n\nexport type UseBlockNumberReturnType<selectData = GetBlockNumberData> =\n  UseQueryReturnType<selectData, GetBlockNumberErrorType>\n\n/** https://wagmi.sh/vue/api/composables/useBlockNumber */\nexport function useBlockNumber<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetBlockNumberData,\n>(\n  parameters: UseBlockNumberParameters<config, chainId, selectData> = {},\n): UseBlockNumberReturnType<selectData> {\n  const params = computed(() => deepUnref(parameters))\n  const config = useConfig(params)\n  const chainId = useChainId({ config })\n  const options = computed(() =>\n    getBlockNumberQueryOptions(config as any, {\n      ...params.value,\n      chainId: params.value.chainId ?? chainId.value,\n      query: params.value.query,\n    }),\n  )\n\n  const queryClient = useQueryClient()\n  const watchBlockNumberArgs = computed(() => {\n    return {\n      ...({\n        config,\n        chainId: params.value.chainId ?? chainId.value,\n        ...(typeof params.value.watch === 'object' ? params.value.watch : {}),\n      } as UseWatchBlockNumberParameters),\n      enabled:\n        (params.value.query?.enabled ?? true) &&\n        (typeof params.value.watch === 'object'\n          ? params.value.watch.enabled\n          : params.value.watch),\n      onBlockNumber(blockNumber) {\n        queryClient.setQueryData(options.value.queryKey, blockNumber)\n      },\n    } satisfies UseWatchBlockNumberParameters\n  })\n  useWatchBlockNumber(watchBlockNumberArgs)\n\n  return useQuery(options as any) as any\n}\n", "import type {\n  Config,\n  GetBytecodeErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetBytecodeData,\n  type GetBytecodeOptions,\n  getBytecodeQueryOptions,\n} from '@wagmi/core/query'\nimport { computed } from 'vue'\nimport type { ConfigParameter } from '../types/properties.js'\nimport type { DeepMaybeRef } from '../types/ref.js'\nimport { deepUnref } from '../utils/cloneDeep.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseBytecodeParameters<\n  config extends Config = Config,\n  selectData = GetBytecodeData,\n> = Compute<\n  DeepMaybeRef<GetBytecodeOptions<config, selectData> & ConfigParameter<config>>\n>\n\nexport type UseBytecodeReturnType<selectData = GetBytecodeData> =\n  UseQueryReturnType<selectData, GetBytecodeErrorType>\n\n/** https://wagmi.sh/vue/api/hooks/useBytecode */\nexport function useBytecode<\n  config extends Config = ResolvedRegister['config'],\n  selectData = GetBytecodeData,\n>(\n  parameters: UseBytecodeParameters<config, selectData> = {},\n): UseBytecodeReturnType<selectData> {\n  const params = computed(() => deepUnref(parameters))\n  const config = useConfig(params)\n  const chainId = useChainId({ config })\n  const options = computed(() =>\n    getBytecodeQueryOptions(config as any, {\n      ...params.value,\n      address: params.value.address,\n      chainId: params.value.chainId ?? chainId.value,\n      query: params.value.query,\n    }),\n  )\n  return useQuery(options as any) as any\n}\n", "import type { Config } from '../createConfig.js'\nimport type { GetChainsReturnType } from './getChains.js'\n\nexport type WatchChainsParameters<config extends Config = Config> = {\n  onChange(\n    chains: GetChainsReturnType<config>,\n    prevChains: GetChainsReturnType<config>,\n  ): void\n}\n\nexport type WatchChainsReturnType = () => void\n\n/**\n * @internal\n * We don't expose this because as far as consumers know, you can't chainge (lol) `config.chains` at runtime.\n * Setting `config.chains` via `config._internal.chains.setState(...)` is an extremely advanced use case that's not worth documenting or supporting in the public API at this time.\n */\nexport function watchChains<config extends Config>(\n  config: config,\n  parameters: WatchChainsParameters<config>,\n): WatchChainsReturnType {\n  const { onChange } = parameters\n  return config._internal.chains.subscribe((chains, prevChains) => {\n    onChange(\n      chains as unknown as GetChainsReturnType<config>,\n      prevChains as unknown as GetChainsReturnType<config>,\n    )\n  })\n}\n", "import {\n  type Config,\n  type GetChainsReturnType,\n  getChains,\n  type ResolvedRegister,\n} from '@wagmi/core'\nimport { watchChains } from '@wagmi/core/internal'\n\nimport { onScopeDispose, type Ref, readonly, ref } from 'vue'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseChainsParameters<config extends Config = Config> =\n  ConfigParameter<config>\n\nexport type UseChainsReturnType<config extends Config = Config> = Ref<\n  GetChainsReturnType<config>\n>\n\n/** https://wagmi.sh/vue/api/composables/useChains */\nexport function useChains<config extends Config = ResolvedRegister['config']>(\n  parameters: UseChainsParameters<config> = {},\n): UseChainsReturnType<config> {\n  const config = useConfig(parameters)\n\n  const chains = ref<GetChainsReturnType<config>>(getChains(config))\n  const unsubscribe = watchChains(config, {\n    onChange(data) {\n      chains.value = data as any\n    },\n  })\n  onScopeDispose(() => unsubscribe())\n\n  return readonly(chains) as UseChainsReturnType<config>\n}\n", "import {\n  type Config,\n  type GetClientParameters,\n  type GetClientReturnType,\n  getClient,\n  type ResolvedRegister,\n  watchClient,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  computed,\n  onScopeDispose,\n  type Ref,\n  readonly,\n  ref,\n  watchEffect,\n} from 'vue'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type { DeepMaybeRef } from '../types/ref.js'\nimport { deepUnref } from '../utils/cloneDeep.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseClientParameters<\n  config extends Config = Config,\n  chainId extends config['chains'][number]['id'] | number | undefined =\n    | config['chains'][number]['id']\n    | undefined,\n> = Compute<\n  DeepMaybeRef<GetClientParameters<config, chainId> & ConfigParameter<config>>\n>\n\nexport type UseClientReturnType<\n  config extends Config = Config,\n  chainId extends config['chains'][number]['id'] | number | undefined =\n    | config['chains'][number]['id']\n    | undefined,\n> = Ref<GetClientReturnType<config, chainId>>\n\n/** https://wagmi.sh/vue/api/composables/useClient */\nexport function useClient<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends config['chains'][number]['id'] | number | undefined =\n    | config['chains'][number]['id']\n    | undefined,\n>(\n  parameters: UseClientParameters<config, chainId> = {},\n): UseClientReturnType<config, chainId> {\n  const params = computed(() => deepUnref(parameters))\n\n  const config = useConfig(params)\n\n  const client = ref(getClient(config, params.value as GetClientParameters))\n  watchEffect(() => {\n    client.value = getClient(config, params.value as GetClientParameters)\n  })\n  const unsubscribe = watchClient(config, {\n    onChange(data) {\n      if (client.value?.uid === data?.uid) return\n      client.value = data\n    },\n  })\n  onScopeDispose(() => unsubscribe())\n\n  return readonly(client) as UseClientReturnType<config, chainId>\n}\n", "import {\n  type Config,\n  type GetConnectorsReturnType,\n  getConnectors,\n  type ResolvedRegister,\n  watchConnectors,\n} from '@wagmi/core'\nimport { onScopeDispose, type Ref, ref } from 'vue'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseConnectorsParameters<config extends Config = Config> =\n  ConfigParameter<config>\n\nexport type UseConnectorsReturnType<config extends Config = Config> = Ref<\n  GetConnectorsReturnType<config>\n>\n\n/** https://wagmi.sh/vue/api/composables/useConnectors */\nexport function useConnectors<\n  config extends Config = ResolvedRegister['config'],\n>(\n  parameters: UseConnectorsParameters<config> = {},\n): UseConnectorsReturnType<config> {\n  const config = useConfig(parameters)\n\n  const connectors = ref(getConnectors(config))\n  const unsubscribe = watchConnectors(config, {\n    onChange(data) {\n      connectors.value = data as never\n    },\n  })\n  onScopeDispose(() => unsubscribe())\n\n  return connectors\n}\n", "import { useMutation } from '@tanstack/vue-query'\nimport type {\n  Config,\n  ConnectErrorType,\n  GetConnectorsReturnType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type ConnectData,\n  type ConnectMutate,\n  type ConnectMutateAsync,\n  type ConnectVariables,\n  connectMutationOptions,\n} from '@wagmi/core/query'\nimport { onScopeDispose } from 'vue'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\nimport { useConnectors } from './useConnectors.js'\n\nexport type UseConnectParameters<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          ConnectData<config, config['connectors'][number], boolean>,\n          ConnectErrorType,\n          ConnectVariables<config, config['connectors'][number], boolean>,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseConnectReturnType<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  UseMutationReturnType<\n    ConnectData<config, config['connectors'][number], boolean>,\n    ConnectErrorType,\n    ConnectVariables<config, config['connectors'][number], boolean>,\n    context\n  > & {\n    /** @deprecated use `mutate` instead */\n    connect: ConnectMutate<config, context>\n    /** @deprecated use `mutateAsync` instead */\n    connectAsync: ConnectMutateAsync<config, context>\n    /** @deprecated use `useConnectors` instead */\n    connectors: Compute<GetConnectorsReturnType> | config['connectors']\n    mutate: ConnectMutate<config, context>\n    mutateAsync: ConnectMutateAsync<config, context>\n  }\n>\n\n/** https://wagmi.sh/vue/api/composables/useConnect */\nexport function useConnect<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: UseConnectParameters<config, context> = {},\n): UseConnectReturnType<config, context> {\n  const config = useConfig(parameters)\n\n  const mutationOptions = connectMutationOptions(config)\n  const { mutate, mutateAsync, ...result } = useMutation({\n    ...(parameters.mutation as typeof mutationOptions),\n    ...mutationOptions,\n  })\n\n  // Reset mutation back to an idle state when the connector disconnects.\n  const unsubscribe = config.subscribe(\n    ({ status }) => status,\n    (status, previousStatus) => {\n      if (previousStatus === 'connected' && status === 'disconnected')\n        result.reset()\n    },\n  )\n  onScopeDispose(() => unsubscribe())\n\n  type Return = UseConnectReturnType<config, context>\n  return {\n    ...(result as Return),\n    connect: mutate as Return['mutate'],\n    connectAsync: mutateAsync as Return['mutateAsync'],\n    connectors: useConnectors({ config }).value,\n    mutate: mutate as Return['mutate'],\n    mutateAsync: mutateAsync as Return['mutateAsync'],\n  }\n}\n", "// Credit: https://github.com/TanStack/query/blob/01ce023826b81e6c41e354f27691f65c9725af67/packages/vue-query/src/utils.ts#L11-L18\n\nexport function updateState(\n  state: Record<string, unknown>,\n  update: Record<string, any>,\n): void {\n  for (const key of Object.keys(state)) {\n    state[key] = update[key]\n  }\n}\n", "import {\n  type Config,\n  type GetConnectionReturnType,\n  getConnection,\n  type ResolvedRegister,\n  watchConnection,\n} from '@wagmi/core'\nimport { onScopeDispose, reactive, readonly, type ToRefs, toRefs } from 'vue'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport { updateState } from '../utils/updateState.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseConnectionParameters<config extends Config = Config> =\n  ConfigParameter<config>\n\nexport type UseConnectionReturnType<config extends Config = Config> = ToRefs<\n  GetConnectionReturnType<config>\n>\n\n/** https://wagmi.sh/vue/api/composables/useConnection */\nexport function useConnection<\n  config extends Config = ResolvedRegister['config'],\n>(\n  parameters: UseConnectionParameters<config> = {},\n): UseConnectionReturnType<config> {\n  const config = useConfig(parameters)\n\n  const connection = reactive(getConnection(config))\n\n  const unsubscribe = watchConnection(config, {\n    onChange(data) {\n      updateState(connection, data)\n    },\n  })\n  onScopeDispose(() => unsubscribe())\n\n  return toRefs(readonly(connection)) as UseConnectionReturnType<config>\n}\n", "import { type GetConnectionReturnType, watchConnection } from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport { watchEffect } from 'vue'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type { DeepMaybeRef } from '../types/ref.js'\nimport { deepUnref } from '../utils/cloneDeep.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseConnectionEffectParameters = Compute<\n  DeepMaybeRef<\n    {\n      onConnect?(\n        data: Compute<\n          Pick<\n            Extract<GetConnectionReturnType, { status: 'connected' }>,\n            'address' | 'addresses' | 'chain' | 'chainId' | 'connector'\n          > & {\n            isReconnected: boolean\n          }\n        >,\n      ): void\n      onDisconnect?(): void\n    } & ConfigParameter\n  >\n>\n\n/** https://wagmi.sh/vue/api/composables/useConnectionEffect */\nexport function useConnectionEffect(\n  parameters: UseConnectionEffectParameters = {},\n) {\n  const config = useConfig(parameters)\n\n  watchEffect((onCleanup) => {\n    const { onConnect, onDisconnect } = deepUnref(parameters)\n\n    const unwatch = watchConnection(config, {\n      onChange(data, prevData) {\n        if (\n          (prevData.status === 'reconnecting' ||\n            (prevData.status === 'connecting' &&\n              prevData.address === undefined)) &&\n          data.status === 'connected'\n        ) {\n          const { address, addresses, chain, chainId, connector } = data\n          const isReconnected =\n            prevData.status === 'reconnecting' ||\n            // if `previousAccount.status` is `undefined`, the connector connected immediately.\n            prevData.status === undefined\n          onConnect?.({\n            address,\n            addresses,\n            chain,\n            chainId,\n            connector,\n            isReconnected,\n          })\n        } else if (\n          prevData.status === 'connected' &&\n          data.status === 'disconnected'\n        )\n          onDisconnect?.()\n      },\n    })\n\n    onCleanup(() => unwatch())\n  })\n}\n", "import {\n  type GetConnectionsReturnType,\n  getConnections,\n  watchConnections,\n} from '@wagmi/core'\nimport { onScopeDispose, type Ref, readonly, ref } from 'vue'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseConnectionsParameters = ConfigParameter\n\nexport type UseConnectionsReturnType = Ref<GetConnectionsReturnType>\n\n/** https://wagmi.sh/vue/api/composables/useConnections */\nexport function useConnections(\n  parameters: UseConnectionsParameters = {},\n): UseConnectionsReturnType {\n  const config = useConfig(parameters)\n\n  const connections = ref(getConnections(config))\n  const unsubscribe = watchConnections(config, {\n    onChange(data) {\n      connections.value = data\n    },\n  })\n  onScopeDispose(() => unsubscribe())\n\n  return readonly(connections) as UseConnectionsReturnType\n}\n", "import { useQueryClient } from '@tanstack/vue-query'\nimport type {\n  Config,\n  Connector,\n  GetConnectorClientErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetConnectorClientData,\n  type GetConnectorClientOptions,\n  getConnectorClientQueryOptions,\n} from '@wagmi/core/query'\nimport { computed, ref, watchEffect } from 'vue'\nimport type { ConfigParameter } from '../types/properties.js'\nimport type { DeepMaybeRef } from '../types/ref.js'\nimport { deepUnref } from '../utils/cloneDeep.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\nimport { useConnection } from './useConnection.js'\n\nexport type UseConnectorClientParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetConnectorClientData<config, chainId>,\n> = Compute<\n  DeepMaybeRef<\n    GetConnectorClientOptions<config, chainId, selectData> &\n      ConfigParameter<config>\n  >\n>\n\nexport type UseConnectorClientReturnType<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetConnectorClientData<config, chainId>,\n> = UseQueryReturnType<selectData, GetConnectorClientErrorType>\n\n/** https://wagmi.sh/vue/api/composables/useConnectorClient */\nexport function useConnectorClient<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetConnectorClientData<config, chainId>,\n>(\n  parameters: UseConnectorClientParameters<config, chainId, selectData> = {},\n): UseConnectorClientReturnType<config, chainId, selectData> {\n  const params = computed(() => deepUnref(parameters))\n  const config = useConfig(params)\n  const chainId = useChainId({ config })\n  const { address, connector } = useConnection({ config })\n  const options = computed(() =>\n    getConnectorClientQueryOptions(config as any, {\n      ...params.value,\n      chainId: params.value.chainId ?? chainId.value,\n      connector: (params.value.connector ?? connector.value) as Connector,\n      query: params.value.query as any,\n    }),\n  )\n\n  const addressRef = ref(address)\n  const queryClient = useQueryClient()\n  watchEffect(() => {\n    const previousAddress = addressRef.value\n    if (!address && previousAddress) {\n      queryClient.removeQueries({ queryKey: options.value.queryKey })\n      addressRef.value = undefined\n    } else if (address.value !== previousAddress) {\n      queryClient.invalidateQueries({ queryKey: options.value.queryKey })\n      addressRef.value = address.value\n    }\n  })\n\n  return useQuery(options as any) as any\n}\n", "import { useMutation } from '@tanstack/vue-query'\nimport type { Connector, DisconnectErrorType } from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type DisconnectData,\n  type DisconnectMutate,\n  type DisconnectMutateAsync,\n  type DisconnectVariables,\n  disconnectMutationOptions,\n} from '@wagmi/core/query'\nimport { computed, type Ref } from 'vue'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\nimport { useConnections } from './useConnections.js'\n\nexport type UseDisconnectParameters<context = unknown> = Compute<\n  ConfigParameter & {\n    mutation?:\n      | UseMutationParameters<\n          DisconnectData,\n          DisconnectErrorType,\n          DisconnectVariables,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseDisconnectReturnType<context = unknown> = Compute<\n  UseMutationReturnType<\n    DisconnectData,\n    DisconnectErrorType,\n    DisconnectVariables,\n    context\n  > & {\n    /** @deprecated use `useConnections` instead */\n    connectors: Ref<readonly Connector[]>\n    /** @deprecated use `mutate` instead */\n    disconnect: DisconnectMutate<context>\n    /** @deprecated use `mutateAsync` instead */\n    disconnectAsync: DisconnectMutateAsync<context>\n    mutate: DisconnectMutate<context>\n    mutateAsync: DisconnectMutateAsync<context>\n  }\n>\n\n/** https://wagmi.sh/vue/api/composables/useDisconnect */\nexport function useDisconnect<context = unknown>(\n  parameters: UseDisconnectParameters<context> = {},\n): UseDisconnectReturnType<context> {\n  const config = useConfig(parameters)\n  const connections = useConnections({ config })\n  const mutationOptions = disconnectMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  return {\n    ...mutation,\n    connectors: computed(() =>\n      connections.value.map((connection) => connection.connector),\n    ),\n    disconnect: mutation.mutate,\n    disconnectAsync: mutation.mutateAsync,\n  }\n}\n", "import type {\n  Config,\n  GetEnsAddressErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetEnsAddressData,\n  type GetEnsAddressOptions,\n  getEnsAddressQueryOptions,\n} from '@wagmi/core/query'\nimport { computed } from 'vue'\nimport type { ConfigParameter } from '../types/properties.js'\nimport type { DeepMaybeRef } from '../types/ref.js'\nimport { deepUnref } from '../utils/cloneDeep.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseEnsAddressParameters<\n  config extends Config = Config,\n  selectData = GetEnsAddressData,\n> = Compute<\n  DeepMaybeRef<\n    GetEnsAddressOptions<config, selectData> & ConfigParameter<config>\n  >\n>\n\nexport type UseEnsAddressReturnType<selectData = GetEnsAddressData> =\n  UseQueryReturnType<selectData, GetEnsAddressErrorType>\n\n/** https://wagmi.sh/vue/api/composables/useEnsAddress */\nexport function useEnsAddress<\n  config extends Config = ResolvedRegister['config'],\n  selectData = GetEnsAddressData,\n>(\n  parameters: UseEnsAddressParameters<config, selectData> = {},\n): UseEnsAddressReturnType<selectData> {\n  const params = computed(() => deepUnref(parameters))\n  const config = useConfig(params)\n  const chainId = useChainId({ config })\n  const options = computed(() =>\n    getEnsAddressQueryOptions(config as any, {\n      ...params.value,\n      chainId: params.value.chainId ?? chainId.value,\n      query: params.value.query,\n    }),\n  )\n  return useQuery(options as any) as any\n}\n", "import type {\n  Config,\n  GetEnsAvatarErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetEnsAvatarData,\n  type GetEnsAvatarOptions,\n  getEnsAvatarQueryOptions,\n} from '@wagmi/core/query'\nimport { computed } from 'vue'\nimport type { ConfigParameter } from '../types/properties.js'\nimport type { DeepMaybeRef } from '../types/ref.js'\nimport { deepUnref } from '../utils/cloneDeep.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseEnsAvatarParameters<\n  config extends Config = Config,\n  selectData = GetEnsAvatarData,\n> = Compute<\n  DeepMaybeRef<\n    GetEnsAvatarOptions<config, selectData> & ConfigParameter<config>\n  >\n>\n\nexport type UseEnsAvatarReturnType<selectData = GetEnsAvatarData> =\n  UseQueryReturnType<selectData, GetEnsAvatarErrorType>\n\n/** https://wagmi.sh/vue/api/composables/useEnsAvatar */\nexport function useEnsAvatar<\n  config extends Config = ResolvedRegister['config'],\n  selectData = GetEnsAvatarData,\n>(\n  parameters: UseEnsAvatarParameters<config, selectData> = {},\n): UseEnsAvatarReturnType<selectData> {\n  const params = computed(() => deepUnref(parameters))\n  const config = useConfig(params)\n  const chainId = useChainId({ config })\n  const options = computed(() =>\n    getEnsAvatarQueryOptions(config as any, {\n      ...params.value,\n      chainId: params.value.chainId ?? chainId.value,\n      query: params.value.query,\n    }),\n  )\n  return useQuery(options as any) as any\n}\n", "import type { Config, GetEnsNameErrorType, ResolvedRegister } from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetEnsNameData,\n  type GetEnsNameOptions,\n  getEnsNameQueryOptions,\n} from '@wagmi/core/query'\nimport { computed } from 'vue'\nimport type { ConfigParameter } from '../types/properties.js'\nimport type { DeepMaybeRef } from '../types/ref.js'\nimport { deepUnref } from '../utils/cloneDeep.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseEnsNameParameters<\n  config extends Config = Config,\n  selectData = GetEnsNameData,\n> = Compute<\n  DeepMaybeRef<GetEnsNameOptions<config, selectData> & ConfigParameter<config>>\n>\n\nexport type UseEnsNameReturnType<selectData = GetEnsNameData> =\n  UseQueryReturnType<selectData, GetEnsNameErrorType>\n\n/** https://wagmi.sh/vue/api/composables/useEnsName */\nexport function useEnsName<\n  config extends Config = ResolvedRegister['config'],\n  selectData = GetEnsNameData,\n>(\n  parameters: UseEnsNameParameters<config, selectData> = {},\n): UseEnsNameReturnType<selectData> {\n  const params = computed(() => deepUnref(parameters))\n  const config = useConfig(params)\n  const chainId = useChainId({ config })\n  const options = computed(() =>\n    getEnsNameQueryOptions(config as any, {\n      ...params.value,\n      address: params.value.address,\n      chainId: params.value.chainId ?? chainId.value,\n      query: params.value.query,\n    }),\n  )\n  return useQuery(options as any) as any\n}\n", "import type {\n  Config,\n  EstimateGasErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport {\n  type EstimateGasData,\n  type EstimateGasOptions,\n  estimateGasQueryOptions,\n} from '@wagmi/core/query'\nimport { computed } from 'vue'\nimport type { ConfigParameter } from '../types/properties.js'\nimport type { DeepMaybeRef } from '../types/ref.js'\nimport { deepUnref } from '../utils/cloneDeep.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\nimport { useConnection } from './useConnection.js'\n\nexport type UseEstimateGasParameters<\n  config extends Config = Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = EstimateGasData,\n> = DeepMaybeRef<\n  EstimateGasOptions<config, chainId, selectData> & ConfigParameter<config>\n>\n\nexport type UseEstimateGasReturnType<selectData = EstimateGasData> =\n  UseQueryReturnType<selectData, EstimateGasErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useEstimateGas */\nexport function useEstimateGas<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = EstimateGasData,\n>(\n  parameters?: UseEstimateGasParameters<config, chainId, selectData>,\n): UseEstimateGasReturnType<selectData>\n\nexport function useEstimateGas(\n  parameters: UseEstimateGasParameters = {},\n): UseEstimateGasReturnType {\n  const params = computed(() => deepUnref(parameters))\n  const config = useConfig(params)\n  const { address, connector } = useConnection({ config })\n  const chainId = useChainId({ config })\n  const options = computed(() =>\n    estimateGasQueryOptions(config as any, {\n      ...params.value,\n      account: params.value.account ?? address.value,\n      chainId: params.value.chainId ?? chainId.value,\n      connector: params.value.connector ?? connector.value,\n      query: params.value.query,\n    }),\n  )\n  return useQuery(options as any) as any\n}\n", "import type {\n  Config,\n  ReadContractErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { UnionCompute } from '@wagmi/core/internal'\nimport {\n  type ReadContractData,\n  type ReadContractOptions,\n  readContractQueryOptions,\n} from '@wagmi/core/query'\nimport type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'\nimport { computed, type MaybeRef } from 'vue'\nimport type { ConfigParameter } from '../types/properties.js'\nimport type { DeepMaybeRef } from '../types/ref.js'\nimport { deepUnref } from '../utils/cloneDeep.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseReadContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'pure' | 'view'\n  > = ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'pure' | 'view',\n    functionName\n  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config = Config,\n  selectData = ReadContractData<abi, functionName, args>,\n> = MaybeRef<\n  UnionCompute<\n    ReadContractOptions<abi, functionName, args, config, selectData> &\n      ConfigParameter<config>\n  >\n>\n\ntype UseReadContractParametersLoose<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'pure' | 'view'\n  > = ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'pure' | 'view',\n    functionName\n  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config = Config,\n  selectData = ReadContractData<abi, functionName, args>,\n> = DeepMaybeRef<\n  ReadContractOptions<abi, functionName, args, config, selectData> &\n    ConfigParameter<Config>\n>\n\nexport type UseReadContractReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'pure' | 'view'\n  > = ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'pure' | 'view',\n    functionName\n  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  selectData = ReadContractData<abi, functionName, args>,\n> = UseQueryReturnType<selectData, ReadContractErrorType>\n\n/** https://wagmi.sh/vue/api/hooks/useReadContract */\nexport function useReadContract<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config = ResolvedRegister['config'],\n  selectData = ReadContractData<abi, functionName, args>,\n>(\n  parameters: UseReadContractParameters<\n    abi,\n    functionName,\n    args,\n    config,\n    selectData\n  >,\n): UseReadContractReturnType<abi, functionName, args, selectData>\nexport function useReadContract<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config = ResolvedRegister['config'],\n  selectData = ReadContractData<abi, functionName, args>,\n>(\n  parameters: UseReadContractParametersLoose<\n    abi,\n    functionName,\n    args,\n    config,\n    selectData\n  >,\n): UseReadContractReturnType\nexport function useReadContract(\n  parameters: UseReadContractParametersLoose = {},\n): UseReadContractReturnType {\n  const params = computed(() => deepUnref(parameters)) as any\n  const config = useConfig(params)\n  const chainId = useChainId({ config })\n  const options = computed(() =>\n    readContractQueryOptions(config as any, {\n      ...params.value,\n      chainId: params.value.chainId ?? chainId.value,\n      query: params.value.query,\n    }),\n  )\n  return useQuery(options as any) as any\n}\n", "import { useMutation } from '@tanstack/vue-query'\nimport type { Connector, ReconnectErrorType } from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type ReconnectData,\n  type ReconnectMutate,\n  type ReconnectMutateAsync,\n  type ReconnectVariables,\n  reconnectMutationOptions,\n} from '@wagmi/core/query'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseReconnectParameters<context = unknown> = Compute<\n  ConfigParameter & {\n    mutation?:\n      | UseMutationParameters<\n          ReconnectData,\n          ReconnectErrorType,\n          ReconnectVariables,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseReconnectReturnType<context = unknown> = Compute<\n  UseMutationReturnType<\n    ReconnectData,\n    ReconnectErrorType,\n    ReconnectVariables,\n    context\n  > & {\n    connectors: readonly Connector[]\n    mutate: ReconnectMutate<context>\n    mutateAsync: ReconnectMutateAsync<context>\n    /** @deprecated use `mutate` instead */\n    reconnect: ReconnectMutate<context>\n    /** @deprecated use `mutateAsync` instead */\n    reconnectAsync: ReconnectMutateAsync<context>\n  }\n>\n\n/** https://wagmi.sh/vue/api/composables/useReconnect */\nexport function useReconnect<context = unknown>(\n  parameters: UseReconnectParameters<context> = {},\n): UseReconnectReturnType<context> {\n  const config = useConfig(parameters)\n  const mutationOptions = reconnectMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  return {\n    ...mutation,\n    connectors: config.connectors,\n    reconnect: mutation.mutate,\n    reconnectAsync: mutation.mutateAsync,\n  }\n}\n", "import { useMutation } from '@tanstack/vue-query'\nimport type {\n  Config,\n  ResolvedRegister,\n  SendTransactionErrorType,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type SendTransactionData,\n  type SendTransactionMutate,\n  type SendTransactionMutateAsync,\n  type SendTransactionVariables,\n  sendTransactionMutationOptions,\n} from '@wagmi/core/query'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseSendTransactionParameters<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          SendTransactionData,\n          SendTransactionErrorType,\n          SendTransactionVariables<config, config['chains'][number]['id']>,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseSendTransactionReturnType<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  UseMutationReturnType<\n    SendTransactionData,\n    SendTransactionErrorType,\n    SendTransactionVariables<config, config['chains'][number]['id']>,\n    context\n  > & {\n    mutate: SendTransactionMutate<config, context>\n    mutateAsync: SendTransactionMutateAsync<config, context>\n    /** @deprecated use `mutate` instead */\n    sendTransaction: SendTransactionMutate<config, context>\n    /** @deprecated use `mutateAsync` instead */\n    sendTransactionAsync: SendTransactionMutateAsync<config, context>\n  }\n>\n\n/** https://wagmi.sh/vue/api/composables/useSendTransaction */\nexport function useSendTransaction<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: UseSendTransactionParameters<config, context> = {},\n): UseSendTransactionReturnType<config, context> {\n  const config = useConfig(parameters)\n  const mutationOptions = sendTransactionMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  type Return = UseSendTransactionReturnType<config, context>\n  return {\n    ...mutation,\n    sendTransaction: mutation.mutate as Return['mutate'],\n    sendTransactionAsync: mutation.mutateAsync as Return['mutateAsync'],\n  }\n}\n", "import type { SignMessageErrorType } from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type SignMessageData,\n  type SignMessageMutate,\n  type SignMessageMutateAsync,\n  type SignMessageVariables,\n  signMessageMutationOptions,\n} from '@wagmi/core/query'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport {\n  type UseMutationParameters,\n  type UseMutationReturnType,\n  useMutation,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseSignMessageParameters<context = unknown> = Compute<\n  ConfigParameter & {\n    mutation?:\n      | UseMutationParameters<\n          SignMessageData,\n          SignMessageErrorType,\n          SignMessageVariables,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseSignMessageReturnType<context = unknown> = Compute<\n  UseMutationReturnType<\n    SignMessageData,\n    SignMessageErrorType,\n    SignMessageVariables,\n    context\n  > & {\n    mutate: SignMessageMutate<context>\n    mutateAsync: SignMessageMutateAsync<context>\n    /** @deprecated use `mutate` instead */\n    signMessage: SignMessageMutate<context>\n    /** @deprecated use `mutateAsync` instead */\n    signMessageAsync: SignMessageMutateAsync<context>\n  }\n>\n\n/** https://wagmi.sh/vue/api/composables/useSignMessage */\nexport function useSignMessage<context = unknown>(\n  parameters: UseSignMessageParameters<context> = {},\n): UseSignMessageReturnType<context> {\n  const config = useConfig(parameters)\n  const mutationOptions = signMessageMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  return {\n    ...mutation,\n    signMessage: mutation.mutate,\n    signMessageAsync: mutation.mutateAsync,\n  }\n}\n", "import type { SignTypedDataErrorType } from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type SignTypedDataData,\n  type SignTypedDataMutate,\n  type SignTypedDataMutateAsync,\n  type SignTypedDataVariables,\n  signTypedDataMutationOptions,\n} from '@wagmi/core/query'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport {\n  type UseMutationParameters,\n  type UseMutationReturnType,\n  useMutation,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseSignTypedDataParameters<context = unknown> = Compute<\n  ConfigParameter & {\n    mutation?:\n      | UseMutationParameters<\n          SignTypedDataData,\n          SignTypedDataErrorType,\n          SignTypedDataVariables,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseSignTypedDataReturnType<context = unknown> = Compute<\n  UseMutationReturnType<\n    SignTypedDataData,\n    SignTypedDataErrorType,\n    SignTypedDataVariables,\n    context\n  > & {\n    mutate: SignTypedDataMutate<context>\n    mutateAsync: SignTypedDataMutateAsync<context>\n    /** @deprecated use `mutate` instead */\n    signTypedData: SignTypedDataMutate<context>\n    /** @deprecated use `mutateAsync` instead */\n    signTypedDataAsync: SignTypedDataMutateAsync<context>\n  }\n>\n\n/** https://wagmi.sh/vue/api/composables/useSignTypedData */\nexport function useSignTypedData<context = unknown>(\n  parameters: UseSignTypedDataParameters<context> = {},\n): UseSignTypedDataReturnType<context> {\n  const config = useConfig(parameters)\n  const mutationOptions = signTypedDataMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  type Return = UseSignTypedDataReturnType<context>\n  return {\n    ...mutation,\n    mutate: mutation.mutate as Return['mutate'],\n    mutateAsync: mutation.mutateAsync as Return['mutateAsync'],\n    signTypedData: mutation.mutate as Return['mutate'],\n    signTypedDataAsync: mutation.mutateAsync as Return['mutateAsync'],\n  }\n}\n", "import type {\n  Config,\n  ResolvedRegister,\n  SimulateContractErrorType,\n} from '@wagmi/core'\nimport {\n  type SimulateContractData,\n  type SimulateContractOptions,\n  simulateContractQueryOptions,\n} from '@wagmi/core/query'\nimport type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'\nimport { computed, type MaybeRef } from 'vue'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { deepUnref } from '../utils/cloneDeep.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\nimport { useConnection } from './useConnection.js'\n\nexport type UseSimulateContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  config extends Config = Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = SimulateContractData<abi, functionName, args, config, chainId>,\n> = MaybeRef<\n  SimulateContractOptions<\n    abi,\n    functionName,\n    args,\n    config,\n    chainId,\n    selectData\n  > &\n    ConfigParameter<config>\n>\n\nexport type UseSimulateContractReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  config extends Config = Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = SimulateContractData<abi, functionName, args, config, chainId>,\n> = UseQueryReturnType<selectData, SimulateContractErrorType>\n\n/** https://wagmi.sh/vue/api/composables/useSimulateContract */\nexport function useSimulateContract<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  config extends Config = ResolvedRegister['config'],\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = SimulateContractData<abi, functionName, args, config, chainId>,\n>(\n  parameters: UseSimulateContractParameters<\n    abi,\n    functionName,\n    args,\n    config,\n    chainId,\n    selectData\n  > = {} as any,\n): UseSimulateContractReturnType<\n  abi,\n  functionName,\n  args,\n  config,\n  chainId,\n  selectData\n> {\n  const params = computed(() => deepUnref(parameters)) as any\n  const config = useConfig(params)\n  const { address, connector } = useConnection()\n  const chainId = useChainId({ config })\n  const options = computed(() =>\n    simulateContractQueryOptions(config as any, {\n      ...params.value,\n      account: params.value.account ?? address.value,\n      chainId: params.value.chainId ?? chainId.value,\n      connector: params.value.connector ?? connector.value,\n      query: params.value.query,\n    }),\n  )\n  return useQuery(options as any) as any\n}\n", "import { useMutation } from '@tanstack/vue-query'\nimport type {\n  Config,\n  ResolvedRegister,\n  SwitchChainErrorType,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type SwitchChainData,\n  type SwitchChainMutate,\n  type SwitchChainMutateAsync,\n  type SwitchChainVariables,\n  switchChainMutationOptions,\n} from '@wagmi/core/query'\nimport type { Ref } from 'vue'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useChains } from './useChains.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseSwitchChainParameters<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          SwitchChainData<config, config['chains'][number]['id']>,\n          SwitchChainErrorType,\n          SwitchChainVariables<config, config['chains'][number]['id']>,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseSwitchChainReturnType<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  UseMutationReturnType<\n    SwitchChainData<config, config['chains'][number]['id']>,\n    SwitchChainErrorType,\n    SwitchChainVariables<config, config['chains'][number]['id']>,\n    context\n  > & {\n    /** @deprecated use `useChains` instead */\n    chains: Ref<config['chains']>\n    mutate: SwitchChainMutate<config, context>\n    mutateAsync: SwitchChainMutateAsync<config, context>\n    /** @deprecated use `mutate` instead */\n    switchChain: SwitchChainMutate<config, context>\n    /** @deprecated use `mutateAsync` instead */\n    switchChainAsync: SwitchChainMutateAsync<config, context>\n  }\n>\n\n/** https://wagmi.sh/vue/api/composables/useSwitchChain */\nexport function useSwitchChain<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: UseSwitchChainParameters<config, context> = {},\n): UseSwitchChainReturnType<config, context> {\n  const config = useConfig(parameters)\n  const mutationOptions = switchChainMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  type Return = UseSwitchChainReturnType<config, context>\n  return {\n    ...(mutation as unknown as Return),\n    chains: useChains({ config }) as unknown as Ref<config['chains']>,\n    mutate: mutation.mutate as Return['mutate'],\n    mutateAsync: mutation.mutateAsync as Return['mutateAsync'],\n    switchChain: mutation.mutate as Return['mutate'],\n    switchChainAsync: mutation.mutateAsync as Return['mutateAsync'],\n  }\n}\n", "import { useMutation } from '@tanstack/vue-query'\nimport type {\n  Config,\n  Connector,\n  ResolvedRegister,\n  SwitchConnectionErrorType,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type SwitchConnectionData,\n  type SwitchConnectionMutate,\n  type SwitchConnectionMutateAsync,\n  type SwitchConnectionVariables,\n  switchConnectionMutationOptions,\n} from '@wagmi/core/query'\nimport { computed, type Ref } from 'vue'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\nimport { useConnections } from './useConnections.js'\n\nexport type UseSwitchConnectionParameters<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          SwitchConnectionData<config>,\n          SwitchConnectionErrorType,\n          SwitchConnectionVariables,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseSwitchConnectionReturnType<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  UseMutationReturnType<\n    SwitchConnectionData<config>,\n    SwitchConnectionErrorType,\n    SwitchConnectionVariables,\n    context\n  > & {\n    /** @deprecated use `useConnections` instead */\n    connectors: Ref<readonly Connector[]>\n    mutate: SwitchConnectionMutate<config, context>\n    mutateAsync: SwitchConnectionMutateAsync<config, context>\n    /** @deprecated use `switchConnection` instead */\n    switchAccount: SwitchConnectionMutate<config, context>\n    /** @deprecated use `switchConnectionAsync` instead */\n    switchAccountAsync: SwitchConnectionMutateAsync<config, context>\n    /** @deprecated use `mutate` instead */\n    switchConnection: SwitchConnectionMutate<config, context>\n    /** @deprecated use `mutateAsync` instead */\n    switchConnectionAsync: SwitchConnectionMutateAsync<config, context>\n  }\n>\n\n/** https://wagmi.sh/vue/api/composables/useSwitchConnection */\nexport function useSwitchConnection<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: UseSwitchConnectionParameters<config, context> = {},\n): UseSwitchConnectionReturnType<config, context> {\n  const config = useConfig(parameters)\n  const connections = useConnections({ config })\n  const mutationOptions = switchConnectionMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  return {\n    ...mutation,\n    connectors: computed(() =>\n      connections.value.map((connection) => connection.connector),\n    ),\n    mutate: mutation.mutate,\n    mutateAsync: mutation.mutateAsync,\n    switchAccount: mutation.mutate,\n    switchAccountAsync: mutation.mutateAsync,\n    switchConnection: mutation.mutate,\n    switchConnectionAsync: mutation.mutateAsync,\n  }\n}\n", "import type {\n  Config,\n  GetTransactionErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetTransactionData,\n  type GetTransactionOptions,\n  getTransactionQueryOptions,\n} from '@wagmi/core/query'\nimport { computed } from 'vue'\nimport type { ConfigParameter } from '../types/properties.js'\nimport type { DeepMaybeRef } from '../types/ref.js'\nimport { deepUnref } from '../utils/cloneDeep.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseTransactionParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetTransactionData<config, chainId>,\n> = Compute<\n  DeepMaybeRef<\n    GetTransactionOptions<config, chainId, selectData> & ConfigParameter<config>\n  >\n>\n\nexport type UseTransactionReturnType<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetTransactionData<config, chainId>,\n> = UseQueryReturnType<selectData, GetTransactionErrorType>\n\n/** https://wagmi.sh/vue/api/composables/useTransaction */\nexport function useTransaction<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetTransactionData<config, chainId>,\n>(\n  parameters: UseTransactionParameters<config, chainId, selectData> = {},\n): UseTransactionReturnType<config, chainId, selectData> {\n  const params = computed(() => deepUnref(parameters))\n  const config = useConfig(params)\n  const chainId = useChainId({ config })\n  const options = computed(() =>\n    getTransactionQueryOptions(config as any, {\n      ...params.value,\n      chainId: params.value.chainId ?? chainId.value,\n      query: params.value.query as any,\n    }),\n  )\n  return useQuery(options as any) as any\n}\n", "import type {\n  Config,\n  GetTransactionReceiptErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetTransactionReceiptData,\n  type GetTransactionReceiptOptions,\n  getTransactionReceiptQueryOptions,\n} from '@wagmi/core/query'\nimport { computed } from 'vue'\nimport type { ConfigParameter } from '../types/properties.js'\nimport type { DeepMaybeRef } from '../types/ref.js'\nimport { deepUnref } from '../utils/cloneDeep.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseTransactionReceiptParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetTransactionReceiptData<config, chainId>,\n> = Compute<\n  DeepMaybeRef<\n    GetTransactionReceiptOptions<config, chainId, selectData> &\n      ConfigParameter<config>\n  >\n>\n\nexport type UseTransactionReceiptReturnType<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetTransactionReceiptData<config, chainId>,\n> = UseQueryReturnType<selectData, GetTransactionReceiptErrorType>\n\n/** https://wagmi.sh/vue/api/composables/useTransactionReceipt */\nexport function useTransactionReceipt<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetTransactionReceiptData<config, chainId>,\n>(\n  parameters: UseTransactionReceiptParameters<config, chainId, selectData> = {},\n): UseTransactionReceiptReturnType<config, chainId, selectData> {\n  const params = computed(() => deepUnref(parameters))\n  const config = useConfig(params)\n  const chainId = useChainId({ config })\n  const options = computed(() =>\n    getTransactionReceiptQueryOptions(config as any, {\n      ...params.value,\n      chainId: params.value.chainId ?? chainId.value,\n      query: params.value.query as any,\n    }),\n  )\n  return useQuery(options as any) as any\n}\n", "import type {\n  Config,\n  ResolvedRegister,\n  WaitForTransactionReceiptErrorType,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type WaitForTransactionReceiptData,\n  type WaitForTransactionReceiptOptions,\n  waitForTransactionReceiptQueryOptions,\n} from '@wagmi/core/query'\nimport { computed } from 'vue'\nimport type { ConfigParameter } from '../types/properties.js'\nimport type { DeepMaybeRef } from '../types/ref.js'\nimport { deepUnref } from '../utils/cloneDeep.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseWaitForTransactionReceiptParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = WaitForTransactionReceiptData<config, chainId>,\n> = Compute<\n  DeepMaybeRef<\n    WaitForTransactionReceiptOptions<config, chainId, selectData> &\n      ConfigParameter<config>\n  >\n>\n\nexport type UseWaitForTransactionReceiptReturnType<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = WaitForTransactionReceiptData<config, chainId>,\n> = UseQueryReturnType<selectData, WaitForTransactionReceiptErrorType>\n\n/** https://wagmi.sh/vue/api/composables/useWaitForTransactionReceipt */\nexport function useWaitForTransactionReceipt<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = WaitForTransactionReceiptData<config, chainId>,\n>(\n  parameters: UseWaitForTransactionReceiptParameters<\n    config,\n    chainId,\n    selectData\n  > = {},\n): UseWaitForTransactionReceiptReturnType<config, chainId, selectData> {\n  const params = computed(() => deepUnref(parameters))\n  const config = useConfig(params)\n  const chainId = useChainId({ config })\n  const options = computed(() =>\n    waitForTransactionReceiptQueryOptions(config as any, {\n      ...params.value,\n      chainId: params.value.chainId ?? chainId.value,\n      query: params.value.query as any,\n    }),\n  )\n  return useQuery(options as any) as any\n}\n", "import {\n  type Config,\n  type ResolvedRegister,\n  type WatchContractEventParameters,\n  watchContractEvent,\n} from '@wagmi/core'\nimport type { UnionCompute, UnionExactPartial } from '@wagmi/core/internal'\nimport type { Abi, ContractEventName } from 'viem'\nimport { computed, watchEffect } from 'vue'\n\nimport type { ConfigParameter, EnabledParameter } from '../types/properties.js'\nimport type { DeepMaybeRef } from '../types/ref.js'\nimport { deepUnref } from '../utils/cloneDeep.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseWatchContractEventParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> = ContractEventName<abi>,\n  strict extends boolean | undefined = undefined,\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n> = DeepMaybeRef<\n  UnionCompute<\n    UnionExactPartial<\n      WatchContractEventParameters<abi, eventName, strict, config, chainId>\n    > &\n      ConfigParameter<config> &\n      EnabledParameter\n  >\n>\n\nexport type UseWatchContractEventReturnType = void\n\n/** https://wagmi.sh/vue/api/composables/useWatchContractEvent */\nexport function useWatchContractEvent<\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi>,\n  strict extends boolean | undefined = undefined,\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n>(\n  parameters: UseWatchContractEventParameters<\n    abi,\n    eventName,\n    strict,\n    config,\n    chainId\n  > = {} as any,\n): UseWatchContractEventReturnType {\n  const parameters_ = computed(() => deepUnref(parameters))\n\n  const config = useConfig(parameters_)\n  const configChainId = useChainId({ config })\n\n  watchEffect((onCleanup) => {\n    const {\n      chainId = configChainId.value,\n      enabled = true,\n      onLogs,\n      config: _,\n      ...rest\n    } = parameters_.value\n\n    if (!enabled) return\n    if (!onLogs) return\n\n    const unwatch = watchContractEvent(config, {\n      ...(rest as any),\n      chainId,\n      onLogs,\n    })\n    onCleanup(unwatch)\n  })\n}\n", "import { useMutation } from '@tanstack/vue-query'\nimport type {\n  Config,\n  ResolvedRegister,\n  WriteContractErrorType,\n} from '@wagmi/core'\nimport {\n  type WriteContractData,\n  type WriteContractMutate,\n  type WriteContractMutateAsync,\n  type WriteContractVariables,\n  writeContractMutationOptions,\n} from '@wagmi/core/query'\nimport type { Abi } from 'viem'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseWriteContractParameters<\n  config extends Config = Config,\n  context = unknown,\n> = ConfigParameter<config> & {\n  mutation?:\n    | UseMutationParameters<\n        WriteContractData,\n        WriteContractErrorType,\n        WriteContractVariables<\n          Abi,\n          string,\n          readonly unknown[],\n          config,\n          config['chains'][number]['id']\n        >,\n        context\n      >\n    | undefined\n}\n\nexport type UseWriteContractReturnType<\n  config extends Config = Config,\n  context = unknown,\n> = UseMutationReturnType<\n  WriteContractData,\n  WriteContractErrorType,\n  WriteContractVariables<\n    Abi,\n    string,\n    readonly unknown[],\n    config,\n    config['chains'][number]['id']\n  >,\n  context\n> & {\n  mutate: WriteContractMutate<config, context>\n  mutateAsync: WriteContractMutateAsync<config, context>\n  /** @deprecated use `mutate` instead */\n  writeContract: WriteContractMutate<config, context>\n  /** @deprecated use `mutateAsync` instead */\n  writeContractAsync: WriteContractMutateAsync<config, context>\n}\n\n/** https://wagmi.sh/vue/api/composables/useWriteContract */\nexport function useWriteContract<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: UseWriteContractParameters<config, context> = {},\n): UseWriteContractReturnType<config, context> {\n  const config = useConfig(parameters)\n  const mutationOptions = writeContractMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  type Return = UseWriteContractReturnType<config, context>\n  return {\n    ...(mutation as Return),\n    mutate: mutation.mutate as Return['mutate'],\n    mutateAsync: mutation.mutateAsync as Return['mutateAsync'],\n    writeContract: mutation.mutate as Return['mutate'],\n    writeContractAsync: mutation.mutateAsync as Return['mutateAsync'],\n  }\n}\n"],
  "mappings": "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",
  "names": ["BaseError", "BaseError", "structuralSharing", "isPlainObject", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery"]
}
