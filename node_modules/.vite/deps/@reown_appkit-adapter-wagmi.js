import "./chunk-2WP5DNSG.js";
import {
  W3mFrameProviderSingleton
} from "./chunk-3ZU5H2LN.js";
import {
  CaipNetworksUtil,
  ErrorUtil as ErrorUtil2,
  HelpersUtil
} from "./chunk-2VDYVRPE.js";
import {
  AdapterBlueprint,
  AlertController,
  SIWXUtil,
  WalletConnectConnector,
  WcHelpersUtil
} from "./chunk-VXPZBJVA.js";
import "./chunk-4Z2ZRXRP.js";
import "./chunk-H5SMHTBZ.js";
import {
  AssetController,
  ChainController,
  ConnectorController,
  CoreHelperUtil,
  OptionsController,
  StorageUtil,
  getActiveCaipNetwork,
  getPreferredAccountType,
  proxy,
  subscribeKey
} from "./chunk-J5D4ZCFA.js";
import {
  ConstantsUtil,
  ErrorUtil,
  NetworkUtil,
  PresetsUtil,
  UserRejectedRequestError
} from "./chunk-E52V435I.js";
import "./chunk-TM3FN7TW.js";
import "./chunk-ZMNNWV57.js";
import {
  ChainNotConfiguredError,
  ProviderNotFoundError,
  connect,
  createConfig,
  createConnector,
  disconnect,
  estimateGas,
  getBalance,
  getConnection,
  getConnections,
  injected,
  prepareTransactionRequest,
  reconnect,
  sendTransaction,
  signMessage,
  switchChain,
  waitForTransactionReceipt,
  watchConnection,
  watchConnections,
  watchConnectors,
  watchPendingTransactions,
  writeContract
} from "./chunk-U6EV7BEV.js";
import "./chunk-QMUQLAW7.js";
import "./chunk-KME7UKT3.js";
import "./chunk-PK3FUKRV.js";
import {
  parseUnits
} from "./chunk-DOW7LSSZ.js";
import "./chunk-4X65JDLI.js";
import "./chunk-UU24B44V.js";
import {
  SwitchChainError,
  UserRejectedRequestError as UserRejectedRequestError2,
  checksumAddress,
  formatUnits,
  getAddress,
  numberToHex
} from "./chunk-Z6GLK4M2.js";
import "./chunk-KR3SNR3Q.js";
import "./chunk-XIJ6CS2S.js";
import "./chunk-HXNQWV53.js";
import "./chunk-DI52DQAC.js";

// node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/connectors/AuthConnector.js
function authConnector(parameters) {
  let currentAccounts = [];
  let socialProvider = void 0;
  let connectSocialPromise = void 0;
  function parseChainId(chainId) {
    const networks = ChainController.getCaipNetworks(ConstantsUtil.CHAIN.EVM);
    let network = Number(NetworkUtil.parseEvmChainId(chainId));
    if (!networks.some((n) => String(n.id) === String(chainId))) {
      const currentChainId = ChainController.getActiveCaipNetwork(ConstantsUtil.CHAIN.EVM)?.id || networks[0]?.id;
      if (currentChainId && Number.isInteger(Number(currentChainId))) {
        network = Number(currentChainId);
      }
    }
    if (!network) {
      throw new Error("ChainId not found in networks");
    }
    return network;
  }
  function getProviderInstance() {
    if (!socialProvider) {
      socialProvider = W3mFrameProviderSingleton.getInstance({
        projectId: parameters.options.projectId,
        chainId: getActiveCaipNetwork()?.caipNetworkId,
        enableLogger: parameters.options.enableAuthLogger,
        onTimeout: (reason) => {
          if (reason === "iframe_load_failed") {
            AlertController.open(ErrorUtil2.ALERT_ERRORS.IFRAME_LOAD_FAILED, "error");
          } else if (reason === "iframe_request_timeout") {
            AlertController.open(ErrorUtil2.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT, "error");
          } else if (reason === "unverified_domain") {
            AlertController.open(ErrorUtil2.ALERT_ERRORS.UNVERIFIED_DOMAIN, "error");
          }
        },
        abortController: ErrorUtil2.EmbeddedWalletAbortController,
        getActiveCaipNetwork: (namespace) => getActiveCaipNetwork(namespace),
        getCaipNetworks: (namespace) => ChainController.getCaipNetworks(namespace)
      });
    }
    return socialProvider;
  }
  async function connectSocial(options = {}) {
    const provider = getProviderInstance();
    let chainId = options.chainId;
    if (options.isReconnecting) {
      const lastUsedChainId = NetworkUtil.parseEvmChainId(provider.getLastUsedChainId() || "");
      const defaultChainId = parameters.chains?.[0].id;
      chainId = lastUsedChainId || defaultChainId;
      if (!chainId) {
        throw new Error("ChainId not found in provider");
      }
    }
    const preferredAccountType = getPreferredAccountType("eip155");
    const { address, chainId: frameChainId, accounts } = await SIWXUtil.authConnectorAuthenticate({
      authConnector: provider,
      chainId,
      preferredAccountType,
      socialUri: options.socialUri,
      chainNamespace: ConstantsUtil.CHAIN.EVM
    });
    currentAccounts = accounts?.map((a) => a.address) || [address];
    const parsedChainId = parseChainId(frameChainId);
    return {
      accounts: currentAccounts,
      account: address,
      chainId: parsedChainId,
      chain: {
        id: parsedChainId,
        unsupported: false
      }
    };
  }
  return createConnector((config) => ({
    id: ConstantsUtil.CONNECTOR_ID.AUTH,
    name: ConstantsUtil.CONNECTOR_NAMES.AUTH,
    type: "AUTH",
    chain: ConstantsUtil.CHAIN.EVM,
    async connect(options = {}) {
      if (connectSocialPromise) {
        const result2 = await connectSocialPromise;
        return {
          accounts: options.withCapabilities ? result2.accounts.map((address) => ({ address, capabilities: {} })) : result2.accounts,
          chainId: result2.chainId
        };
      }
      if (!connectSocialPromise) {
        connectSocialPromise = new Promise((resolve) => {
          resolve(connectSocial(options));
        });
      }
      const result = await connectSocialPromise;
      connectSocialPromise = void 0;
      return {
        accounts: options.withCapabilities ? result.accounts.map((address) => ({ address, capabilities: {} })) : result.accounts,
        chainId: result.chainId
      };
    },
    async disconnect() {
      const provider = await this.getProvider();
      await provider.disconnect();
    },
    getAccounts() {
      if (!currentAccounts?.length) {
        return Promise.resolve([]);
      }
      config.emitter.emit("change", { accounts: currentAccounts });
      return Promise.resolve(currentAccounts);
    },
    async getProvider() {
      if (!this.provider) {
        this.provider = W3mFrameProviderSingleton.getInstance({
          projectId: parameters.options.projectId,
          chainId: getActiveCaipNetwork()?.caipNetworkId,
          enableLogger: parameters.options.enableAuthLogger,
          abortController: ErrorUtil2.EmbeddedWalletAbortController,
          onTimeout: (reason) => {
            if (reason === "iframe_load_failed") {
              AlertController.open(ErrorUtil2.ALERT_ERRORS.IFRAME_LOAD_FAILED, "error");
            } else if (reason === "iframe_request_timeout") {
              AlertController.open(ErrorUtil2.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT, "error");
            } else if (reason === "unverified_domain") {
              AlertController.open(ErrorUtil2.ALERT_ERRORS.UNVERIFIED_DOMAIN, "error");
            }
          },
          getActiveCaipNetwork: (namespace) => getActiveCaipNetwork(namespace),
          getCaipNetworks: (namespace) => ChainController.getCaipNetworks(namespace)
        });
      }
      return Promise.resolve(this.provider);
    },
    async getChainId() {
      const provider = await this.getProvider();
      const { chainId } = await provider.getChainId();
      return parseChainId(chainId);
    },
    async isAuthorized() {
      const activeChain = ChainController.state.activeChain;
      const isActiveChainEvm = activeChain === ConstantsUtil.CHAIN.EVM;
      const isAnyAuthConnected = ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.some((chain) => ConnectorController.getConnectorId(chain) === ConstantsUtil.CONNECTOR_ID.AUTH);
      if (isAnyAuthConnected && !isActiveChainEvm) {
        return false;
      }
      const provider = await this.getProvider();
      return Promise.resolve(provider.getLoginEmailUsed());
    },
    async switchChain({ chainId }) {
      try {
        const chain = config.chains.find((c) => c.id === chainId);
        if (!chain) {
          throw new SwitchChainError(new Error("chain not found on connector."));
        }
        const provider = await this.getProvider();
        const preferredAccountType = getPreferredAccountType("eip155");
        const response = await provider.connect({
          chainId,
          preferredAccountType
        });
        currentAccounts = response?.accounts?.map((a) => a.address) || [response.address];
        config.emitter.emit("change", {
          chainId: Number(chainId),
          accounts: currentAccounts
        });
        return chain;
      } catch (error) {
        if (error instanceof Error) {
          throw new SwitchChainError(error);
        }
        throw error;
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0) {
        this.onDisconnect();
      } else {
        config.emitter.emit("change", { accounts: accounts.map(getAddress) });
      }
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error) {
      const provider = await this.getProvider();
      await provider.disconnect();
    }
  }));
}

// node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/connectors/WalletConnectConnector.js
walletConnect.type = "walletConnect";
function walletConnect(parameters) {
  const isNewChainsStale = parameters.isNewChainsStale ?? true;
  let provider_;
  let accountsChanged;
  let chainChanged;
  let connect2;
  let displayUri;
  let sessionDelete;
  let disconnect2;
  return createConnector((config) => ({
    id: "walletConnect",
    name: "WalletConnect",
    type: walletConnect.type,
    provider: parameters.universalProvider,
    async setup() {
      const provider = await this.getProvider().catch(() => null);
      if (!provider) {
        return;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider.on("connect", connect2);
      }
      if (!sessionDelete) {
        sessionDelete = this.onSessionDelete.bind(this);
        provider.on("session_delete", sessionDelete);
      }
    },
    async connect({ ...rest } = {}) {
      try {
        const caipNetworks = ChainController.getCaipNetworks();
        const provider = await this.getProvider();
        if (!provider) {
          throw new ProviderNotFoundError();
        }
        if (!displayUri) {
          displayUri = this.onDisplayUri;
          provider.on("display_uri", displayUri);
        }
        const isChainsStale = await this.isChainsStale();
        if (provider.session && isChainsStale) {
          await provider.disconnect();
        }
        const universalProviderConfigOverride = OptionsController.state.universalProviderConfigOverride;
        if (!provider.session || isChainsStale) {
          const namespaces = WcHelpersUtil.createNamespaces(caipNetworks, universalProviderConfigOverride);
          await provider.connect({
            optionalNamespaces: namespaces,
            ..."pairingTopic" in rest ? { pairingTopic: rest.pairingTopic } : {}
          });
          this.setRequestedChainsIds(caipNetworks.map((x) => Number(x.id)));
        }
        const accounts = await this.getAccounts();
        const requestChainId = await this.getChainId();
        const chains = provider.session?.namespaces?.["eip155"]?.chains;
        const isRequestedChainSupported = chains?.some((chain) => Number(chain.split(":")[1]) === requestChainId);
        let currentChainId = 1;
        if (isRequestedChainSupported) {
          currentChainId = requestChainId;
        } else if (chains?.[0]) {
          currentChainId = Number(chains[0].split(":")[1]);
        }
        if (displayUri) {
          provider.removeListener("display_uri", displayUri);
          displayUri = void 0;
        }
        if (connect2) {
          provider.removeListener("connect", connect2);
          connect2 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect2);
        }
        if (!sessionDelete) {
          sessionDelete = this.onSessionDelete.bind(this);
          provider.on("session_delete", sessionDelete);
        }
        const defaultChain = universalProviderConfigOverride?.defaultChain;
        provider.setDefaultChain(defaultChain ?? `eip155:${currentChainId}`);
        return {
          accounts,
          chainId: currentChainId
        };
      } catch (error) {
        if (/(user rejected|connection request reset)/i.test(error?.message)) {
          throw new UserRejectedRequestError2(error);
        }
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      try {
        await provider?.disconnect();
      } catch (error) {
        if (!/No matching key/i.test(error.message)) {
          throw error;
        }
      } finally {
        if (chainChanged) {
          provider?.removeListener("chainChanged", chainChanged);
          chainChanged = void 0;
        }
        if (disconnect2) {
          provider?.removeListener("disconnect", disconnect2);
          disconnect2 = void 0;
        }
        if (!connect2) {
          connect2 = this.onConnect.bind(this);
          provider?.on("connect", connect2);
        }
        if (accountsChanged) {
          provider?.removeListener("accountsChanged", accountsChanged);
          accountsChanged = void 0;
        }
        if (sessionDelete) {
          provider?.removeListener("session_delete", sessionDelete);
          sessionDelete = void 0;
        }
        this.setRequestedChainsIds([]);
      }
    },
    async getAccounts() {
      const provider = await this.getProvider();
      if (!provider?.session?.namespaces) {
        return [];
      }
      const accountsList = provider?.session?.namespaces[ConstantsUtil.CHAIN.EVM]?.accounts;
      const accounts = accountsList?.map((account) => account.split(":")[2]) ?? [];
      const accountsAdded = /* @__PURE__ */ new Set();
      const deduplicatedAccounts = accounts.filter((account) => {
        const lowerCasedAccount = account?.toLowerCase();
        if (accountsAdded.has(lowerCasedAccount)) {
          return false;
        }
        accountsAdded.add(lowerCasedAccount);
        return true;
      });
      return deduplicatedAccounts;
    },
    async getProvider({ chainId } = {}) {
      if (!provider_) {
        provider_ = parameters.universalProvider;
        provider_?.events.setMaxListeners(Number.POSITIVE_INFINITY);
      }
      const activeNamespace = StorageUtil.getActiveNamespace();
      const currentChainId = ChainController.getActiveCaipNetwork()?.id;
      if (chainId && currentChainId !== chainId && activeNamespace) {
        const storedCaipNetworkId = StorageUtil.getStoredActiveCaipNetworkId();
        const appKitCaipNetworks = activeNamespace ? ChainController.getCaipNetworks(activeNamespace) : [];
        const storedCaipNetwork = appKitCaipNetworks?.find((n) => n.id === storedCaipNetworkId);
        if (storedCaipNetwork && storedCaipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM) {
          await this.switchChain?.({ chainId: Number(storedCaipNetwork.id) });
        }
      }
      return provider_;
    },
    async getChainId() {
      const chainId = ChainController.getActiveCaipNetwork(ConstantsUtil.CHAIN.EVM)?.id;
      if (chainId) {
        return chainId;
      }
      const provider = await this.getProvider();
      const chain = provider.session?.namespaces[ConstantsUtil.CHAIN.EVM]?.chains?.[0];
      const network = ChainController.getCaipNetworks().find((c) => c.id === chain);
      return network?.id;
    },
    async isAuthorized() {
      try {
        const [accounts, provider] = await Promise.all([this.getAccounts(), this.getProvider()]);
        if (!accounts.length) {
          return false;
        }
        const isChainsStale = await this.isChainsStale();
        if (isChainsStale && provider.session) {
          await provider.disconnect().catch(() => {
          });
          return false;
        }
        return true;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      const provider = await this.getProvider();
      if (!provider) {
        throw new ProviderNotFoundError();
      }
      const chainToSwitch = ChainController.getCaipNetworks().find((x) => x.id === chainId);
      if (!chainToSwitch) {
        throw new SwitchChainError(new ChainNotConfiguredError());
      }
      try {
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chainId) }]
        });
        if (chainToSwitch?.caipNetworkId) {
          provider.setDefaultChain(chainToSwitch?.caipNetworkId);
        }
        config.emitter.emit("change", { chainId: Number(chainId) });
        const requestedChains = await this.getRequestedChainsIds();
        this.setRequestedChainsIds([...requestedChains, chainId]);
        return { ...chainToSwitch, id: chainToSwitch.id };
      } catch (err) {
        const error = err;
        if (/(?:user rejected)/iu.test(error.message)) {
          throw new UserRejectedRequestError2(error);
        }
        try {
          let blockExplorerUrls;
          if (addEthereumChainParameter?.blockExplorerUrls) {
            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
          } else {
            blockExplorerUrls = chainToSwitch.blockExplorers?.default.url ? [chainToSwitch.blockExplorers?.default.url] : [];
          }
          const rpcUrls = chainToSwitch.rpcUrls?.["chainDefault"]?.http || [];
          const addEthereumChain = {
            blockExplorerUrls,
            chainId: numberToHex(chainId),
            chainName: chainToSwitch.name,
            iconUrls: addEthereumChainParameter?.iconUrls,
            nativeCurrency: chainToSwitch.nativeCurrency,
            rpcUrls
          };
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [addEthereumChain]
          });
          const requestedChains = await this.getRequestedChainsIds();
          this.setRequestedChainsIds([...requestedChains, chainId]);
          return { ...chainToSwitch, id: chainToSwitch.id };
        } catch (e) {
          throw new UserRejectedRequestError2(e);
        }
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0) {
        this.onDisconnect();
      } else {
        config.emitter.emit("change", {
          accounts: accounts.map((x) => getAddress(x))
        });
      }
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    onConnect(_connectInfo) {
      this.setRequestedChainsIds(ChainController.getCaipNetworks().map((x) => Number(x.id)));
    },
    async onDisconnect(_error) {
      this.setRequestedChainsIds([]);
      config.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      if (sessionDelete) {
        provider.removeListener("session_delete", sessionDelete);
        sessionDelete = void 0;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider.on("connect", connect2);
      }
    },
    onDisplayUri(uri) {
      config.emitter.emit("message", { type: "display_uri", data: uri });
    },
    onSessionDelete() {
      this.onDisconnect();
    },
    getNamespaceChainsIds() {
      if (!provider_?.session?.namespaces) {
        return [];
      }
      const accounts = provider_?.session?.namespaces[ConstantsUtil.CHAIN.EVM]?.accounts;
      const chainIds = accounts?.map((account) => Number.parseInt(account.split(":")[1] ?? "")) ?? [];
      return chainIds;
    },
    async getRequestedChainsIds() {
      const chainIds = await config.storage?.getItem(this.requestedChainsStorageKey) ?? [];
      return [...new Set(chainIds)];
    },
    async isChainsStale() {
      if (!isNewChainsStale) {
        return false;
      }
      const connectorChains = config.chains.map((x) => x.id);
      const namespaceChains = this.getNamespaceChainsIds();
      if (namespaceChains.length && !namespaceChains.some((id) => connectorChains.includes(id))) {
        return false;
      }
      const requestedChains = await this.getRequestedChainsIds();
      return !connectorChains.every((id) => requestedChains.includes(Number(id)));
    },
    async setRequestedChainsIds(chains) {
      await config.storage?.setItem(this.requestedChainsStorageKey, chains);
    },
    get requestedChainsStorageKey() {
      return `${this.id}.requestedChains`;
    }
  }));
}

// node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/utils/LimitterUtil.js
var state = proxy({
  pendingTransactions: 0
});
var LimitterUtil = {
  state,
  subscribeKey(key, callback) {
    return subscribeKey(state, key, callback);
  },
  increase(value) {
    state[value] += 1;
  },
  decrease(value) {
    state[value] -= 1;
  },
  reset(value) {
    state[value] = 0;
  }
};

// node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/utils/helpers.js
async function getSafeConnector(connectors) {
  if (CoreHelperUtil.isSafeApp()) {
    const { safe } = await import("./exports-WCNF7WCA.js");
    if (safe && !connectors.some((c) => c.type === "safe")) {
      const safeConnector = safe();
      return safeConnector;
    }
  }
  return null;
}
async function getBaseAccountConnector(connectors) {
  try {
    const { baseAccount } = await import("./exports-WCNF7WCA.js");
    if (baseAccount && !connectors.some((c) => c.id === "baseAccount")) {
      return baseAccount();
    }
  } catch (error) {
    console.error("Failed to import Coinbase Wallet SDK:", error);
  }
  return null;
}

// node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/client.js
var DEFAULT_PENDING_TRANSACTIONS_FILTER = {
  enable: false,
  pollingInterval: 3e4
};
var WagmiAdapter = class extends AdapterBlueprint {
  constructor(configParams) {
    const networks = CaipNetworksUtil.extendCaipNetworks(configParams.networks, {
      projectId: configParams.projectId,
      customNetworkImageUrls: {},
      customRpcUrls: configParams.customRpcUrls
    });
    super();
    this.balancePromises = {};
    this.namespace = ConstantsUtil.CHAIN.EVM;
    this.adapterType = ConstantsUtil.ADAPTER_TYPES.WAGMI;
    this.projectId = configParams.projectId;
    this.pendingTransactionsFilter = {
      ...DEFAULT_PENDING_TRANSACTIONS_FILTER,
      ...configParams.pendingTransactionsFilter ?? {}
    };
    this.createConfig({ ...configParams, networks });
    this.checkChainId();
  }
  construct(_options) {
    this.checkChainId();
    this.setupWatchers();
  }
  async getAccounts(params) {
    const connector = this.getWagmiConnector(params.id);
    if (!connector) {
      return { accounts: [] };
    }
    if (connector.id === ConstantsUtil.CONNECTOR_ID.AUTH) {
      const provider = await connector.getProvider();
      if (!provider?.user) {
        return { accounts: [] };
      }
      const { address: address2, accounts } = provider.user;
      return Promise.resolve({
        accounts: (accounts || [{ address: address2, type: "eoa" }]).map((account) => CoreHelperUtil.createAccount("eip155", account.address, account.type))
      });
    }
    const { addresses, address } = getConnection(this.wagmiConfig);
    return Promise.resolve({
      accounts: [...new Set(addresses || [address])]?.map((val) => CoreHelperUtil.createAccount("eip155", val || "", "eoa"))
    });
  }
  checkChainId() {
    const { chainId } = getConnection(this.wagmiConfig);
    if (chainId) {
      this.emit("switchNetwork", {
        chainId
      });
    }
  }
  getWagmiConnector(id) {
    return this.wagmiConfig.connectors.find((c) => c.id === id);
  }
  createConfig(configParams) {
    this.wagmiChains = configParams.networks.filter((caipNetwork) => caipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM);
    const transports = {};
    const connectors = [...configParams.connectors ?? []];
    this.wagmiChains.forEach((element) => {
      const fromTransportProp = configParams.transports?.[element.id];
      const caipNetworkId = CaipNetworksUtil.getCaipNetworkId(element);
      if (fromTransportProp) {
        transports[element.id] = CaipNetworksUtil.extendWagmiTransports(element, configParams.projectId, fromTransportProp);
      } else {
        transports[element.id] = CaipNetworksUtil.getViemTransport(element, configParams.projectId, configParams.customRpcUrls?.[caipNetworkId]);
      }
    });
    this.wagmiConfig = createConfig({
      ...configParams,
      chains: this.wagmiChains,
      connectors,
      transports
    });
  }
  setupWatchPendingTransactions() {
    if (!this.pendingTransactionsFilter.enable || this.unwatchPendingTransactions) {
      return;
    }
    this.unwatchPendingTransactions = watchPendingTransactions(this.wagmiConfig, {
      pollingInterval: this.pendingTransactionsFilter.pollingInterval,
      onError: () => {
      },
      onTransactions: () => {
        this.emit("pendingTransactions");
        LimitterUtil.increase("pendingTransactions");
      }
    });
    const unsubscribe = LimitterUtil.subscribeKey("pendingTransactions", (val) => {
      if (val >= ConstantsUtil.LIMITS.PENDING_TRANSACTIONS) {
        this.unwatchPendingTransactions?.();
        unsubscribe();
      }
    });
  }
  setupWatchers() {
    watchConnections(this.wagmiConfig, {
      onChange: (connections) => {
        this.clearConnections();
        this.addConnection(...connections.map((connection) => {
          const caipNetwork = this.getCaipNetworks().find((network) => network.id === connection.chainId);
          const isAuth = connection.connector.id === ConstantsUtil.CONNECTOR_ID.AUTH;
          return {
            accounts: connection.accounts.map((account) => ({
              address: this.toChecksummedAddress(account)
            })),
            caipNetwork,
            connectorId: connection.connector.id,
            auth: isAuth ? {
              name: StorageUtil.getConnectedSocialProvider(),
              username: StorageUtil.getConnectedSocialUsername()
            } : void 0
          };
        }));
      }
    });
    watchConnection(this.wagmiConfig, {
      onChange: (accountData, prevAccountData) => {
        if (accountData.status === "disconnected" && prevAccountData.address) {
          this.emit("disconnect");
        }
        if (accountData?.chainId && accountData?.chainId !== prevAccountData?.chainId) {
          this.emit("switchNetwork", {
            chainId: accountData.chainId
          });
        }
        if (accountData.status === "connected") {
          const hasAccountChanged = accountData.address !== prevAccountData?.address;
          const hasConnectorChanged = accountData.connector.id !== prevAccountData.connector?.id;
          const hasConnectionStatusChanged = prevAccountData.status !== "connected";
          if (hasAccountChanged || hasConnectorChanged || hasConnectionStatusChanged) {
            this.setupWatchPendingTransactions();
            this.handleAccountChanged({
              address: accountData.address,
              chainId: accountData.chainId,
              connector: accountData.connector
            });
          }
        }
      }
    });
  }
  async addThirdPartyConnectors() {
    const thirdPartyConnectors = [];
    const { enableCoinbase: isCoinbaseEnabled } = OptionsController.state || {};
    if (isCoinbaseEnabled !== false) {
      const baseAccountConnector = await getBaseAccountConnector(this.wagmiConfig.connectors);
      if (baseAccountConnector) {
        thirdPartyConnectors.push(baseAccountConnector);
      }
    }
    const safeConnector = await getSafeConnector(this.wagmiConfig.connectors);
    if (safeConnector) {
      thirdPartyConnectors.push(safeConnector);
    }
    await Promise.all(thirdPartyConnectors.map((connector) => {
      const cnctr = this.configureInternalConnector(connector);
      return this.addWagmiConnector(cnctr);
    }));
  }
  addWagmiConnectors() {
    const customConnectors = [];
    if (OptionsController.state.enableInjected !== false) {
      customConnectors.push(injected({ shimDisconnect: true }));
    }
    const { features, remoteFeatures, projectId, enableAuthLogger: isAuthLoggerEnabled } = OptionsController.state;
    const isEmailEnabled = remoteFeatures?.email ?? features?.email ?? true;
    const socials = remoteFeatures?.socials ?? features?.socials;
    const isSocialsEnabled = Array.isArray(socials) && socials?.length > 0;
    if (isEmailEnabled || isSocialsEnabled) {
      customConnectors.push(authConnector({
        chains: this.wagmiChains,
        options: { projectId, enableAuthLogger: isAuthLoggerEnabled }
      }));
    }
    customConnectors.forEach((connector) => {
      this.configureInternalConnector(connector);
    });
  }
  configureInternalConnector(connector) {
    const cnctr = this.wagmiConfig._internal.connectors.setup(connector);
    this.wagmiConfig._internal.connectors.setState((prev) => [...prev, cnctr]);
    return cnctr;
  }
  async handleAccountChanged({ address, chainId, connector }) {
    if (!this.namespace) {
      throw new Error("WagmiAdapter:handleAccountChanged - namespace is required");
    }
    const provider = await connector.getProvider().catch(() => void 0);
    this.emit("accountChanged", {
      address: this.toChecksummedAddress(address),
      chainId,
      connector: {
        id: connector.id,
        name: PresetsUtil.ConnectorNamesMap[connector.id] ?? connector.name,
        imageId: PresetsUtil.ConnectorImageIds[connector.id],
        type: PresetsUtil.ConnectorTypesMap[connector.type] ?? "EXTERNAL",
        info: connector.id === ConstantsUtil.CONNECTOR_ID.INJECTED ? void 0 : { rdns: connector.id },
        provider,
        chain: this.namespace,
        chains: []
      }
    });
  }
  async writeSolanaTransaction() {
    return Promise.resolve({ hash: "" });
  }
  async signMessage(params) {
    try {
      const signature = await signMessage(this.wagmiConfig, {
        message: params.message,
        account: params.address
      });
      return { signature };
    } catch (error) {
      throw new Error("WagmiAdapter:signMessage - Sign message failed");
    }
  }
  async sendTransaction(params) {
    const { chainId, address } = getConnection(this.wagmiConfig);
    const wagmiChain = this.wagmiChains?.find((chain) => chain.id === chainId);
    const txParams = {
      account: address,
      to: params.to,
      value: Number.isNaN(Number(params.value)) ? BigInt(0) : BigInt(params.value),
      gas: params.gas ? BigInt(params.gas) : void 0,
      gasPrice: params.gasPrice ? BigInt(params.gasPrice) : void 0,
      data: params.data,
      chain: wagmiChain,
      type: "legacy",
      parameters: ["nonce"]
    };
    await prepareTransactionRequest(this.wagmiConfig, txParams);
    const tx = await sendTransaction(this.wagmiConfig, txParams);
    await waitForTransactionReceipt(this.wagmiConfig, { hash: tx, timeout: 25e3 });
    return { hash: tx };
  }
  async writeContract(params) {
    const { caipNetwork, ...data } = params;
    const chainId = Number(NetworkUtil.caipNetworkIdToNumber(caipNetwork.caipNetworkId));
    const wagmiChain = this.wagmiChains?.find((chain) => chain.id === chainId);
    const tx = await writeContract(this.wagmiConfig, {
      chain: wagmiChain,
      address: data.tokenAddress,
      account: data.fromAddress,
      abi: data.abi,
      functionName: data.method,
      args: data.args,
      __mode: "prepared"
    });
    return { hash: tx };
  }
  async estimateGas(params) {
    try {
      const result = await estimateGas(this.wagmiConfig, {
        account: params.address,
        to: params.to,
        data: params.data,
        type: "legacy"
      });
      return { gas: result };
    } catch (error) {
      throw new Error("WagmiAdapter:estimateGas - error estimating gas");
    }
  }
  parseUnits(params) {
    return parseUnits(params.value, params.decimals);
  }
  formatUnits(params) {
    return formatUnits(params.value, params.decimals);
  }
  async addWagmiConnector(connector) {
    if (!this.namespace) {
      throw new Error("WagmiAdapter:addWagmiConnector - namespace is required");
    }
    const { enableEIP6963: isEIP6963Enabled } = OptionsController.state || {};
    if (connector.type === ConstantsUtil.CONNECTOR_ID.INJECTED && isEIP6963Enabled === false) {
      return;
    }
    if (connector.id === ConstantsUtil.CONNECTOR_ID.AUTH || connector.id === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
      return;
    }
    let provider = void 0;
    if (connector.id !== ConstantsUtil.CONNECTOR_ID.BASE_ACCOUNT) {
      provider = await connector.getProvider().catch(() => void 0);
    }
    const customConnectorImages = AssetController.state.connectorImages;
    this.addConnector({
      id: connector.id,
      explorerId: PresetsUtil.ConnectorExplorerIds[connector.id] ?? PresetsUtil.ConnectorExplorerIds[connector.name],
      imageUrl: customConnectorImages?.[connector.id] ?? connector.icon,
      name: PresetsUtil.ConnectorNamesMap[connector.id] ?? connector.name,
      imageId: PresetsUtil.ConnectorImageIds[connector.id],
      type: PresetsUtil.ConnectorTypesMap[connector.type] ?? "EXTERNAL",
      info: connector.id === ConstantsUtil.CONNECTOR_ID.INJECTED ? void 0 : { rdns: connector.id },
      provider,
      chain: this.namespace,
      chains: []
    });
  }
  async syncConnectors() {
    watchConnectors(this.wagmiConfig, {
      onChange: (connectors) => {
        connectors.forEach((connector) => this.addWagmiConnector(connector));
      }
    });
    this.addWagmiConnectors();
    await Promise.all(this.wagmiConfig.connectors.map((connector) => this.addWagmiConnector(connector)));
    await this.addThirdPartyConnectors();
  }
  async syncConnections() {
    const wagmiConnectors = this.connectors.filter((c) => {
      const { hasDisconnected, hasConnected } = HelpersUtil.getConnectorStorageInfo(c.id, this.namespace);
      return !hasDisconnected && hasConnected;
    }).map((connector) => this.getWagmiConnector(connector.id)).filter(Boolean);
    await reconnect(this.wagmiConfig, {
      connectors: wagmiConnectors
    });
  }
  async syncConnection(params) {
    const { id, chainId } = params;
    const connections = getConnections(this.wagmiConfig);
    const connection = connections.find((c) => c.connector.id === id);
    const connector = this.getWagmiConnector(id);
    const provider = await connector?.getProvider();
    const isSafeApp = CoreHelperUtil.isSafeApp();
    if (isSafeApp && id === ConstantsUtil.CONNECTOR_ID.SAFE && !connection?.accounts.length) {
      const safeAppConnector = this.getWagmiConnector("safe");
      if (safeAppConnector) {
        const res = await connect(this.wagmiConfig, {
          connector: safeAppConnector,
          chainId: Number(chainId)
        });
        const safeProvider = await safeAppConnector.getProvider();
        return {
          chainId: Number(chainId),
          address: this.toChecksummedAddress(res.accounts[0]),
          provider: safeProvider,
          type: connection?.connector.type?.toUpperCase(),
          id: connection?.connector.id
        };
      }
    }
    return {
      chainId: Number(connection?.chainId),
      address: this.toChecksummedAddress(connection?.accounts[0]),
      provider,
      type: connection?.connector.type?.toUpperCase(),
      id: connection?.connector.id
    };
  }
  async connectWalletConnect(chainId) {
    try {
      const walletConnectConnector = this.getWalletConnectConnector();
      await walletConnectConnector.authenticate();
      const wagmiConnector = this.getWagmiConnector("walletConnect");
      if (!wagmiConnector) {
        throw new Error("UniversalAdapter:connectWalletConnect - connector not found");
      }
      const res = await connect(this.wagmiConfig, {
        connector: wagmiConnector,
        chainId: chainId ? Number(chainId) : void 0
      });
      if (res.chainId !== Number(chainId)) {
        await switchChain(this.wagmiConfig, { chainId: res.chainId });
      }
      return { clientId: await walletConnectConnector.provider.client.core.crypto.getClientId() };
    } catch (err) {
      if (err instanceof UserRejectedRequestError2) {
        throw new UserRejectedRequestError(err);
      }
      if (ErrorUtil.isUserRejectedRequestError(err)) {
        throw new UserRejectedRequestError(err);
      }
      throw err;
    }
  }
  async connect(params) {
    try {
      const { id, address, provider, type, info, chainId, socialUri } = params;
      const connector = this.getWagmiConnector(id);
      if (!connector) {
        throw new Error("connectionControllerClient:connectExternal - connector is undefined");
      }
      if (provider && info && connector.id === ConstantsUtil.CONNECTOR_ID.EIP6963) {
        connector.setEip6963Wallet?.({ provider, info });
      }
      const connection = this.wagmiConfig.state?.connections?.get(connector.uid);
      if (connection) {
        await this.wagmiConfig.storage?.setItem("recentConnectorId", connector.id);
        const sortedAccounts = [...connection.accounts].sort((a, b) => {
          if (HelpersUtil.isLowerCaseMatch(a, address)) {
            return -1;
          }
          if (HelpersUtil.isLowerCaseMatch(b, address)) {
            return 1;
          }
          return 0;
        });
        this.wagmiConfig?.setState((x) => ({
          ...x,
          connections: new Map(x.connections).set(connector.uid, {
            accounts: sortedAccounts,
            chainId: connection.chainId,
            connector: connection.connector
          }),
          current: connector.uid,
          status: "connected"
        }));
        return {
          address: this.toChecksummedAddress(sortedAccounts[0]),
          chainId: connection.chainId,
          provider,
          type,
          id
        };
      }
      const res = await connect(this.wagmiConfig, {
        connector,
        chainId: chainId ? Number(chainId) : void 0,
        socialUri
      });
      const resolvedProvider = provider ?? await connector.getProvider();
      return {
        address: this.toChecksummedAddress(res.accounts[0]),
        chainId: res.chainId,
        provider: resolvedProvider,
        type,
        id
      };
    } catch (err) {
      if (err instanceof UserRejectedRequestError2) {
        throw new UserRejectedRequestError(err);
      }
      if (ErrorUtil.isUserRejectedRequestError(err)) {
        throw new UserRejectedRequestError(err);
      }
      throw err;
    }
  }
  get connections() {
    return Array.from(this.wagmiConfig.state.connections.values()).map((connection) => ({
      accounts: connection.accounts.map((account) => ({
        address: this.toChecksummedAddress(account)
      })),
      connectorId: connection.connector.id
    }));
  }
  async reconnect(params) {
    const { id } = params;
    const connector = this.getWagmiConnector(id);
    if (!connector) {
      throw new Error("connectionControllerClient:connectExternal - connector is undefined");
    }
    await reconnect(this.wagmiConfig, {
      connectors: [connector]
    });
  }
  async getBalance(params) {
    const address = params.address;
    const caipNetwork = this.getCaipNetworks().find((network) => network.id === params.chainId);
    if (!address) {
      return Promise.resolve({ balance: "0.00", symbol: "ETH" });
    }
    if (caipNetwork && this.wagmiConfig) {
      const caipAddress = `${caipNetwork.caipNetworkId}:${params.address}`;
      const cachedPromise = this.balancePromises[caipAddress];
      if (cachedPromise) {
        return cachedPromise;
      }
      const cachedBalance = StorageUtil.getNativeBalanceCacheForCaipAddress(caipAddress);
      if (cachedBalance) {
        return { balance: cachedBalance.balance, symbol: cachedBalance.symbol };
      }
      this.balancePromises[caipAddress] = new Promise(async (resolve) => {
        try {
          const chainId = Number(params.chainId);
          const balance = await getBalance(this.wagmiConfig, {
            address: params.address,
            chainId,
            token: params.tokens?.[caipNetwork.caipNetworkId]?.address
          });
          StorageUtil.updateNativeBalanceCache({
            caipAddress,
            balance: balance.formatted,
            symbol: balance.symbol,
            timestamp: Date.now()
          });
          resolve({ balance: balance.formatted, symbol: balance.symbol });
        } catch (error) {
          console.warn("Appkit:WagmiAdapter:getBalance - Error getting balance", error);
          resolve({ balance: "0.00", symbol: "ETH" });
        }
      }).finally(() => {
        delete this.balancePromises[caipAddress];
      });
      return this.balancePromises[caipAddress] || { balance: "0.00", symbol: "ETH" };
    }
    return { balance: "", symbol: "" };
  }
  getWalletConnectProvider() {
    return this.getWagmiConnector("walletConnect")?.["provider"];
  }
  async disconnect(params) {
    if (params.id) {
      const connector = this.getWagmiConnector(params.id);
      const connections = getConnections(this.wagmiConfig);
      const connection = connections.find((c) => HelpersUtil.isLowerCaseMatch(c.connector.id, params.id));
      await disconnect(this.wagmiConfig, { connector });
      if (OptionsController.state.enableReconnect === false) {
        this.deleteConnection(params.id);
      }
      if (connection) {
        return {
          connections: [
            {
              accounts: connection.accounts.map((account) => ({
                address: this.toChecksummedAddress(account)
              })),
              connectorId: connection.connector.id
            }
          ]
        };
      }
      return { connections: [] };
    }
    return this.disconnectAll();
  }
  async disconnectAll() {
    const wagmiConnections = getConnections(this.wagmiConfig);
    const connections = await Promise.allSettled(wagmiConnections.map(async (connection) => {
      const connector = this.getWagmiConnector(connection.connector.id);
      if (connector) {
        await disconnect(this.wagmiConfig, { connector });
      }
      return connection;
    }));
    this.wagmiConfig.state.connections.clear();
    return {
      connections: connections.filter((connection) => connection.status === "fulfilled").map(({ value: connection }) => ({
        accounts: connection.accounts.map((account) => ({
          address: this.toChecksummedAddress(account)
        })),
        connectorId: connection.connector.id
      }))
    };
  }
  async switchNetwork(params) {
    const { caipNetwork } = params;
    const wagmiChain = this.wagmiConfig.chains.find((chain) => chain.id.toString() === caipNetwork.id.toString());
    if (!wagmiChain) {
      throw new Error("connectionControllerClient:switchNetwork - wagmiChain is undefined");
    }
    const { name, nativeCurrency, rpcUrls, blockExplorers, id } = wagmiChain;
    const rpcUrl = caipNetwork.rpcUrls?.["chainDefault"]?.http?.[0] ?? rpcUrls.default.http[0] ?? "";
    const blockExplorerUrl = blockExplorers?.default.url ?? caipNetwork.blockExplorers?.default?.url ?? "";
    const currency = nativeCurrency ?? caipNetwork.nativeCurrency;
    const chainName = name ?? caipNetwork.name;
    await switchChain(this.wagmiConfig, {
      chainId: id,
      addEthereumChainParameter: {
        chainName,
        nativeCurrency: currency,
        rpcUrls: [rpcUrl],
        blockExplorerUrls: [blockExplorerUrl]
      }
    });
    await super.switchNetwork(params);
  }
  async getCapabilities(params) {
    if (!this.wagmiConfig) {
      throw new Error("connectionControllerClient:getCapabilities - wagmiConfig is undefined");
    }
    const connections = getConnections(this.wagmiConfig);
    const connection = connections[0];
    const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
    if (!connector) {
      throw new Error("connectionControllerClient:getCapabilities - connector is undefined");
    }
    const provider = await connector.getProvider();
    if (!provider) {
      throw new Error("connectionControllerClient:getCapabilities - provider is undefined");
    }
    return await provider.request({ method: "wallet_getCapabilities", params: [params] });
  }
  async grantPermissions(params) {
    if (!this.wagmiConfig) {
      throw new Error("connectionControllerClient:grantPermissions - wagmiConfig is undefined");
    }
    const connections = getConnections(this.wagmiConfig);
    const connection = connections[0];
    const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
    if (!connector) {
      throw new Error("connectionControllerClient:grantPermissions - connector is undefined");
    }
    const provider = await connector.getProvider();
    if (!provider) {
      throw new Error("connectionControllerClient:grantPermissions - provider is undefined");
    }
    return provider.request({ method: "wallet_grantPermissions", params });
  }
  async revokePermissions(params) {
    if (!this.wagmiConfig) {
      throw new Error("connectionControllerClient:revokePermissions - wagmiConfig is undefined");
    }
    const connections = getConnections(this.wagmiConfig);
    const connection = connections[0];
    const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
    if (!connector) {
      throw new Error("connectionControllerClient:revokePermissions - connector is undefined");
    }
    const provider = await connector.getProvider();
    if (!provider) {
      throw new Error("connectionControllerClient:revokePermissions - provider is undefined");
    }
    return provider.request({ method: "wallet_revokePermissions", params });
  }
  async walletGetAssets(params) {
    if (!this.wagmiConfig) {
      throw new Error("connectionControllerClient:walletGetAssets - wagmiConfig is undefined");
    }
    const connections = getConnections(this.wagmiConfig);
    const connection = connections[0];
    const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
    if (!connector) {
      throw new Error("connectionControllerClient:walletGetAssets - connector is undefined");
    }
    const provider = await connector.getProvider();
    if (!provider) {
      throw new Error("connectionControllerClient:walletGetAssets - provider is undefined");
    }
    return provider.request({ method: "wallet_getAssets", params: [params] });
  }
  setAuthProvider(authProvider) {
    if (!this.namespace) {
      throw new Error("WagmiAdapter:setAuthProvider - namespace is required");
    }
    this.addConnector({
      id: ConstantsUtil.CONNECTOR_ID.AUTH,
      type: "AUTH",
      name: ConstantsUtil.CONNECTOR_NAMES.AUTH,
      provider: authProvider,
      imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil.CONNECTOR_ID.AUTH],
      chain: this.namespace,
      chains: []
    });
  }
  async setUniversalProvider(universalProvider) {
    universalProvider.on("connect", () => {
      const connections = getConnections(this.wagmiConfig);
      const connector = this.getWagmiConnector("walletConnect");
      if (connector && !connections.find((c) => c.connector.id === connector.id)) {
        if (ChainController.state.activeChain === "eip155") {
          return;
        }
        reconnect(this.wagmiConfig, {
          connectors: [connector]
        });
      }
    });
    const walletConnectConnector = walletConnect({
      universalProvider
    });
    this.configureInternalConnector(walletConnectConnector);
    this.addConnector(new WalletConnectConnector({
      provider: universalProvider,
      caipNetworks: this.getCaipNetworks(),
      namespace: "eip155"
    }));
    return Promise.resolve();
  }
  toChecksummedAddress(address) {
    return checksumAddress(address.toLowerCase());
  }
};
export {
  WagmiAdapter,
  authConnector
};
//# sourceMappingURL=@reown_appkit-adapter-wagmi.js.map
