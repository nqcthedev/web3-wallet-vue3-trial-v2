import {
  computed,
  getCurrentScope,
  hasInjectionContext,
  inject,
  isRef,
  nextTick,
  onScopeDispose,
  reactive,
  readonly,
  ref,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  toRefs,
  unref,
  watch,
  watchEffect
} from "./chunk-DUJS4OLK.js";
import {
  InfiniteQueryObserver,
  MutationCache,
  MutationObserver,
  QueriesObserver,
  QueryCache,
  QueryClient,
  QueryObserver,
  isServer,
  onlineManager,
  shouldThrowError
} from "./chunk-SWPER5RL.js";

// node_modules/@tanstack/vue-query/node_modules/vue-demi/lib/index.mjs
var isVue2 = false;

// node_modules/@tanstack/vue-query/build/modern/utils.js
var VUE_QUERY_CLIENT = "VUE_QUERY_CLIENT";
function getClientKey(key) {
  const suffix = key ? `:${key}` : "";
  return `${VUE_QUERY_CLIENT}${suffix}`;
}
function updateState(state, update) {
  Object.keys(state).forEach((key) => {
    state[key] = update[key];
  });
}
function _cloneDeep(value, customize, currentKey = "", currentLevel = 0) {
  if (customize) {
    const result = customize(value, currentKey, currentLevel);
    if (result === void 0 && isRef(value)) {
      return result;
    }
    if (result !== void 0) {
      return result;
    }
  }
  if (Array.isArray(value)) {
    return value.map(
      (val, index) => _cloneDeep(val, customize, String(index), currentLevel + 1)
    );
  }
  if (typeof value === "object" && isPlainObject(value)) {
    const entries = Object.entries(value).map(([key, val]) => [
      key,
      _cloneDeep(val, customize, key, currentLevel + 1)
    ]);
    return Object.fromEntries(entries);
  }
  return value;
}
function cloneDeep(value, customize) {
  return _cloneDeep(value, customize);
}
function cloneDeepUnref(obj, unrefGetters = false) {
  return cloneDeep(obj, (val, key, level) => {
    if (level === 1 && key === "queryKey") {
      return cloneDeepUnref(val, true);
    }
    if (unrefGetters && isFunction(val)) {
      return cloneDeepUnref(val(), unrefGetters);
    }
    if (isRef(val)) {
      return cloneDeepUnref(unref(val), unrefGetters);
    }
    return void 0;
  });
}
function isPlainObject(value) {
  if (Object.prototype.toString.call(value) !== "[object Object]") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.prototype;
}
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/@tanstack/vue-query/build/modern/useQueryClient.js
function useQueryClient(id = "") {
  if (!hasInjectionContext()) {
    throw new Error(
      "vue-query hooks can only be used inside setup() function or functions that support injection context."
    );
  }
  const key = getClientKey(id);
  const queryClient = inject(key);
  if (!queryClient) {
    throw new Error(
      "No 'queryClient' found in Vue context, use 'VueQueryPlugin' to properly initialize the library."
    );
  }
  return queryClient;
}

// node_modules/@tanstack/vue-query/build/modern/queryCache.js
var QueryCache2 = class extends QueryCache {
  find(filters) {
    return super.find(cloneDeepUnref(filters));
  }
  findAll(filters = {}) {
    return super.findAll(cloneDeepUnref(filters));
  }
};

// node_modules/@tanstack/vue-query/build/modern/mutationCache.js
var MutationCache2 = class extends MutationCache {
  find(filters) {
    return super.find(cloneDeepUnref(filters));
  }
  findAll(filters = {}) {
    return super.findAll(cloneDeepUnref(filters));
  }
};

// node_modules/@tanstack/vue-query/build/modern/queryClient.js
var QueryClient2 = class extends QueryClient {
  constructor(config = {}) {
    const vueQueryConfig = {
      defaultOptions: config.defaultOptions,
      queryCache: config.queryCache || new QueryCache2(),
      mutationCache: config.mutationCache || new MutationCache2()
    };
    super(vueQueryConfig);
    this.isRestoring = ref(false);
  }
  isFetching(filters = {}) {
    return super.isFetching(cloneDeepUnref(filters));
  }
  isMutating(filters = {}) {
    return super.isMutating(cloneDeepUnref(filters));
  }
  getQueryData(queryKey) {
    return super.getQueryData(cloneDeepUnref(queryKey));
  }
  ensureQueryData(options) {
    return super.ensureQueryData(cloneDeepUnref(options));
  }
  getQueriesData(filters) {
    return super.getQueriesData(cloneDeepUnref(filters));
  }
  setQueryData(queryKey, updater, options = {}) {
    return super.setQueryData(
      cloneDeepUnref(queryKey),
      updater,
      cloneDeepUnref(options)
    );
  }
  setQueriesData(filters, updater, options = {}) {
    return super.setQueriesData(
      cloneDeepUnref(filters),
      updater,
      cloneDeepUnref(options)
    );
  }
  getQueryState(queryKey) {
    return super.getQueryState(cloneDeepUnref(queryKey));
  }
  removeQueries(filters = {}) {
    return super.removeQueries(cloneDeepUnref(filters));
  }
  resetQueries(filters = {}, options = {}) {
    return super.resetQueries(cloneDeepUnref(filters), cloneDeepUnref(options));
  }
  cancelQueries(filters = {}, options = {}) {
    return super.cancelQueries(cloneDeepUnref(filters), cloneDeepUnref(options));
  }
  invalidateQueries(filters = {}, options = {}) {
    const filtersCloned = cloneDeepUnref(filters);
    const optionsCloned = cloneDeepUnref(options);
    super.invalidateQueries(
      { ...filtersCloned, refetchType: "none" },
      optionsCloned
    );
    if (filtersCloned.refetchType === "none") {
      return Promise.resolve();
    }
    const refetchFilters = {
      ...filtersCloned,
      type: filtersCloned.refetchType ?? filtersCloned.type ?? "active"
    };
    return nextTick().then(() => {
      return super.refetchQueries(refetchFilters, optionsCloned);
    });
  }
  refetchQueries(filters = {}, options = {}) {
    return super.refetchQueries(
      cloneDeepUnref(filters),
      cloneDeepUnref(options)
    );
  }
  fetchQuery(options) {
    return super.fetchQuery(cloneDeepUnref(options));
  }
  prefetchQuery(options) {
    return super.prefetchQuery(cloneDeepUnref(options));
  }
  fetchInfiniteQuery(options) {
    return super.fetchInfiniteQuery(cloneDeepUnref(options));
  }
  prefetchInfiniteQuery(options) {
    return super.prefetchInfiniteQuery(cloneDeepUnref(options));
  }
  setDefaultOptions(options) {
    super.setDefaultOptions(cloneDeepUnref(options));
  }
  setQueryDefaults(queryKey, options) {
    super.setQueryDefaults(cloneDeepUnref(queryKey), cloneDeepUnref(options));
  }
  getQueryDefaults(queryKey) {
    return super.getQueryDefaults(cloneDeepUnref(queryKey));
  }
  setMutationDefaults(mutationKey, options) {
    super.setMutationDefaults(
      cloneDeepUnref(mutationKey),
      cloneDeepUnref(options)
    );
  }
  getMutationDefaults(mutationKey) {
    return super.getMutationDefaults(cloneDeepUnref(mutationKey));
  }
};

// node_modules/@tanstack/vue-query/node_modules/@vue/devtools-api/lib/esm/env.js
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {};
}
var isProxyAvailable = typeof Proxy === "function";

// node_modules/@tanstack/vue-query/node_modules/@vue/devtools-api/lib/esm/const.js
var HOOK_SETUP = "devtools-plugin:setup";
var HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";

// node_modules/@tanstack/vue-query/node_modules/@vue/devtools-api/lib/esm/time.js
var supported;
var perf;
function isPerformanceSupported() {
  var _a;
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else if (typeof globalThis !== "undefined" && ((_a = globalThis.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
    supported = true;
    perf = globalThis.perf_hooks.performance;
  } else {
    supported = false;
  }
  return supported;
}
function now() {
  return isPerformanceSupported() ? perf.now() : Date.now();
}

// node_modules/@tanstack/vue-query/node_modules/@vue/devtools-api/lib/esm/proxy.js
var ApiProxy = class {
  constructor(plugin, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin;
    this.hook = hook;
    const defaultSettings = {};
    if (plugin.settings) {
      for (const id in plugin.settings) {
        const item = plugin.settings[id];
        defaultSettings[id] = item.defaultValue;
      }
    }
    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
    let currentSettings = Object.assign({}, defaultSettings);
    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data = JSON.parse(raw);
      Object.assign(currentSettings, data);
    } catch (e) {
    }
    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },
      setSettings(value) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
        } catch (e) {
        }
        currentSettings = value;
      },
      now() {
        return now();
      }
    };
    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId2, value) => {
        if (pluginId2 === this.plugin.id) {
          this.fallbacks.setSettings(value);
        }
      });
    }
    this.proxiedOn = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target.on[prop];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop,
              args
            });
          };
        }
      }
    });
    this.proxiedTarget = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target[prop];
        } else if (prop === "on") {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop,
              args,
              resolve: () => {
              }
            });
            return this.fallbacks[prop](...args);
          };
        } else {
          return (...args) => {
            return new Promise((resolve) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve
              });
            });
          };
        }
      }
    });
  }
  async setRealTarget(target) {
    this.target = target;
    for (const item of this.onQueue) {
      this.target.on[item.method](...item.args);
    }
    for (const item of this.targetQueue) {
      item.resolve(await this.target[item.method](...item.args));
    }
  }
};

// node_modules/@tanstack/vue-query/node_modules/@vue/devtools-api/lib/esm/index.js
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy
    });
    if (proxy) {
      setupFn(proxy.proxiedTarget);
    }
  }
}

// node_modules/@tanstack/match-sorter-utils/build/lib/index.mjs
var characterMap = {
  À: "A",
  Á: "A",
  Â: "A",
  Ã: "A",
  Ä: "A",
  Å: "A",
  Ấ: "A",
  Ắ: "A",
  Ẳ: "A",
  Ẵ: "A",
  Ặ: "A",
  Æ: "AE",
  Ầ: "A",
  Ằ: "A",
  Ȃ: "A",
  Ç: "C",
  Ḉ: "C",
  È: "E",
  É: "E",
  Ê: "E",
  Ë: "E",
  Ế: "E",
  Ḗ: "E",
  Ề: "E",
  Ḕ: "E",
  Ḝ: "E",
  Ȇ: "E",
  Ì: "I",
  Í: "I",
  Î: "I",
  Ï: "I",
  Ḯ: "I",
  Ȋ: "I",
  Ð: "D",
  Ñ: "N",
  Ò: "O",
  Ó: "O",
  Ô: "O",
  Õ: "O",
  Ö: "O",
  Ø: "O",
  Ố: "O",
  Ṍ: "O",
  Ṓ: "O",
  Ȏ: "O",
  Ù: "U",
  Ú: "U",
  Û: "U",
  Ü: "U",
  Ý: "Y",
  à: "a",
  á: "a",
  â: "a",
  ã: "a",
  ä: "a",
  å: "a",
  ấ: "a",
  ắ: "a",
  ẳ: "a",
  ẵ: "a",
  ặ: "a",
  æ: "ae",
  ầ: "a",
  ằ: "a",
  ȃ: "a",
  ç: "c",
  ḉ: "c",
  è: "e",
  é: "e",
  ê: "e",
  ë: "e",
  ế: "e",
  ḗ: "e",
  ề: "e",
  ḕ: "e",
  ḝ: "e",
  ȇ: "e",
  ì: "i",
  í: "i",
  î: "i",
  ï: "i",
  ḯ: "i",
  ȋ: "i",
  ð: "d",
  ñ: "n",
  ò: "o",
  ó: "o",
  ô: "o",
  õ: "o",
  ö: "o",
  ø: "o",
  ố: "o",
  ṍ: "o",
  ṓ: "o",
  ȏ: "o",
  ù: "u",
  ú: "u",
  û: "u",
  ü: "u",
  ý: "y",
  ÿ: "y",
  Ā: "A",
  ā: "a",
  Ă: "A",
  ă: "a",
  Ą: "A",
  ą: "a",
  Ć: "C",
  ć: "c",
  Ĉ: "C",
  ĉ: "c",
  Ċ: "C",
  ċ: "c",
  Č: "C",
  č: "c",
  C̆: "C",
  c̆: "c",
  Ď: "D",
  ď: "d",
  Đ: "D",
  đ: "d",
  Ē: "E",
  ē: "e",
  Ĕ: "E",
  ĕ: "e",
  Ė: "E",
  ė: "e",
  Ę: "E",
  ę: "e",
  Ě: "E",
  ě: "e",
  Ĝ: "G",
  Ǵ: "G",
  ĝ: "g",
  ǵ: "g",
  Ğ: "G",
  ğ: "g",
  Ġ: "G",
  ġ: "g",
  Ģ: "G",
  ģ: "g",
  Ĥ: "H",
  ĥ: "h",
  Ħ: "H",
  ħ: "h",
  Ḫ: "H",
  ḫ: "h",
  Ĩ: "I",
  ĩ: "i",
  Ī: "I",
  ī: "i",
  Ĭ: "I",
  ĭ: "i",
  Į: "I",
  į: "i",
  İ: "I",
  ı: "i",
  Ĳ: "IJ",
  ĳ: "ij",
  Ĵ: "J",
  ĵ: "j",
  Ķ: "K",
  ķ: "k",
  Ḱ: "K",
  ḱ: "k",
  K̆: "K",
  k̆: "k",
  Ĺ: "L",
  ĺ: "l",
  Ļ: "L",
  ļ: "l",
  Ľ: "L",
  ľ: "l",
  Ŀ: "L",
  ŀ: "l",
  Ł: "l",
  ł: "l",
  Ḿ: "M",
  ḿ: "m",
  M̆: "M",
  m̆: "m",
  Ń: "N",
  ń: "n",
  Ņ: "N",
  ņ: "n",
  Ň: "N",
  ň: "n",
  ŉ: "n",
  N̆: "N",
  n̆: "n",
  Ō: "O",
  ō: "o",
  Ŏ: "O",
  ŏ: "o",
  Ő: "O",
  ő: "o",
  Œ: "OE",
  œ: "oe",
  P̆: "P",
  p̆: "p",
  Ŕ: "R",
  ŕ: "r",
  Ŗ: "R",
  ŗ: "r",
  Ř: "R",
  ř: "r",
  R̆: "R",
  r̆: "r",
  Ȓ: "R",
  ȓ: "r",
  Ś: "S",
  ś: "s",
  Ŝ: "S",
  ŝ: "s",
  Ş: "S",
  Ș: "S",
  ș: "s",
  ş: "s",
  Š: "S",
  š: "s",
  Ţ: "T",
  ţ: "t",
  ț: "t",
  Ț: "T",
  Ť: "T",
  ť: "t",
  Ŧ: "T",
  ŧ: "t",
  T̆: "T",
  t̆: "t",
  Ũ: "U",
  ũ: "u",
  Ū: "U",
  ū: "u",
  Ŭ: "U",
  ŭ: "u",
  Ů: "U",
  ů: "u",
  Ű: "U",
  ű: "u",
  Ų: "U",
  ų: "u",
  Ȗ: "U",
  ȗ: "u",
  V̆: "V",
  v̆: "v",
  Ŵ: "W",
  ŵ: "w",
  Ẃ: "W",
  ẃ: "w",
  X̆: "X",
  x̆: "x",
  Ŷ: "Y",
  ŷ: "y",
  Ÿ: "Y",
  Y̆: "Y",
  y̆: "y",
  Ź: "Z",
  ź: "z",
  Ż: "Z",
  ż: "z",
  Ž: "Z",
  ž: "z",
  ſ: "s",
  ƒ: "f",
  Ơ: "O",
  ơ: "o",
  Ư: "U",
  ư: "u",
  Ǎ: "A",
  ǎ: "a",
  Ǐ: "I",
  ǐ: "i",
  Ǒ: "O",
  ǒ: "o",
  Ǔ: "U",
  ǔ: "u",
  Ǖ: "U",
  ǖ: "u",
  Ǘ: "U",
  ǘ: "u",
  Ǚ: "U",
  ǚ: "u",
  Ǜ: "U",
  ǜ: "u",
  Ứ: "U",
  ứ: "u",
  Ṹ: "U",
  ṹ: "u",
  Ǻ: "A",
  ǻ: "a",
  Ǽ: "AE",
  ǽ: "ae",
  Ǿ: "O",
  ǿ: "o",
  Þ: "TH",
  þ: "th",
  Ṕ: "P",
  ṕ: "p",
  Ṥ: "S",
  ṥ: "s",
  X́: "X",
  x́: "x",
  Ѓ: "Г",
  ѓ: "г",
  Ќ: "К",
  ќ: "к",
  A̋: "A",
  a̋: "a",
  E̋: "E",
  e̋: "e",
  I̋: "I",
  i̋: "i",
  Ǹ: "N",
  ǹ: "n",
  Ồ: "O",
  ồ: "o",
  Ṑ: "O",
  ṑ: "o",
  Ừ: "U",
  ừ: "u",
  Ẁ: "W",
  ẁ: "w",
  Ỳ: "Y",
  ỳ: "y",
  Ȁ: "A",
  ȁ: "a",
  Ȅ: "E",
  ȅ: "e",
  Ȉ: "I",
  ȉ: "i",
  Ȍ: "O",
  ȍ: "o",
  Ȑ: "R",
  ȑ: "r",
  Ȕ: "U",
  ȕ: "u",
  B̌: "B",
  b̌: "b",
  Č̣: "C",
  č̣: "c",
  Ê̌: "E",
  ê̌: "e",
  F̌: "F",
  f̌: "f",
  Ǧ: "G",
  ǧ: "g",
  Ȟ: "H",
  ȟ: "h",
  J̌: "J",
  ǰ: "j",
  Ǩ: "K",
  ǩ: "k",
  M̌: "M",
  m̌: "m",
  P̌: "P",
  p̌: "p",
  Q̌: "Q",
  q̌: "q",
  Ř̩: "R",
  ř̩: "r",
  Ṧ: "S",
  ṧ: "s",
  V̌: "V",
  v̌: "v",
  W̌: "W",
  w̌: "w",
  X̌: "X",
  x̌: "x",
  Y̌: "Y",
  y̌: "y",
  A̧: "A",
  a̧: "a",
  B̧: "B",
  b̧: "b",
  Ḑ: "D",
  ḑ: "d",
  Ȩ: "E",
  ȩ: "e",
  Ɛ̧: "E",
  ɛ̧: "e",
  Ḩ: "H",
  ḩ: "h",
  I̧: "I",
  i̧: "i",
  Ɨ̧: "I",
  ɨ̧: "i",
  M̧: "M",
  m̧: "m",
  O̧: "O",
  o̧: "o",
  Q̧: "Q",
  q̧: "q",
  U̧: "U",
  u̧: "u",
  X̧: "X",
  x̧: "x",
  Z̧: "Z",
  z̧: "z"
};
var chars = Object.keys(characterMap).join("|");
var allAccents = new RegExp(chars, "g");
function removeAccents(str) {
  return str.replace(allAccents, (match) => {
    return characterMap[match];
  });
}
var rankings = {
  CASE_SENSITIVE_EQUAL: 7,
  EQUAL: 6,
  STARTS_WITH: 5,
  WORD_STARTS_WITH: 4,
  CONTAINS: 3,
  ACRONYM: 2,
  MATCHES: 1,
  NO_MATCH: 0
};
function rankItem(item, value, options) {
  var _options$threshold;
  options = options || {};
  options.threshold = (_options$threshold = options.threshold) != null ? _options$threshold : rankings.MATCHES;
  if (!options.accessors) {
    const rank = getMatchRanking(item, value, options);
    return {
      // ends up being duplicate of 'item' in matches but consistent
      rankedValue: item,
      rank,
      accessorIndex: -1,
      accessorThreshold: options.threshold,
      passed: rank >= options.threshold
    };
  }
  const valuesToRank = getAllValuesToRank(item, options.accessors);
  const rankingInfo = {
    rankedValue: item,
    rank: rankings.NO_MATCH,
    accessorIndex: -1,
    accessorThreshold: options.threshold,
    passed: false
  };
  for (let i = 0; i < valuesToRank.length; i++) {
    const rankValue = valuesToRank[i];
    let newRank = getMatchRanking(rankValue.itemValue, value, options);
    const {
      minRanking,
      maxRanking,
      threshold = options.threshold
    } = rankValue.attributes;
    if (newRank < minRanking && newRank >= rankings.MATCHES) {
      newRank = minRanking;
    } else if (newRank > maxRanking) {
      newRank = maxRanking;
    }
    newRank = Math.min(newRank, maxRanking);
    if (newRank >= threshold && newRank > rankingInfo.rank) {
      rankingInfo.rank = newRank;
      rankingInfo.passed = true;
      rankingInfo.accessorIndex = i;
      rankingInfo.accessorThreshold = threshold;
      rankingInfo.rankedValue = rankValue.itemValue;
    }
  }
  return rankingInfo;
}
function getMatchRanking(testString, stringToRank, options) {
  testString = prepareValueForComparison(testString, options);
  stringToRank = prepareValueForComparison(stringToRank, options);
  if (stringToRank.length > testString.length) {
    return rankings.NO_MATCH;
  }
  if (testString === stringToRank) {
    return rankings.CASE_SENSITIVE_EQUAL;
  }
  testString = testString.toLowerCase();
  stringToRank = stringToRank.toLowerCase();
  if (testString === stringToRank) {
    return rankings.EQUAL;
  }
  if (testString.startsWith(stringToRank)) {
    return rankings.STARTS_WITH;
  }
  if (testString.includes(` ${stringToRank}`)) {
    return rankings.WORD_STARTS_WITH;
  }
  if (testString.includes(stringToRank)) {
    return rankings.CONTAINS;
  } else if (stringToRank.length === 1) {
    return rankings.NO_MATCH;
  }
  if (getAcronym(testString).includes(stringToRank)) {
    return rankings.ACRONYM;
  }
  return getClosenessRanking(testString, stringToRank);
}
function getAcronym(string) {
  let acronym = "";
  const wordsInString = string.split(" ");
  wordsInString.forEach((wordInString) => {
    const splitByHyphenWords = wordInString.split("-");
    splitByHyphenWords.forEach((splitByHyphenWord) => {
      acronym += splitByHyphenWord.substr(0, 1);
    });
  });
  return acronym;
}
function getClosenessRanking(testString, stringToRank) {
  let matchingInOrderCharCount = 0;
  let charNumber = 0;
  function findMatchingCharacter(matchChar, string, index) {
    for (let j = index, J = string.length; j < J; j++) {
      const stringChar = string[j];
      if (stringChar === matchChar) {
        matchingInOrderCharCount += 1;
        return j + 1;
      }
    }
    return -1;
  }
  function getRanking(spread2) {
    const spreadPercentage = 1 / spread2;
    const inOrderPercentage = matchingInOrderCharCount / stringToRank.length;
    const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage;
    return ranking;
  }
  const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);
  if (firstIndex < 0) {
    return rankings.NO_MATCH;
  }
  charNumber = firstIndex;
  for (let i = 1, I = stringToRank.length; i < I; i++) {
    const matchChar = stringToRank[i];
    charNumber = findMatchingCharacter(matchChar, testString, charNumber);
    const found = charNumber > -1;
    if (!found) {
      return rankings.NO_MATCH;
    }
  }
  const spread = charNumber - firstIndex;
  return getRanking(spread);
}
function prepareValueForComparison(value, _ref) {
  let {
    keepDiacritics
  } = _ref;
  value = `${value}`;
  if (!keepDiacritics) {
    value = removeAccents(value);
  }
  return value;
}
function getItemValues(item, accessor) {
  let accessorFn = accessor;
  if (typeof accessor === "object") {
    accessorFn = accessor.accessor;
  }
  const value = accessorFn(item);
  if (value == null) {
    return [];
  }
  if (Array.isArray(value)) {
    return value;
  }
  return [String(value)];
}
function getAllValuesToRank(item, accessors) {
  const allValues = [];
  for (let j = 0, J = accessors.length; j < J; j++) {
    const accessor = accessors[j];
    const attributes = getAccessorAttributes(accessor);
    const itemValues = getItemValues(item, accessor);
    for (let i = 0, I = itemValues.length; i < I; i++) {
      allValues.push({
        itemValue: itemValues[i],
        attributes
      });
    }
  }
  return allValues;
}
var defaultKeyAttributes = {
  maxRanking: Infinity,
  minRanking: -Infinity
};
function getAccessorAttributes(accessor) {
  if (typeof accessor === "function") {
    return defaultKeyAttributes;
  }
  return {
    ...defaultKeyAttributes,
    ...accessor
  };
}

// node_modules/@tanstack/vue-query/build/modern/devtools/utils.js
function getQueryState(query) {
  if (query.state.fetchStatus === "fetching") {
    return 0;
  }
  if (query.state.fetchStatus === "paused") {
    return 4;
  }
  if (!query.getObserversCount()) {
    return 3;
  }
  if (query.isStale()) {
    return 2;
  }
  return 1;
}
function getQueryStateLabel(query) {
  const queryState = getQueryState(query);
  if (queryState === 0) {
    return "fetching";
  }
  if (queryState === 4) {
    return "paused";
  }
  if (queryState === 2) {
    return "stale";
  }
  if (queryState === 3) {
    return "inactive";
  }
  return "fresh";
}
function getQueryStatusFg(query) {
  const queryState = getQueryState(query);
  if (queryState === 2) {
    return 0;
  }
  return 16777215;
}
function getQueryStatusBg(query) {
  const queryState = getQueryState(query);
  if (queryState === 0) {
    return 27647;
  }
  if (queryState === 4) {
    return 9193963;
  }
  if (queryState === 2) {
    return 16757248;
  }
  if (queryState === 3) {
    return 4148832;
  }
  return 33575;
}
var queryHashSort = (a, b) => a.queryHash.localeCompare(b.queryHash);
var dateSort = (a, b) => a.state.dataUpdatedAt < b.state.dataUpdatedAt ? 1 : -1;
var statusAndDateSort = (a, b) => {
  if (getQueryState(a) === getQueryState(b)) {
    return dateSort(a, b);
  }
  return getQueryState(a) > getQueryState(b) ? 1 : -1;
};
var sortFns = {
  "Status > Last Updated": statusAndDateSort,
  "Query Hash": queryHashSort,
  "Last Updated": dateSort
};

// node_modules/@tanstack/vue-query/build/modern/devtools/devtools.js
var pluginId = "vue-query";
var pluginName = "Vue Query";
function setupDevtools(app, queryClient) {
  setupDevtoolsPlugin(
    {
      id: pluginId,
      label: pluginName,
      packageName: "vue-query",
      homepage: "https://tanstack.com/query/latest",
      logo: "https://raw.githubusercontent.com/TanStack/query/main/packages/vue-query/media/vue-query.svg",
      app,
      settings: {
        baseSort: {
          type: "choice",
          component: "button-group",
          label: "Sort Cache Entries",
          options: [
            {
              label: "ASC",
              value: 1
            },
            {
              label: "DESC",
              value: -1
            }
          ],
          defaultValue: 1
        },
        sortFn: {
          type: "choice",
          label: "Sort Function",
          options: Object.keys(sortFns).map((key) => ({
            label: key,
            value: key
          })),
          defaultValue: Object.keys(sortFns)[0]
        },
        onlineMode: {
          type: "choice",
          component: "button-group",
          label: "Online mode",
          options: [
            {
              label: "Online",
              value: 1
            },
            {
              label: "Offline",
              value: 0
            }
          ],
          defaultValue: 1
        }
      }
    },
    (api) => {
      const initialSettings = api.getSettings();
      onlineManager.setOnline(Boolean(initialSettings.onlineMode.valueOf()));
      const queryCache = queryClient.getQueryCache();
      api.addInspector({
        id: pluginId,
        label: pluginName,
        icon: "api",
        nodeActions: [
          {
            icon: "file_download",
            tooltip: "Refetch",
            action: (queryHash) => {
              queryCache.get(queryHash)?.fetch();
            }
          },
          {
            icon: "alarm",
            tooltip: "Invalidate",
            action: (queryHash) => {
              const query = queryCache.get(queryHash);
              queryClient.invalidateQueries(query);
            }
          },
          {
            icon: "settings_backup_restore",
            tooltip: "Reset",
            action: (queryHash) => {
              queryCache.get(queryHash)?.reset();
            }
          },
          {
            icon: "delete",
            tooltip: "Remove",
            action: (queryHash) => {
              const query = queryCache.get(queryHash);
              queryCache.remove(query);
            }
          },
          {
            icon: "hourglass_empty",
            tooltip: "Force loading",
            action: (queryHash) => {
              const query = queryCache.get(queryHash);
              query.setState({
                data: void 0,
                status: "pending"
              });
            }
          },
          {
            icon: "error_outline",
            tooltip: "Force error",
            action: (queryHash) => {
              const query = queryCache.get(queryHash);
              query.setState({
                data: void 0,
                status: "error",
                error: new Error("Unknown error from devtools")
              });
            }
          }
        ]
      });
      api.addTimelineLayer({
        id: pluginId,
        label: pluginName,
        color: 16767308
      });
      queryCache.subscribe((event) => {
        api.sendInspectorTree(pluginId);
        api.sendInspectorState(pluginId);
        const queryEvents = [
          "added",
          "removed",
          "updated"
        ];
        if (queryEvents.includes(event.type)) {
          api.addTimelineEvent({
            layerId: pluginId,
            event: {
              title: event.type,
              subtitle: event.query.queryHash,
              time: api.now(),
              data: {
                queryHash: event.query.queryHash,
                ...event
              }
            }
          });
        }
      });
      api.on.setPluginSettings((payload) => {
        if (payload.key === "onlineMode") {
          onlineManager.setOnline(Boolean(payload.newValue));
        }
      });
      api.on.getInspectorTree((payload) => {
        if (payload.inspectorId === pluginId) {
          const queries = queryCache.getAll();
          const settings = api.getSettings();
          const filtered = payload.filter ? queries.filter(
            (item) => rankItem(item.queryHash, payload.filter).passed
          ) : [...queries];
          const sorted = filtered.sort(
            (a, b) => sortFns[settings.sortFn](a, b) * settings.baseSort
          );
          const nodes = sorted.map((query) => {
            const stateLabel = getQueryStateLabel(query);
            return {
              id: query.queryHash,
              label: query.queryHash,
              tags: [
                {
                  label: `${stateLabel} [${query.getObserversCount()}]`,
                  textColor: getQueryStatusFg(query),
                  backgroundColor: getQueryStatusBg(query)
                }
              ]
            };
          });
          payload.rootNodes = nodes;
        }
      });
      api.on.getInspectorState((payload) => {
        if (payload.inspectorId === pluginId) {
          const query = queryCache.get(payload.nodeId);
          if (!query) {
            return;
          }
          payload.state = {
            " Query Details": [
              {
                key: "Query key",
                value: query.queryHash
              },
              {
                key: "Query status",
                value: getQueryStateLabel(query)
              },
              {
                key: "Observers",
                value: query.getObserversCount()
              },
              {
                key: "Last Updated",
                value: new Date(query.state.dataUpdatedAt).toLocaleTimeString()
              }
            ],
            "Data Explorer": [
              {
                key: "Data",
                value: query.state.data
              }
            ],
            "Query Explorer": [
              {
                key: "Query",
                value: query
              }
            ]
          };
        }
      });
    }
  );
}

// node_modules/@tanstack/vue-query/build/modern/vueQueryPlugin.js
var VueQueryPlugin = {
  install: (app, options = {}) => {
    const clientKey = getClientKey(options.queryClientKey);
    let client;
    if ("queryClient" in options && options.queryClient) {
      client = options.queryClient;
    } else {
      const clientConfig = "queryClientConfig" in options ? options.queryClientConfig : void 0;
      client = new QueryClient2(clientConfig);
    }
    if (!isServer) {
      client.mount();
    }
    let persisterUnmount = () => {
    };
    if (options.clientPersister) {
      if (client.isRestoring) {
        client.isRestoring.value = true;
      }
      const [unmount, promise] = options.clientPersister(client);
      persisterUnmount = unmount;
      promise.then(() => {
        if (client.isRestoring) {
          client.isRestoring.value = false;
        }
        options.clientPersisterOnSuccess?.(client);
      });
    }
    const cleanup = () => {
      client.unmount();
      persisterUnmount();
    };
    if (app.onUnmount) {
      app.onUnmount(cleanup);
    } else {
      const originalUnmount = app.unmount;
      app.unmount = function vueQueryUnmount() {
        cleanup();
        originalUnmount();
      };
    }
    if (isVue2) {
      app.mixin({
        beforeCreate() {
          if (!this._provided) {
            const provideCache = {};
            Object.defineProperty(this, "_provided", {
              get: () => provideCache,
              set: (v) => Object.assign(provideCache, v)
            });
          }
          this._provided[clientKey] = client;
          if (true) {
            if (this === this.$root && options.enableDevtoolsV6Plugin) {
              setupDevtools(this, client);
            }
          }
        }
      });
    } else {
      app.provide(clientKey, client);
      if (true) {
        if (options.enableDevtoolsV6Plugin) {
          setupDevtools(app, client);
        }
      }
    }
  }
};

// node_modules/@tanstack/vue-query/build/modern/queryOptions.js
function queryOptions(options) {
  return options;
}

// node_modules/@tanstack/vue-query/build/modern/infiniteQueryOptions.js
function infiniteQueryOptions(options) {
  return options;
}

// node_modules/@tanstack/vue-query/build/modern/useBaseQuery.js
function useBaseQuery(Observer, options, queryClient) {
  if (true) {
    if (!getCurrentScope()) {
      console.warn(
        'vue-query composable like "useQuery()" should only be used inside a "setup()" function or a running effect scope. They might otherwise lead to memory leaks.'
      );
    }
  }
  const client = queryClient || useQueryClient();
  const defaultedOptions = computed(() => {
    let resolvedOptions = options;
    if (typeof resolvedOptions === "function") {
      resolvedOptions = resolvedOptions();
    }
    const clonedOptions = cloneDeepUnref(resolvedOptions);
    if (typeof clonedOptions.enabled === "function") {
      clonedOptions.enabled = clonedOptions.enabled();
    }
    const defaulted = client.defaultQueryOptions(clonedOptions);
    defaulted._optimisticResults = client.isRestoring?.value ? "isRestoring" : "optimistic";
    return defaulted;
  });
  const observer = new Observer(client, defaultedOptions.value);
  const state = defaultedOptions.value.shallow ? shallowReactive(observer.getCurrentResult()) : reactive(observer.getCurrentResult());
  let unsubscribe = () => {
  };
  if (client.isRestoring) {
    watch(
      client.isRestoring,
      (isRestoring) => {
        if (!isRestoring) {
          unsubscribe();
          unsubscribe = observer.subscribe((result) => {
            updateState(state, result);
          });
        }
      },
      { immediate: true }
    );
  }
  const updater = () => {
    observer.setOptions(defaultedOptions.value);
    updateState(state, observer.getCurrentResult());
  };
  watch(defaultedOptions, updater);
  onScopeDispose(() => {
    unsubscribe();
  });
  const refetch = (...args) => {
    updater();
    return state.refetch(...args);
  };
  const suspense = () => {
    return new Promise(
      (resolve, reject) => {
        let stopWatch = () => {
        };
        const run = () => {
          if (defaultedOptions.value.enabled !== false) {
            observer.setOptions(defaultedOptions.value);
            const optimisticResult = observer.getOptimisticResult(
              defaultedOptions.value
            );
            if (optimisticResult.isStale) {
              stopWatch();
              observer.fetchOptimistic(defaultedOptions.value).then(resolve, (error) => {
                if (shouldThrowError(defaultedOptions.value.throwOnError, [
                  error,
                  observer.getCurrentQuery()
                ])) {
                  reject(error);
                } else {
                  resolve(observer.getCurrentResult());
                }
              });
            } else {
              stopWatch();
              resolve(optimisticResult);
            }
          }
        };
        run();
        stopWatch = watch(defaultedOptions, run);
      }
    );
  };
  watch(
    () => state.error,
    (error) => {
      if (state.isError && !state.isFetching && shouldThrowError(defaultedOptions.value.throwOnError, [
        error,
        observer.getCurrentQuery()
      ])) {
        throw error;
      }
    }
  );
  const readonlyState = defaultedOptions.value.shallow ? shallowReadonly(state) : readonly(state);
  const object = toRefs(readonlyState);
  for (const key in state) {
    if (typeof state[key] === "function") {
      object[key] = state[key];
    }
  }
  object.suspense = suspense;
  object.refetch = refetch;
  return object;
}

// node_modules/@tanstack/vue-query/build/modern/useQuery.js
function useQuery(options, queryClient) {
  return useBaseQuery(QueryObserver, options, queryClient);
}

// node_modules/@tanstack/vue-query/build/modern/useQueries.js
function useQueries({
  queries,
  ...options
}, queryClient) {
  if (true) {
    if (!getCurrentScope()) {
      console.warn(
        'vue-query composable like "useQuery()" should only be used inside a "setup()" function or a running effect scope. They might otherwise lead to memory leaks.'
      );
    }
  }
  const client = queryClient || useQueryClient();
  const defaultedQueries = computed(() => {
    const resolvedQueries = typeof queries === "function" ? queries() : queries;
    const queriesRaw = unref(resolvedQueries);
    return queriesRaw.map((queryOptions2) => {
      const clonedOptions = cloneDeepUnref(queryOptions2);
      if (typeof clonedOptions.enabled === "function") {
        clonedOptions.enabled = queryOptions2.enabled();
      }
      const defaulted = client.defaultQueryOptions(clonedOptions);
      defaulted._optimisticResults = client.isRestoring?.value ? "isRestoring" : "optimistic";
      return defaulted;
    });
  });
  const observer = new QueriesObserver(
    client,
    defaultedQueries.value,
    options
  );
  const getOptimisticResult = () => {
    const [results, getCombinedResult] = observer.getOptimisticResult(
      defaultedQueries.value,
      options.combine
    );
    return getCombinedResult(
      results.map((result, index) => {
        return {
          ...result,
          refetch: async (...args) => {
            const [{ [index]: query }] = observer.getOptimisticResult(
              defaultedQueries.value,
              options.combine
            );
            return query.refetch(...args);
          }
        };
      })
    );
  };
  const state = shallowRef(getOptimisticResult());
  let unsubscribe = () => {
  };
  if (client.isRestoring) {
    watch(
      client.isRestoring,
      (isRestoring) => {
        if (!isRestoring) {
          unsubscribe();
          unsubscribe = observer.subscribe(() => {
            state.value = getOptimisticResult();
          });
          state.value = getOptimisticResult();
        }
      },
      { immediate: true }
    );
  }
  watch(defaultedQueries, (queriesValue) => {
    observer.setQueries(
      queriesValue,
      options
    );
    state.value = getOptimisticResult();
  });
  onScopeDispose(() => {
    unsubscribe();
  });
  return options.shallow ? shallowReadonly(state) : readonly(state);
}

// node_modules/@tanstack/vue-query/build/modern/useInfiniteQuery.js
function useInfiniteQuery(options, queryClient) {
  return useBaseQuery(
    InfiniteQueryObserver,
    options,
    queryClient
  );
}

// node_modules/@tanstack/vue-query/build/modern/useMutation.js
function useMutation(mutationOptions, queryClient) {
  if (true) {
    if (!getCurrentScope()) {
      console.warn(
        'vue-query composable like "useQuery()" should only be used inside a "setup()" function or a running effect scope. They might otherwise lead to memory leaks.'
      );
    }
  }
  const client = queryClient || useQueryClient();
  const options = computed(() => {
    const resolvedOptions = typeof mutationOptions === "function" ? mutationOptions() : mutationOptions;
    return client.defaultMutationOptions(cloneDeepUnref(resolvedOptions));
  });
  const observer = new MutationObserver(client, options.value);
  const state = options.value.shallow ? shallowReactive(observer.getCurrentResult()) : reactive(observer.getCurrentResult());
  const unsubscribe = observer.subscribe((result) => {
    updateState(state, result);
  });
  const mutate = (variables, mutateOptions) => {
    observer.mutate(variables, mutateOptions).catch(() => {
    });
  };
  watch(options, () => {
    observer.setOptions(options.value);
  });
  onScopeDispose(() => {
    unsubscribe();
  });
  const readonlyState = options.value.shallow ? shallowReadonly(state) : readonly(state);
  const resultRefs = toRefs(readonlyState);
  watch(
    () => state.error,
    (error) => {
      if (error && shouldThrowError(options.value.throwOnError, [error])) {
        throw error;
      }
    }
  );
  return {
    ...resultRefs,
    mutate,
    mutateAsync: state.mutate,
    reset: state.reset
  };
}

// node_modules/@tanstack/vue-query/build/modern/useIsFetching.js
function useIsFetching(fetchingFilters = {}, queryClient) {
  if (true) {
    if (!getCurrentScope()) {
      console.warn(
        'vue-query composable like "useQuery()" should only be used inside a "setup()" function or a running effect scope. They might otherwise lead to memory leaks.'
      );
    }
  }
  const client = queryClient || useQueryClient();
  const isFetching = ref();
  const listener = () => {
    const resolvedFilters = typeof fetchingFilters === "function" ? fetchingFilters() : fetchingFilters;
    isFetching.value = client.isFetching(cloneDeepUnref(resolvedFilters));
  };
  const unsubscribe = client.getQueryCache().subscribe(listener);
  watchEffect(listener);
  onScopeDispose(() => {
    unsubscribe();
  });
  return isFetching;
}

// node_modules/@tanstack/vue-query/build/modern/useMutationState.js
function useIsMutating(filters = {}, queryClient) {
  if (true) {
    if (!getCurrentScope()) {
      console.warn(
        'vue-query composable like "useQuery()" should only be used inside a "setup()" function or a running effect scope. They might otherwise lead to memory leaks.'
      );
    }
  }
  const client = queryClient || useQueryClient();
  const mutationState = useMutationState(
    {
      filters: computed(() => ({
        ...cloneDeepUnref(typeof filters === "function" ? filters() : filters),
        status: "pending"
      }))
    },
    client
  );
  const length = computed(() => mutationState.value.length);
  return length;
}
function getResult(mutationCache, options) {
  return mutationCache.findAll(options.filters).map(
    (mutation) => options.select ? options.select(mutation) : mutation.state
  );
}
function useMutationState(options = {}, queryClient) {
  const resolvedOptions = computed(() => {
    const newOptions = typeof options === "function" ? options() : options;
    return {
      filters: cloneDeepUnref(newOptions.filters),
      select: newOptions.select
    };
  });
  const mutationCache = (queryClient || useQueryClient()).getMutationCache();
  const state = shallowRef(getResult(mutationCache, resolvedOptions.value));
  const unsubscribe = mutationCache.subscribe(() => {
    state.value = getResult(mutationCache, resolvedOptions.value);
  });
  watch(resolvedOptions, () => {
    state.value = getResult(mutationCache, resolvedOptions.value);
  });
  onScopeDispose(() => {
    unsubscribe();
  });
  return shallowReadonly(state);
}

export {
  VUE_QUERY_CLIENT,
  useQueryClient,
  QueryCache2 as QueryCache,
  MutationCache2 as MutationCache,
  QueryClient2 as QueryClient,
  VueQueryPlugin,
  queryOptions,
  infiniteQueryOptions,
  useQuery,
  useQueries,
  useInfiniteQuery,
  useMutation,
  useIsFetching,
  useIsMutating,
  useMutationState
};
//# sourceMappingURL=chunk-SFFHNKTF.js.map
