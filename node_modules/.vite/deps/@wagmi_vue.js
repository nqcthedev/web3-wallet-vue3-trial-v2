import {
  BaseError,
  ChainNotConfiguredError,
  ConnectorAccountNotFoundError,
  ConnectorAlreadyConnectedError,
  ConnectorChainMismatchError,
  ConnectorNotFoundError,
  ConnectorUnavailableReconnectingError,
  ProviderNotFoundError,
  SwitchChainNotSupportedError,
  connect,
  cookieStorage,
  cookieToInitialState,
  createConfig,
  createConnector,
  createStorage,
  deepEqual,
  deserialize,
  disconnect,
  estimateGas,
  fallback,
  getBalance,
  getBlockNumber,
  getBytecode,
  getChainId,
  getChains,
  getClient,
  getConnection,
  getConnections,
  getConnectorClient,
  getConnectors,
  getEnsAddress,
  getEnsAvatar,
  getEnsName,
  getTransaction,
  getTransactionReceipt,
  hydrate,
  injected,
  mock,
  noopStorage,
  parseCookie,
  readContract,
  reconnect,
  sendTransaction,
  serialize,
  signMessage,
  signTypedData,
  simulateContract,
  switchChain,
  switchConnection,
  unstable_connector,
  waitForTransactionReceipt,
  watchBlockNumber,
  watchChainId,
  watchClient,
  watchConnection,
  watchConnections,
  watchConnectors,
  watchContractEvent,
  writeContract
} from "./chunk-U6EV7BEV.js";
import {
  useMutation,
  useQuery,
  useQueryClient
} from "./chunk-SFFHNKTF.js";
import {
  computed,
  hasInjectionContext,
  inject,
  isRef,
  onScopeDispose,
  reactive,
  readonly,
  ref,
  toRefs,
  unref,
  watchEffect
} from "./chunk-DUJS4OLK.js";
import "./chunk-QMUQLAW7.js";
import "./chunk-KME7UKT3.js";
import {
  custom,
  http,
  webSocket
} from "./chunk-PK3FUKRV.js";
import "./chunk-DOW7LSSZ.js";
import "./chunk-4X65JDLI.js";
import "./chunk-UU24B44V.js";
import "./chunk-Z6GLK4M2.js";
import "./chunk-KR3SNR3Q.js";
import "./chunk-XIJ6CS2S.js";
import "./chunk-HXNQWV53.js";
import {
  replaceEqualDeep
} from "./chunk-SWPER5RL.js";
import "./chunk-DI52DQAC.js";

// node_modules/@wagmi/vue/dist/esm/plugin.js
var configKey = /* @__PURE__ */ Symbol();
var WagmiPlugin = {
  install(app, options) {
    const { config, reconnectOnMount = true } = options;
    app.provide(configKey, config);
    const { onMount } = hydrate(config, { ...options, reconnectOnMount });
    onMount();
  }
};

// node_modules/@wagmi/vue/dist/esm/version.js
var version = "0.4.11";

// node_modules/@wagmi/vue/dist/esm/utils/getVersion.js
var getVersion = () => `@wagmi/vue@${version}`;

// node_modules/@wagmi/vue/dist/esm/errors/base.js
var BaseError2 = class extends BaseError {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WagmiError"
    });
  }
  get docsBaseUrl() {
    return "https://wagmi.sh/vue";
  }
  get version() {
    return getVersion();
  }
};

// node_modules/@wagmi/vue/dist/esm/errors/plugin.js
var WagmiPluginNotFoundError = class extends BaseError2 {
  constructor() {
    super("No `config` found in Vue context, use `WagmiPlugin` to properly initialize the library.", {
      docsPath: "/api/TODO"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WagmiPluginNotFoundError"
    });
  }
};
var WagmiInjectionContextError = class extends BaseError2 {
  constructor() {
    super("Wagmi composables can only be used inside `setup()` function or functions that support injection context.", {
      docsPath: "/api/TODO"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WagmiInjectionContextError"
    });
  }
};

// node_modules/@wagmi/core/dist/esm/query/utils.js
function structuralSharing(oldData, newData) {
  return replaceEqualDeep(oldData, newData);
}
function hashFn(queryKey) {
  return JSON.stringify(queryKey, (_, value) => {
    if (isPlainObject(value))
      return Object.keys(value).sort().reduce((result, key) => {
        result[key] = value[key];
        return result;
      }, {});
    if (typeof value === "bigint")
      return value.toString();
    return value;
  });
}
function isPlainObject(value) {
  if (!hasObjectPrototype(value)) {
    return false;
  }
  const ctor = value.constructor;
  if (typeof ctor === "undefined")
    return true;
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot))
    return false;
  if (!prot.hasOwnProperty("isPrototypeOf"))
    return false;
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function filterQueryOptions(options) {
  const {
    // import('@tanstack/query-core').QueryOptions
    // biome-ignore lint/correctness/noUnusedVariables: tossing
    _defaulted,
    behavior,
    gcTime,
    initialData,
    initialDataUpdatedAt,
    maxPages,
    meta,
    networkMode,
    queryFn,
    queryHash,
    queryKey,
    queryKeyHashFn,
    retry,
    retryDelay,
    structuralSharing: structuralSharing2,
    // import('@tanstack/query-core').InfiniteQueryObserverOptions
    // biome-ignore lint/correctness/noUnusedVariables: tossing
    getPreviousPageParam,
    getNextPageParam,
    initialPageParam,
    // import('@tanstack/react-query').UseQueryOptions
    // biome-ignore lint/correctness/noUnusedVariables: tossing
    _optimisticResults,
    enabled,
    notifyOnChangeProps,
    placeholderData,
    refetchInterval,
    refetchIntervalInBackground,
    refetchOnMount,
    refetchOnReconnect,
    refetchOnWindowFocus,
    retryOnMount,
    select,
    staleTime,
    suspense,
    throwOnError,
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // wagmi
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // biome-ignore lint/correctness/noUnusedVariables: tossing
    abi,
    config,
    connector,
    query,
    watch,
    ...rest
  } = options;
  if (connector)
    return { connectorUid: connector?.uid, ...rest };
  return rest;
}

// node_modules/@wagmi/core/dist/esm/query/connect.js
function connectMutationOptions(config) {
  return {
    mutationFn(variables) {
      return connect(config, variables);
    },
    mutationKey: ["connect"]
  };
}

// node_modules/@wagmi/core/dist/esm/query/disconnect.js
function disconnectMutationOptions(config) {
  return {
    mutationFn(variables) {
      return disconnect(config, variables);
    },
    mutationKey: ["disconnect"]
  };
}

// node_modules/@wagmi/core/dist/esm/query/estimateGas.js
function estimateGasQueryOptions(config, options = {}) {
  return {
    ...options.query,
    enabled: Boolean((options.account || options.connector) && (options.query?.enabled ?? true)),
    queryFn: async (context) => {
      const [, { scopeKey: _, ...parameters }] = context.queryKey;
      if (!parameters.account && !options.connector)
        throw new Error("account or connector is required");
      return estimateGas(config, {
        ...parameters,
        account: parameters.account,
        connector: options.connector
      });
    },
    queryKey: estimateGasQueryKey(options)
  };
}
function estimateGasQueryKey(options = {}) {
  return ["estimateGas", filterQueryOptions(options)];
}

// node_modules/@wagmi/core/dist/esm/query/getBalance.js
function getBalanceQueryOptions(config, options = {}) {
  return {
    ...options.query,
    enabled: Boolean(options.address && (options.query?.enabled ?? true)),
    queryFn: async (context) => {
      const [, { scopeKey: _, ...parameters }] = context.queryKey;
      if (!parameters.address)
        throw new Error("address is required");
      const balance = await getBalance(config, {
        ...parameters,
        address: parameters.address
      });
      return balance ?? null;
    },
    queryKey: getBalanceQueryKey(options)
  };
}
function getBalanceQueryKey(options = {}) {
  return ["balance", filterQueryOptions(options)];
}

// node_modules/@wagmi/core/dist/esm/query/getBlockNumber.js
function getBlockNumberQueryOptions(config, options = {}) {
  return {
    ...options.query,
    gcTime: 0,
    queryFn: async (context) => {
      const [, { scopeKey: _, ...parameters }] = context.queryKey;
      const blockNumber = await getBlockNumber(config, parameters);
      return blockNumber ?? null;
    },
    queryKey: getBlockNumberQueryKey(options)
  };
}
function getBlockNumberQueryKey(options = {}) {
  return ["blockNumber", filterQueryOptions(options)];
}

// node_modules/@wagmi/core/dist/esm/query/getBytecode.js
function getBytecodeQueryOptions(config, options = {}) {
  return {
    ...options.query,
    enabled: Boolean(options.address && (options.query?.enabled ?? true)),
    queryFn: async (context) => {
      const [, { scopeKey: _, ...parameters }] = context.queryKey;
      if (!parameters.address)
        throw new Error("address is required");
      const bytecode = await getBytecode(config, {
        ...parameters,
        address: parameters.address
      });
      return bytecode ?? null;
    },
    queryKey: getBytecodeQueryKey(options)
  };
}
function getBytecodeQueryKey(options = {}) {
  return ["getBytecode", filterQueryOptions(options)];
}

// node_modules/@wagmi/core/dist/esm/query/getConnectorClient.js
function getConnectorClientQueryOptions(config, options = {}) {
  return {
    ...options.query,
    enabled: Boolean(options.connector?.getProvider && (options.query?.enabled ?? true)),
    gcTime: 0,
    queryFn: async (context) => {
      const [, { connectorUid: _, scopeKey: __, ...parameters }] = context.queryKey;
      return getConnectorClient(config, {
        ...parameters,
        connector: options.connector
      });
    },
    queryKey: getConnectorClientQueryKey(options),
    staleTime: Number.POSITIVE_INFINITY
  };
}
function getConnectorClientQueryKey(options = {}) {
  return ["connectorClient", filterQueryOptions(options)];
}

// node_modules/@wagmi/core/dist/esm/query/getEnsAddress.js
function getEnsAddressQueryOptions(config, options = {}) {
  return {
    ...options.query,
    enabled: Boolean(options.name && (options.query?.enabled ?? true)),
    queryFn: async (context) => {
      const [, { scopeKey: _, ...parameters }] = context.queryKey;
      if (!parameters.name)
        throw new Error("name is required");
      return getEnsAddress(config, { ...parameters, name: parameters.name });
    },
    queryKey: getEnsAddressQueryKey(options)
  };
}
function getEnsAddressQueryKey(options = {}) {
  return ["ensAddress", filterQueryOptions(options)];
}

// node_modules/@wagmi/core/dist/esm/query/getEnsAvatar.js
function getEnsAvatarQueryOptions(config, options = {}) {
  return {
    ...options.query,
    enabled: Boolean(options.name && (options.query?.enabled ?? true)),
    queryFn: async (context) => {
      const [, { scopeKey: _, ...parameters }] = context.queryKey;
      if (!parameters.name)
        throw new Error("name is required");
      return getEnsAvatar(config, { ...parameters, name: parameters.name });
    },
    queryKey: getEnsAvatarQueryKey(options)
  };
}
function getEnsAvatarQueryKey(options = {}) {
  return ["ensAvatar", filterQueryOptions(options)];
}

// node_modules/@wagmi/core/dist/esm/query/getEnsName.js
function getEnsNameQueryOptions(config, options = {}) {
  return {
    ...options.query,
    enabled: Boolean(options.address && (options.query?.enabled ?? true)),
    queryFn: async (context) => {
      const [, { scopeKey: _, ...parameters }] = context.queryKey;
      if (!parameters.address)
        throw new Error("address is required");
      return getEnsName(config, { ...parameters, address: parameters.address });
    },
    queryKey: getEnsNameQueryKey(options)
  };
}
function getEnsNameQueryKey(options = {}) {
  return ["ensName", filterQueryOptions(options)];
}

// node_modules/@wagmi/core/dist/esm/query/getTransaction.js
function getTransactionQueryOptions(config, options = {}) {
  return {
    ...options.query,
    enabled: Boolean((options.hash || options.index && (options.blockHash || options.blockNumber || options.blockTag)) && (options.query?.enabled ?? true)),
    queryFn: async (context) => {
      const [, { scopeKey: _, ...parameters }] = context.queryKey;
      if (!(parameters.hash || parameters.index && (parameters.blockHash || parameters.blockNumber || parameters.blockTag)))
        throw new Error("hash OR index AND blockHash, blockNumber, blockTag is required");
      return getTransaction(config, parameters);
    },
    queryKey: getTransactionQueryKey(options)
  };
}
function getTransactionQueryKey(options = {}) {
  return ["transaction", filterQueryOptions(options)];
}

// node_modules/@wagmi/core/dist/esm/query/getTransactionReceipt.js
function getTransactionReceiptQueryOptions(config, options = {}) {
  return {
    ...options.query,
    enabled: Boolean(options.hash && (options.query?.enabled ?? true)),
    queryFn: async (context) => {
      const [, { scopeKey: _, ...parameters }] = context.queryKey;
      if (!parameters.hash)
        throw new Error("hash is required");
      return getTransactionReceipt(config, {
        ...parameters,
        hash: parameters.hash
      });
    },
    queryKey: getTransactionReceiptQueryKey(options)
  };
}
function getTransactionReceiptQueryKey(options = {}) {
  return ["getTransactionReceipt", filterQueryOptions(options)];
}

// node_modules/@wagmi/core/dist/esm/query/readContract.js
function readContractQueryOptions(config, options = {}) {
  return {
    ...options.query,
    enabled: Boolean(Boolean(options.address || "code" in options && options.code) && options.abi && options.functionName && (options.query?.enabled ?? true)),
    // TODO: Support `signal` once Viem actions allow passthrough
    // https://tkdodo.eu/blog/why-you-want-react-query#bonus-cancellation
    queryFn: async (context) => {
      if (!options.abi)
        throw new Error("abi is required");
      const [, { scopeKey: _, ...parameters }] = context.queryKey;
      if (!parameters.functionName)
        throw new Error("functionName is required");
      const result = await readContract(config, {
        ...parameters,
        abi: options.abi,
        address: parameters.address,
        code: "code" in parameters && parameters.code ? parameters.code : void 0,
        functionName: parameters.functionName
      });
      return result;
    },
    queryKey: readContractQueryKey(options),
    structuralSharing
  };
}
function readContractQueryKey(options = {}) {
  return ["readContract", filterQueryOptions(options)];
}

// node_modules/@wagmi/core/dist/esm/query/reconnect.js
function reconnectMutationOptions(config) {
  return {
    mutationFn(variables) {
      return reconnect(config, variables);
    },
    mutationKey: ["reconnect"]
  };
}

// node_modules/@wagmi/core/dist/esm/query/sendTransaction.js
function sendTransactionMutationOptions(config) {
  return {
    mutationFn(variables) {
      return sendTransaction(config, variables);
    },
    mutationKey: ["sendTransaction"]
  };
}

// node_modules/@wagmi/core/dist/esm/query/signMessage.js
function signMessageMutationOptions(config) {
  return {
    mutationFn(variables) {
      return signMessage(config, variables);
    },
    mutationKey: ["signMessage"]
  };
}

// node_modules/@wagmi/core/dist/esm/query/signTypedData.js
function signTypedDataMutationOptions(config) {
  return {
    mutationFn(variables) {
      return signTypedData(config, variables);
    },
    mutationKey: ["signTypedData"]
  };
}

// node_modules/@wagmi/core/dist/esm/query/simulateContract.js
function simulateContractQueryOptions(config, options = {}) {
  return {
    ...options.query,
    enabled: Boolean(options.abi && options.address && options.connector && options.functionName && (options.query?.enabled ?? true)),
    queryFn: async (context) => {
      if (!options.abi)
        throw new Error("abi is required");
      if (!options.connector)
        throw new Error("connector is required");
      const [, { scopeKey: _, ...parameters }] = context.queryKey;
      if (!parameters.address)
        throw new Error("address is required");
      if (!parameters.functionName)
        throw new Error("functionName is required");
      return simulateContract(config, {
        ...parameters,
        abi: options.abi,
        address: parameters.address,
        connector: options.connector,
        functionName: parameters.functionName
      });
    },
    queryKey: simulateContractQueryKey(options)
  };
}
function simulateContractQueryKey(options = {}) {
  const { connector: _, ...rest } = options;
  return ["simulateContract", filterQueryOptions(rest)];
}

// node_modules/@wagmi/core/dist/esm/query/switchChain.js
function switchChainMutationOptions(config) {
  return {
    mutationFn(variables) {
      return switchChain(config, variables);
    },
    mutationKey: ["switchChain"]
  };
}

// node_modules/@wagmi/core/dist/esm/query/switchConnection.js
function switchConnectionMutationOptions(config) {
  return {
    mutationFn(variables) {
      return switchConnection(config, variables);
    },
    mutationKey: ["switchConnection"]
  };
}

// node_modules/@wagmi/core/dist/esm/query/waitForTransactionReceipt.js
function waitForTransactionReceiptQueryOptions(config, options = {}) {
  return {
    ...options.query,
    enabled: Boolean(options.hash && (options.query?.enabled ?? true)),
    queryFn: async (context) => {
      const [, { scopeKey: _, ...parameters }] = context.queryKey;
      if (!parameters.hash)
        throw new Error("hash is required");
      return waitForTransactionReceipt(config, {
        ...parameters,
        onReplaced: options.onReplaced,
        hash: parameters.hash
      });
    },
    queryKey: waitForTransactionReceiptQueryKey(options)
  };
}
function waitForTransactionReceiptQueryKey(options = {}) {
  const { onReplaced: _, ...rest } = options;
  return ["waitForTransactionReceipt", filterQueryOptions(rest)];
}

// node_modules/@wagmi/core/dist/esm/query/writeContract.js
function writeContractMutationOptions(config) {
  return {
    mutationFn(variables) {
      return writeContract(config, variables);
    },
    mutationKey: ["writeContract"]
  };
}

// node_modules/@wagmi/vue/dist/esm/utils/cloneDeep.js
function cloneDeep(value, customize) {
  if (customize) {
    const result = customize(value);
    if (result === void 0 && isRef(value))
      return result;
    if (result !== void 0)
      return result;
  }
  if (Array.isArray(value))
    return value.map((val) => cloneDeep(val, customize));
  if (typeof value === "object" && isPlainObject2(value)) {
    const entries = Object.entries(value).map(([key, val]) => [
      key,
      cloneDeep(val, customize)
    ]);
    return Object.fromEntries(entries);
  }
  return value;
}
function deepUnref(value) {
  return cloneDeep(value, (val) => {
    if (isRef(val))
      return deepUnref(unref(val));
    return void 0;
  });
}
function isPlainObject2(value) {
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.prototype;
}

// node_modules/@wagmi/vue/dist/esm/utils/query.js
function useQuery2(parameters) {
  const options = computed(() => ({
    ...unref(parameters),
    queryKeyHashFn: hashFn
  }));
  const result = useQuery(options);
  result.queryKey = unref(options).queryKey;
  return result;
}

// node_modules/@wagmi/vue/dist/esm/composables/useConfig.js
function useConfig(parameters_ = {}) {
  const parameters = unref(parameters_);
  if (parameters.config)
    return parameters.config;
  if (!hasInjectionContext())
    throw new WagmiInjectionContextError();
  const config = inject(configKey);
  if (!config)
    throw new WagmiPluginNotFoundError();
  return config;
}

// node_modules/@wagmi/vue/dist/esm/composables/useChainId.js
function useChainId(parameters = {}) {
  const config = useConfig(parameters);
  const chainId = ref(getChainId(config));
  const unsubscribe = watchChainId(config, {
    onChange(data) {
      chainId.value = data;
    }
  });
  onScopeDispose(() => unsubscribe());
  return readonly(chainId);
}

// node_modules/@wagmi/vue/dist/esm/composables/useBalance.js
function useBalance(parameters = {}) {
  const params = computed(() => deepUnref(parameters));
  const config = useConfig(params);
  const chainId = useChainId({ config });
  const options = computed(() => getBalanceQueryOptions(config, {
    ...params.value,
    chainId: params.value.chainId ?? chainId.value,
    query: params.value.query
  }));
  return useQuery2(options);
}

// node_modules/@wagmi/vue/dist/esm/composables/useWatchBlockNumber.js
function useWatchBlockNumber(parameters_ = {}) {
  const parameters = computed(() => deepUnref(parameters_));
  const config = useConfig(parameters);
  const configChainId = useChainId({ config });
  watchEffect((onCleanup) => {
    const { chainId = configChainId.value, enabled = true, onBlockNumber, config: _, ...rest } = parameters.value;
    if (!enabled)
      return;
    if (!onBlockNumber)
      return;
    const unwatch = watchBlockNumber(config, {
      ...rest,
      chainId,
      onBlockNumber,
      emitOnBegin: true
    });
    onCleanup(unwatch);
  });
}

// node_modules/@wagmi/vue/dist/esm/composables/useBlockNumber.js
function useBlockNumber(parameters = {}) {
  const params = computed(() => deepUnref(parameters));
  const config = useConfig(params);
  const chainId = useChainId({ config });
  const options = computed(() => getBlockNumberQueryOptions(config, {
    ...params.value,
    chainId: params.value.chainId ?? chainId.value,
    query: params.value.query
  }));
  const queryClient = useQueryClient();
  const watchBlockNumberArgs = computed(() => {
    return {
      ...{
        config,
        chainId: params.value.chainId ?? chainId.value,
        ...typeof params.value.watch === "object" ? params.value.watch : {}
      },
      enabled: (params.value.query?.enabled ?? true) && (typeof params.value.watch === "object" ? params.value.watch.enabled : params.value.watch),
      onBlockNumber(blockNumber) {
        queryClient.setQueryData(options.value.queryKey, blockNumber);
      }
    };
  });
  useWatchBlockNumber(watchBlockNumberArgs);
  return useQuery2(options);
}

// node_modules/@wagmi/vue/dist/esm/composables/useBytecode.js
function useBytecode(parameters = {}) {
  const params = computed(() => deepUnref(parameters));
  const config = useConfig(params);
  const chainId = useChainId({ config });
  const options = computed(() => getBytecodeQueryOptions(config, {
    ...params.value,
    address: params.value.address,
    chainId: params.value.chainId ?? chainId.value,
    query: params.value.query
  }));
  return useQuery2(options);
}

// node_modules/@wagmi/core/dist/esm/actions/watchChains.js
function watchChains(config, parameters) {
  const { onChange } = parameters;
  return config._internal.chains.subscribe((chains, prevChains) => {
    onChange(chains, prevChains);
  });
}

// node_modules/@wagmi/vue/dist/esm/composables/useChains.js
function useChains(parameters = {}) {
  const config = useConfig(parameters);
  const chains = ref(getChains(config));
  const unsubscribe = watchChains(config, {
    onChange(data) {
      chains.value = data;
    }
  });
  onScopeDispose(() => unsubscribe());
  return readonly(chains);
}

// node_modules/@wagmi/vue/dist/esm/composables/useClient.js
function useClient(parameters = {}) {
  const params = computed(() => deepUnref(parameters));
  const config = useConfig(params);
  const client = ref(getClient(config, params.value));
  watchEffect(() => {
    client.value = getClient(config, params.value);
  });
  const unsubscribe = watchClient(config, {
    onChange(data) {
      if (client.value?.uid === data?.uid)
        return;
      client.value = data;
    }
  });
  onScopeDispose(() => unsubscribe());
  return readonly(client);
}

// node_modules/@wagmi/vue/dist/esm/composables/useConnectors.js
function useConnectors(parameters = {}) {
  const config = useConfig(parameters);
  const connectors = ref(getConnectors(config));
  const unsubscribe = watchConnectors(config, {
    onChange(data) {
      connectors.value = data;
    }
  });
  onScopeDispose(() => unsubscribe());
  return connectors;
}

// node_modules/@wagmi/vue/dist/esm/composables/useConnect.js
function useConnect(parameters = {}) {
  const config = useConfig(parameters);
  const mutationOptions = connectMutationOptions(config);
  const { mutate, mutateAsync, ...result } = useMutation({
    ...parameters.mutation,
    ...mutationOptions
  });
  const unsubscribe = config.subscribe(({ status }) => status, (status, previousStatus) => {
    if (previousStatus === "connected" && status === "disconnected")
      result.reset();
  });
  onScopeDispose(() => unsubscribe());
  return {
    ...result,
    connect: mutate,
    connectAsync: mutateAsync,
    connectors: useConnectors({ config }).value,
    mutate,
    mutateAsync
  };
}

// node_modules/@wagmi/vue/dist/esm/utils/updateState.js
function updateState(state, update) {
  for (const key of Object.keys(state)) {
    state[key] = update[key];
  }
}

// node_modules/@wagmi/vue/dist/esm/composables/useConnection.js
function useConnection(parameters = {}) {
  const config = useConfig(parameters);
  const connection = reactive(getConnection(config));
  const unsubscribe = watchConnection(config, {
    onChange(data) {
      updateState(connection, data);
    }
  });
  onScopeDispose(() => unsubscribe());
  return toRefs(readonly(connection));
}

// node_modules/@wagmi/vue/dist/esm/composables/useConnectionEffect.js
function useConnectionEffect(parameters = {}) {
  const config = useConfig(parameters);
  watchEffect((onCleanup) => {
    const { onConnect, onDisconnect } = deepUnref(parameters);
    const unwatch = watchConnection(config, {
      onChange(data, prevData) {
        if ((prevData.status === "reconnecting" || prevData.status === "connecting" && prevData.address === void 0) && data.status === "connected") {
          const { address, addresses, chain, chainId, connector } = data;
          const isReconnected = prevData.status === "reconnecting" || // if `previousAccount.status` is `undefined`, the connector connected immediately.
          prevData.status === void 0;
          onConnect?.({
            address,
            addresses,
            chain,
            chainId,
            connector,
            isReconnected
          });
        } else if (prevData.status === "connected" && data.status === "disconnected")
          onDisconnect?.();
      }
    });
    onCleanup(() => unwatch());
  });
}

// node_modules/@wagmi/vue/dist/esm/composables/useConnections.js
function useConnections(parameters = {}) {
  const config = useConfig(parameters);
  const connections = ref(getConnections(config));
  const unsubscribe = watchConnections(config, {
    onChange(data) {
      connections.value = data;
    }
  });
  onScopeDispose(() => unsubscribe());
  return readonly(connections);
}

// node_modules/@wagmi/vue/dist/esm/composables/useConnectorClient.js
function useConnectorClient(parameters = {}) {
  const params = computed(() => deepUnref(parameters));
  const config = useConfig(params);
  const chainId = useChainId({ config });
  const { address, connector } = useConnection({ config });
  const options = computed(() => getConnectorClientQueryOptions(config, {
    ...params.value,
    chainId: params.value.chainId ?? chainId.value,
    connector: params.value.connector ?? connector.value,
    query: params.value.query
  }));
  const addressRef = ref(address);
  const queryClient = useQueryClient();
  watchEffect(() => {
    const previousAddress = addressRef.value;
    if (!address && previousAddress) {
      queryClient.removeQueries({ queryKey: options.value.queryKey });
      addressRef.value = void 0;
    } else if (address.value !== previousAddress) {
      queryClient.invalidateQueries({ queryKey: options.value.queryKey });
      addressRef.value = address.value;
    }
  });
  return useQuery2(options);
}

// node_modules/@wagmi/vue/dist/esm/composables/useDisconnect.js
function useDisconnect(parameters = {}) {
  const config = useConfig(parameters);
  const connections = useConnections({ config });
  const mutationOptions = disconnectMutationOptions(config);
  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions });
  return {
    ...mutation,
    connectors: computed(() => connections.value.map((connection) => connection.connector)),
    disconnect: mutation.mutate,
    disconnectAsync: mutation.mutateAsync
  };
}

// node_modules/@wagmi/vue/dist/esm/composables/useEnsAddress.js
function useEnsAddress(parameters = {}) {
  const params = computed(() => deepUnref(parameters));
  const config = useConfig(params);
  const chainId = useChainId({ config });
  const options = computed(() => getEnsAddressQueryOptions(config, {
    ...params.value,
    chainId: params.value.chainId ?? chainId.value,
    query: params.value.query
  }));
  return useQuery2(options);
}

// node_modules/@wagmi/vue/dist/esm/composables/useEnsAvatar.js
function useEnsAvatar(parameters = {}) {
  const params = computed(() => deepUnref(parameters));
  const config = useConfig(params);
  const chainId = useChainId({ config });
  const options = computed(() => getEnsAvatarQueryOptions(config, {
    ...params.value,
    chainId: params.value.chainId ?? chainId.value,
    query: params.value.query
  }));
  return useQuery2(options);
}

// node_modules/@wagmi/vue/dist/esm/composables/useEnsName.js
function useEnsName(parameters = {}) {
  const params = computed(() => deepUnref(parameters));
  const config = useConfig(params);
  const chainId = useChainId({ config });
  const options = computed(() => getEnsNameQueryOptions(config, {
    ...params.value,
    address: params.value.address,
    chainId: params.value.chainId ?? chainId.value,
    query: params.value.query
  }));
  return useQuery2(options);
}

// node_modules/@wagmi/vue/dist/esm/composables/useEstimateGas.js
function useEstimateGas(parameters = {}) {
  const params = computed(() => deepUnref(parameters));
  const config = useConfig(params);
  const { address, connector } = useConnection({ config });
  const chainId = useChainId({ config });
  const options = computed(() => estimateGasQueryOptions(config, {
    ...params.value,
    account: params.value.account ?? address.value,
    chainId: params.value.chainId ?? chainId.value,
    connector: params.value.connector ?? connector.value,
    query: params.value.query
  }));
  return useQuery2(options);
}

// node_modules/@wagmi/vue/dist/esm/composables/useReadContract.js
function useReadContract(parameters = {}) {
  const params = computed(() => deepUnref(parameters));
  const config = useConfig(params);
  const chainId = useChainId({ config });
  const options = computed(() => readContractQueryOptions(config, {
    ...params.value,
    chainId: params.value.chainId ?? chainId.value,
    query: params.value.query
  }));
  return useQuery2(options);
}

// node_modules/@wagmi/vue/dist/esm/composables/useReconnect.js
function useReconnect(parameters = {}) {
  const config = useConfig(parameters);
  const mutationOptions = reconnectMutationOptions(config);
  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions });
  return {
    ...mutation,
    connectors: config.connectors,
    reconnect: mutation.mutate,
    reconnectAsync: mutation.mutateAsync
  };
}

// node_modules/@wagmi/vue/dist/esm/composables/useSendTransaction.js
function useSendTransaction(parameters = {}) {
  const config = useConfig(parameters);
  const mutationOptions = sendTransactionMutationOptions(config);
  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions });
  return {
    ...mutation,
    sendTransaction: mutation.mutate,
    sendTransactionAsync: mutation.mutateAsync
  };
}

// node_modules/@wagmi/vue/dist/esm/composables/useSignMessage.js
function useSignMessage(parameters = {}) {
  const config = useConfig(parameters);
  const mutationOptions = signMessageMutationOptions(config);
  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions });
  return {
    ...mutation,
    signMessage: mutation.mutate,
    signMessageAsync: mutation.mutateAsync
  };
}

// node_modules/@wagmi/vue/dist/esm/composables/useSignTypedData.js
function useSignTypedData(parameters = {}) {
  const config = useConfig(parameters);
  const mutationOptions = signTypedDataMutationOptions(config);
  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions });
  return {
    ...mutation,
    mutate: mutation.mutate,
    mutateAsync: mutation.mutateAsync,
    signTypedData: mutation.mutate,
    signTypedDataAsync: mutation.mutateAsync
  };
}

// node_modules/@wagmi/vue/dist/esm/composables/useSimulateContract.js
function useSimulateContract(parameters = {}) {
  const params = computed(() => deepUnref(parameters));
  const config = useConfig(params);
  const { address, connector } = useConnection();
  const chainId = useChainId({ config });
  const options = computed(() => simulateContractQueryOptions(config, {
    ...params.value,
    account: params.value.account ?? address.value,
    chainId: params.value.chainId ?? chainId.value,
    connector: params.value.connector ?? connector.value,
    query: params.value.query
  }));
  return useQuery2(options);
}

// node_modules/@wagmi/vue/dist/esm/composables/useSwitchChain.js
function useSwitchChain(parameters = {}) {
  const config = useConfig(parameters);
  const mutationOptions = switchChainMutationOptions(config);
  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions });
  return {
    ...mutation,
    chains: useChains({ config }),
    mutate: mutation.mutate,
    mutateAsync: mutation.mutateAsync,
    switchChain: mutation.mutate,
    switchChainAsync: mutation.mutateAsync
  };
}

// node_modules/@wagmi/vue/dist/esm/composables/useSwitchConnection.js
function useSwitchConnection(parameters = {}) {
  const config = useConfig(parameters);
  const connections = useConnections({ config });
  const mutationOptions = switchConnectionMutationOptions(config);
  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions });
  return {
    ...mutation,
    connectors: computed(() => connections.value.map((connection) => connection.connector)),
    mutate: mutation.mutate,
    mutateAsync: mutation.mutateAsync,
    switchAccount: mutation.mutate,
    switchAccountAsync: mutation.mutateAsync,
    switchConnection: mutation.mutate,
    switchConnectionAsync: mutation.mutateAsync
  };
}

// node_modules/@wagmi/vue/dist/esm/composables/useTransaction.js
function useTransaction(parameters = {}) {
  const params = computed(() => deepUnref(parameters));
  const config = useConfig(params);
  const chainId = useChainId({ config });
  const options = computed(() => getTransactionQueryOptions(config, {
    ...params.value,
    chainId: params.value.chainId ?? chainId.value,
    query: params.value.query
  }));
  return useQuery2(options);
}

// node_modules/@wagmi/vue/dist/esm/composables/useTransactionReceipt.js
function useTransactionReceipt(parameters = {}) {
  const params = computed(() => deepUnref(parameters));
  const config = useConfig(params);
  const chainId = useChainId({ config });
  const options = computed(() => getTransactionReceiptQueryOptions(config, {
    ...params.value,
    chainId: params.value.chainId ?? chainId.value,
    query: params.value.query
  }));
  return useQuery2(options);
}

// node_modules/@wagmi/vue/dist/esm/composables/useWaitForTransactionReceipt.js
function useWaitForTransactionReceipt(parameters = {}) {
  const params = computed(() => deepUnref(parameters));
  const config = useConfig(params);
  const chainId = useChainId({ config });
  const options = computed(() => waitForTransactionReceiptQueryOptions(config, {
    ...params.value,
    chainId: params.value.chainId ?? chainId.value,
    query: params.value.query
  }));
  return useQuery2(options);
}

// node_modules/@wagmi/vue/dist/esm/composables/useWatchContractEvent.js
function useWatchContractEvent(parameters = {}) {
  const parameters_ = computed(() => deepUnref(parameters));
  const config = useConfig(parameters_);
  const configChainId = useChainId({ config });
  watchEffect((onCleanup) => {
    const { chainId = configChainId.value, enabled = true, onLogs, config: _, ...rest } = parameters_.value;
    if (!enabled)
      return;
    if (!onLogs)
      return;
    const unwatch = watchContractEvent(config, {
      ...rest,
      chainId,
      onLogs
    });
    onCleanup(unwatch);
  });
}

// node_modules/@wagmi/vue/dist/esm/composables/useWriteContract.js
function useWriteContract(parameters = {}) {
  const config = useConfig(parameters);
  const mutationOptions = writeContractMutationOptions(config);
  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions });
  return {
    ...mutation,
    mutate: mutation.mutate,
    mutateAsync: mutation.mutateAsync,
    writeContract: mutation.mutate,
    writeContractAsync: mutation.mutateAsync
  };
}
export {
  BaseError2 as BaseError,
  ChainNotConfiguredError,
  ConnectorAccountNotFoundError,
  ConnectorAlreadyConnectedError,
  ConnectorChainMismatchError,
  ConnectorNotFoundError,
  ConnectorUnavailableReconnectingError,
  ProviderNotFoundError,
  SwitchChainNotSupportedError,
  WagmiInjectionContextError,
  WagmiPlugin,
  WagmiPluginNotFoundError,
  configKey,
  cookieStorage,
  cookieToInitialState,
  createConfig,
  createConnector,
  createStorage,
  custom,
  deepEqual,
  deserialize,
  fallback,
  http,
  injected,
  mock,
  noopStorage,
  parseCookie,
  serialize,
  unstable_connector,
  useConnection as useAccount,
  useConnectionEffect as useAccountEffect,
  useBalance,
  useBlockNumber,
  useBytecode,
  useChainId,
  useChains,
  useClient,
  useConfig,
  useConnect,
  useConnection,
  useConnectionEffect,
  useConnections,
  useConnectorClient,
  useConnectors,
  useDisconnect,
  useEnsAddress,
  useEnsAvatar,
  useEnsName,
  useEstimateGas,
  useReadContract,
  useReconnect,
  useSendTransaction,
  useSignMessage,
  useSignTypedData,
  useSimulateContract,
  useSwitchConnection as useSwitchAccount,
  useSwitchChain,
  useSwitchConnection,
  useTransaction,
  useTransactionReceipt,
  useWaitForTransactionReceipt,
  useWatchBlockNumber,
  useWatchContractEvent,
  useWriteContract,
  version,
  webSocket
};
//# sourceMappingURL=@wagmi_vue.js.map
