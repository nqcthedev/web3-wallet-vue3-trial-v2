{
  "version": 3,
  "sources": ["../../@tanstack/vue-query/node_modules/vue-demi/lib/index.mjs", "../../@tanstack/vue-query/src/utils.ts", "../../@tanstack/vue-query/src/useQueryClient.ts", "../../@tanstack/vue-query/src/queryCache.ts", "../../@tanstack/vue-query/src/mutationCache.ts", "../../@tanstack/vue-query/src/queryClient.ts", "../../@tanstack/vue-query/node_modules/@vue/devtools-api/lib/esm/env.js", "../../@tanstack/vue-query/node_modules/@vue/devtools-api/lib/esm/const.js", "../../@tanstack/vue-query/node_modules/@vue/devtools-api/lib/esm/time.js", "../../@tanstack/vue-query/node_modules/@vue/devtools-api/lib/esm/proxy.js", "../../@tanstack/vue-query/node_modules/@vue/devtools-api/lib/esm/index.js", "../../@tanstack/match-sorter-utils/src/remove-accents.ts", "../../@tanstack/match-sorter-utils/src/index.ts", "../../@tanstack/vue-query/src/devtools/utils.ts", "../../@tanstack/vue-query/src/devtools/devtools.ts", "../../@tanstack/vue-query/src/vueQueryPlugin.ts", "../../@tanstack/vue-query/src/queryOptions.ts", "../../@tanstack/vue-query/src/infiniteQueryOptions.ts", "../../@tanstack/vue-query/src/useBaseQuery.ts", "../../@tanstack/vue-query/src/useQuery.ts", "../../@tanstack/vue-query/src/useQueries.ts", "../../@tanstack/vue-query/src/useInfiniteQuery.ts", "../../@tanstack/vue-query/src/useMutation.ts", "../../@tanstack/vue-query/src/useIsFetching.ts", "../../@tanstack/vue-query/src/useMutationState.ts"],
  "sourcesContent": ["import * as Vue from 'vue'\n\nvar isVue2 = false\nvar isVue3 = true\nvar Vue2 = undefined\n\nfunction install() {}\n\nexport function set(target, key, val) {\n  if (Array.isArray(target)) {\n    target.length = Math.max(target.length, key)\n    target.splice(key, 1, val)\n    return val\n  }\n  target[key] = val\n  return val\n}\n\nexport function del(target, key) {\n  if (Array.isArray(target)) {\n    target.splice(key, 1)\n    return\n  }\n  delete target[key]\n}\n\nexport * from 'vue'\nexport {\n  Vue,\n  Vue2,\n  isVue2,\n  isVue3,\n  install,\n}\n", "import { isRef, unref } from 'vue-demi'\nimport type { MaybeRefDeep } from './types'\n\nexport const VUE_QUERY_CLIENT = 'VUE_QUERY_CLIENT'\n\nexport function getClientKey(key?: string) {\n  const suffix = key ? `:${key}` : ''\n  return `${VUE_QUERY_CLIENT}${suffix}`\n}\n\nexport function updateState(\n  state: Record<string, any>,\n  update: Record<string, any>,\n): void {\n  Object.keys(state).forEach((key) => {\n    state[key] = update[key]\n  })\n}\n\n// Helper function for cloning deep objects where\n// the level and key is provided to the callback function.\nfunction _cloneDeep<T>(\n  value: MaybeRefDeep<T>,\n  customize?: (\n    val: MaybeRefDeep<T>,\n    key: string,\n    level: number,\n  ) => T | undefined,\n  currentKey: string = '',\n  currentLevel: number = 0,\n): T {\n  if (customize) {\n    const result = customize(value, currentKey, currentLevel)\n    if (result === undefined && isRef(value)) {\n      return result as T\n    }\n    if (result !== undefined) {\n      return result\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return value.map((val, index) =>\n      _cloneDeep(val, customize, String(index), currentLevel + 1),\n    ) as unknown as T\n  }\n\n  if (typeof value === 'object' && isPlainObject(value)) {\n    const entries = Object.entries(value).map(([key, val]) => [\n      key,\n      _cloneDeep(val, customize, key, currentLevel + 1),\n    ])\n    return Object.fromEntries(entries)\n  }\n\n  return value as T\n}\n\nexport function cloneDeep<T>(\n  value: MaybeRefDeep<T>,\n  customize?: (\n    val: MaybeRefDeep<T>,\n    key: string,\n    level: number,\n  ) => T | undefined,\n): T {\n  return _cloneDeep(value, customize)\n}\n\nexport function cloneDeepUnref<T>(\n  obj: MaybeRefDeep<T>,\n  unrefGetters = false,\n): T {\n  return cloneDeep(obj, (val, key, level) => {\n    // Check if we're at the top level and the key is 'queryKey'\n    //\n    // If so, take the recursive descent where we resolve\n    // getters to values as well as refs.\n    if (level === 1 && key === 'queryKey') {\n      return cloneDeepUnref(val, true)\n    }\n\n    // Resolve getters to values if specified.\n    if (unrefGetters && isFunction(val)) {\n      // Cast due to older TS versions not allowing calling\n      // on certain intersection types.\n      return cloneDeepUnref((val as Function)(), unrefGetters)\n    }\n\n    // Unref refs and continue to recurse into the value.\n    if (isRef(val)) {\n      return cloneDeepUnref(unref(val), unrefGetters)\n    }\n\n    return undefined\n  })\n}\n\n// eslint-disable-next-line @typescript-eslint/no-wrapper-object-types\nfunction isPlainObject(value: unknown): value is Object {\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(value)\n  return prototype === null || prototype === Object.prototype\n}\n\nfunction isFunction(value: unknown): value is Function {\n  return typeof value === 'function'\n}\n", "import { hasInjectionContext, inject } from 'vue-demi'\n\nimport { getClientKey } from './utils'\nimport type { QueryClient } from './queryClient'\n\nexport function useQueryClient(id = ''): QueryClient {\n  // ensures that `inject()` can be used\n  if (!hasInjectionContext()) {\n    throw new Error(\n      'vue-query hooks can only be used inside setup() function or functions that support injection context.',\n    )\n  }\n\n  const key = getClientKey(id)\n  const queryClient = inject<QueryClient>(key)\n\n  if (!queryClient) {\n    throw new Error(\n      \"No 'queryClient' found in Vue context, use 'VueQueryPlugin' to properly initialize the library.\",\n    )\n  }\n\n  return queryClient\n}\n", "import { QueryCache as QC } from '@tanstack/query-core'\nimport { cloneDeepUnref } from './utils'\nimport type {\n  DefaultError,\n  Query,\n  QueryFilters,\n  WithRequired,\n} from '@tanstack/query-core'\nimport type { MaybeRefDeep } from './types'\n\nexport class QueryCache extends QC {\n  find<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData>(\n    filters: MaybeRefDeep<WithRequired<QueryFilters, 'queryKey'>>,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    return super.find(cloneDeepUnref(filters))\n  }\n\n  findAll(filters: MaybeRefDeep<QueryFilters> = {}): Array<Query> {\n    return super.findAll(cloneDeepUnref(filters))\n  }\n}\n", "import { MutationCache as MC } from '@tanstack/query-core'\nimport { cloneDeepUnref } from './utils'\nimport type {\n  DefaultError,\n  Mutation,\n  MutationFilters,\n} from '@tanstack/query-core'\nimport type { MaybeRefDeep } from './types'\n\nexport class MutationCache extends MC {\n  find<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = any,\n    TOnMutateResult = unknown,\n  >(\n    filters: MaybeRefDeep<MutationFilters>,\n  ): Mutation<TData, TError, TVariables, TOnMutateResult> | undefined {\n    return super.find(cloneDeepUnref(filters))\n  }\n\n  findAll(filters: MaybeRefDeep<MutationFilters> = {}): Array<Mutation> {\n    return super.findAll(cloneDeepUnref(filters))\n  }\n}\n", "import { nextTick, ref } from 'vue-demi'\nimport { QueryClient as QC } from '@tanstack/query-core'\nimport { cloneDeepUnref } from './utils'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport type { UseQueryOptions } from './useQuery'\nimport type { Ref } from 'vue-demi'\nimport type { MaybeRefDeep, NoUnknown, QueryClientConfig } from './types'\nimport type {\n  CancelOptions,\n  DefaultError,\n  DefaultOptions,\n  EnsureQueryDataOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InferDataFromTag,\n  InferErrorFromTag,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationFilters,\n  MutationKey,\n  MutationObserverOptions,\n  NoInfer,\n  OmitKeyof,\n  QueryFilters,\n  QueryKey,\n  QueryObserverOptions,\n  QueryState,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n  Updater,\n} from '@tanstack/query-core'\n\nexport class QueryClient extends QC {\n  constructor(config: QueryClientConfig = {}) {\n    const vueQueryConfig = {\n      defaultOptions: config.defaultOptions,\n      queryCache: config.queryCache || new QueryCache(),\n      mutationCache: config.mutationCache || new MutationCache(),\n    }\n    super(vueQueryConfig)\n  }\n\n  isRestoring?: Ref<boolean> = ref(false)\n\n  isFetching(filters: MaybeRefDeep<QueryFilters> = {}): number {\n    return super.isFetching(cloneDeepUnref(filters))\n  }\n\n  isMutating(filters: MaybeRefDeep<MutationFilters> = {}): number {\n    return super.isMutating(cloneDeepUnref(filters))\n  }\n\n  getQueryData<TData = unknown, TTaggedQueryKey extends QueryKey = QueryKey>(\n    queryKey: TTaggedQueryKey,\n  ): InferDataFromTag<TData, TTaggedQueryKey> | undefined\n  getQueryData<TData = unknown>(\n    queryKey: MaybeRefDeep<QueryKey>,\n  ): TData | undefined\n  getQueryData<TData = unknown>(\n    queryKey: MaybeRefDeep<QueryKey>,\n  ): TData | undefined {\n    return super.getQueryData(cloneDeepUnref(queryKey))\n  }\n\n  ensureQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: EnsureQueryDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: MaybeRefDeep<\n      EnsureQueryDataOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: MaybeRefDeep<\n      EnsureQueryDataOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<TData> {\n    return super.ensureQueryData(cloneDeepUnref(options))\n  }\n\n  getQueriesData<TData = unknown>(\n    filters: MaybeRefDeep<QueryFilters>,\n  ): Array<[QueryKey, TData | undefined]> {\n    return super.getQueriesData(cloneDeepUnref(filters))\n  }\n\n  setQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n  >(\n    queryKey: TTaggedQueryKey,\n    updater: Updater<\n      NoInfer<TInferredQueryFnData> | undefined,\n      NoInfer<TInferredQueryFnData> | undefined\n    >,\n    options?: MaybeRefDeep<SetDataOptions>,\n  ): NoInfer<TInferredQueryFnData> | undefined\n  setQueryData<TQueryFnData, TData = NoUnknown<TQueryFnData>>(\n    queryKey: MaybeRefDeep<QueryKey>,\n    updater: Updater<NoInfer<TData> | undefined, NoInfer<TData> | undefined>,\n    options?: MaybeRefDeep<SetDataOptions>,\n  ): NoInfer<TData> | undefined\n  setQueryData<TData>(\n    queryKey: MaybeRefDeep<QueryKey>,\n    updater: Updater<TData | undefined, TData | undefined>,\n    options: MaybeRefDeep<SetDataOptions> = {},\n  ): NoInfer<TData> | undefined {\n    return super.setQueryData(\n      cloneDeepUnref(queryKey),\n      updater,\n      cloneDeepUnref(options),\n    )\n  }\n\n  setQueriesData<TData>(\n    filters: MaybeRefDeep<QueryFilters>,\n    updater: Updater<TData | undefined, TData | undefined>,\n    options: MaybeRefDeep<SetDataOptions> = {},\n  ): Array<[QueryKey, TData | undefined]> {\n    return super.setQueriesData(\n      cloneDeepUnref(filters),\n      updater,\n      cloneDeepUnref(options),\n    )\n  }\n\n  getQueryState<TData = unknown, TError = DefaultError>(\n    queryKey: MaybeRefDeep<QueryKey>,\n  ): QueryState<TData, TError> | undefined {\n    return super.getQueryState(cloneDeepUnref(queryKey))\n  }\n\n  removeQueries<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(filters?: QueryFilters<TTaggedQueryKey>): void\n  removeQueries(filters: MaybeRefDeep<QueryFilters> = {}): void {\n    return super.removeQueries(cloneDeepUnref(filters))\n  }\n\n  resetQueries<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    filters?: QueryFilters<TTaggedQueryKey>,\n    options?: MaybeRefDeep<ResetOptions>,\n  ): Promise<void>\n  resetQueries(\n    filters: MaybeRefDeep<QueryFilters> = {},\n    options: MaybeRefDeep<ResetOptions> = {},\n  ): Promise<void> {\n    return super.resetQueries(cloneDeepUnref(filters), cloneDeepUnref(options))\n  }\n\n  cancelQueries<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    filters?: QueryFilters<TTaggedQueryKey>,\n    options?: MaybeRefDeep<CancelOptions>,\n  ): Promise<void>\n  cancelQueries(\n    filters: MaybeRefDeep<QueryFilters> = {},\n    options: MaybeRefDeep<CancelOptions> = {},\n  ): Promise<void> {\n    return super.cancelQueries(cloneDeepUnref(filters), cloneDeepUnref(options))\n  }\n\n  invalidateQueries<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    filters?: InvalidateQueryFilters<TTaggedQueryKey>,\n    options?: MaybeRefDeep<InvalidateOptions>,\n  ): Promise<void>\n  invalidateQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters: MaybeRefDeep<InvalidateQueryFilters<TTaggedQueryKey>> = {},\n    options: MaybeRefDeep<InvalidateOptions> = {},\n  ): Promise<void> {\n    const filtersCloned = cloneDeepUnref(filters)\n    const optionsCloned = cloneDeepUnref(options)\n\n    super.invalidateQueries(\n      { ...filtersCloned, refetchType: 'none' },\n      optionsCloned,\n    )\n\n    if (filtersCloned.refetchType === 'none') {\n      return Promise.resolve()\n    }\n\n    const refetchFilters: RefetchQueryFilters<TTaggedQueryKey> = {\n      ...filtersCloned,\n      type: filtersCloned.refetchType ?? filtersCloned.type ?? 'active',\n    }\n\n    // (dosipiuk): We need to delay `refetchQueries` execution to next macro task for all reactive values to be updated.\n    // This ensures that `context` in `queryFn` while `invalidating` along reactive variable change has correct\n    return nextTick().then(() => {\n      return super.refetchQueries(refetchFilters, optionsCloned)\n    })\n  }\n\n  refetchQueries<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    filters?: RefetchQueryFilters<TTaggedQueryKey>,\n    options?: MaybeRefDeep<RefetchOptions>,\n  ): Promise<void>\n  refetchQueries(\n    filters: MaybeRefDeep<RefetchQueryFilters> = {},\n    options: MaybeRefDeep<RefetchOptions> = {},\n  ): Promise<void> {\n    return super.refetchQueries(\n      cloneDeepUnref(filters),\n      cloneDeepUnref(options),\n    )\n  }\n\n  fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: FetchQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>\n    >,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>\n    >,\n  ): Promise<TData> {\n    return super.fetchQuery(cloneDeepUnref(options))\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void> {\n    return super.prefetchQuery(cloneDeepUnref(options))\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>>\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: MaybeRefDeep<\n      FetchInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryKey,\n        TPageParam\n      >\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>>\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: MaybeRefDeep<\n      FetchInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryKey,\n        TPageParam\n      >\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    return super.fetchInfiniteQuery(cloneDeepUnref(options))\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: MaybeRefDeep<\n      FetchInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryKey,\n        TPageParam\n      >\n    >,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: MaybeRefDeep<\n      FetchInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryKey,\n        TPageParam\n      >\n    >,\n  ): Promise<void> {\n    return super.prefetchInfiniteQuery(cloneDeepUnref(options))\n  }\n\n  setDefaultOptions(options: MaybeRefDeep<DefaultOptions>): void {\n    super.setDefaultOptions(cloneDeepUnref(options))\n  }\n\n  setQueryDefaults<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n  >(\n    queryKey: MaybeRefDeep<QueryKey>,\n    options: MaybeRefDeep<\n      Omit<UseQueryOptions<TQueryFnData, TError, TData, TQueryData>, 'queryKey'>\n    >,\n  ): void {\n    super.setQueryDefaults(cloneDeepUnref(queryKey), cloneDeepUnref(options))\n  }\n\n  getQueryDefaults(\n    queryKey: MaybeRefDeep<QueryKey>,\n  ): OmitKeyof<QueryObserverOptions<any, any, any, any, any>, 'queryKey'> {\n    return super.getQueryDefaults(cloneDeepUnref(queryKey))\n  }\n\n  setMutationDefaults<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = void,\n    TOnMutateResult = unknown,\n  >(\n    mutationKey: MaybeRefDeep<MutationKey>,\n    options: MaybeRefDeep<\n      MutationObserverOptions<TData, TError, TVariables, TOnMutateResult>\n    >,\n  ): void {\n    super.setMutationDefaults(\n      cloneDeepUnref(mutationKey),\n      cloneDeepUnref(options),\n    )\n  }\n\n  getMutationDefaults(\n    mutationKey: MaybeRefDeep<MutationKey>,\n  ): MutationObserverOptions<any, any, any, any> {\n    return super.getMutationDefaults(cloneDeepUnref(mutationKey))\n  }\n}\n", "export function getDevtoolsGlobalHook() {\n    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;\n}\nexport function getTarget() {\n    // @ts-expect-error navigator and windows are not available in all environments\n    return (typeof navigator !== 'undefined' && typeof window !== 'undefined')\n        ? window\n        : typeof globalThis !== 'undefined'\n            ? globalThis\n            : {};\n}\nexport const isProxyAvailable = typeof Proxy === 'function';\n", "export const HOOK_SETUP = 'devtools-plugin:setup';\nexport const HOOK_PLUGIN_SETTINGS_SET = 'plugin:settings:set';\n", "let supported;\nlet perf;\nexport function isPerformanceSupported() {\n    var _a;\n    if (supported !== undefined) {\n        return supported;\n    }\n    if (typeof window !== 'undefined' && window.performance) {\n        supported = true;\n        perf = window.performance;\n    }\n    else if (typeof globalThis !== 'undefined' && ((_a = globalThis.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {\n        supported = true;\n        perf = globalThis.perf_hooks.performance;\n    }\n    else {\n        supported = false;\n    }\n    return supported;\n}\nexport function now() {\n    return isPerformanceSupported() ? perf.now() : Date.now();\n}\n", "import { HOOK_PLUGIN_SETTINGS_SET } from './const.js';\nimport { now } from './time.js';\nexport class ApiProxy {\n    constructor(plugin, hook) {\n        this.target = null;\n        this.targetQueue = [];\n        this.onQueue = [];\n        this.plugin = plugin;\n        this.hook = hook;\n        const defaultSettings = {};\n        if (plugin.settings) {\n            for (const id in plugin.settings) {\n                const item = plugin.settings[id];\n                defaultSettings[id] = item.defaultValue;\n            }\n        }\n        const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;\n        let currentSettings = Object.assign({}, defaultSettings);\n        try {\n            const raw = localStorage.getItem(localSettingsSaveId);\n            const data = JSON.parse(raw);\n            Object.assign(currentSettings, data);\n        }\n        catch (e) {\n            // noop\n        }\n        this.fallbacks = {\n            getSettings() {\n                return currentSettings;\n            },\n            setSettings(value) {\n                try {\n                    localStorage.setItem(localSettingsSaveId, JSON.stringify(value));\n                }\n                catch (e) {\n                    // noop\n                }\n                currentSettings = value;\n            },\n            now() {\n                return now();\n            },\n        };\n        if (hook) {\n            hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {\n                if (pluginId === this.plugin.id) {\n                    this.fallbacks.setSettings(value);\n                }\n            });\n        }\n        this.proxiedOn = new Proxy({}, {\n            get: (_target, prop) => {\n                if (this.target) {\n                    return this.target.on[prop];\n                }\n                else {\n                    return (...args) => {\n                        this.onQueue.push({\n                            method: prop,\n                            args,\n                        });\n                    };\n                }\n            },\n        });\n        this.proxiedTarget = new Proxy({}, {\n            get: (_target, prop) => {\n                if (this.target) {\n                    return this.target[prop];\n                }\n                else if (prop === 'on') {\n                    return this.proxiedOn;\n                }\n                else if (Object.keys(this.fallbacks).includes(prop)) {\n                    return (...args) => {\n                        this.targetQueue.push({\n                            method: prop,\n                            args,\n                            resolve: () => { },\n                        });\n                        return this.fallbacks[prop](...args);\n                    };\n                }\n                else {\n                    return (...args) => {\n                        return new Promise((resolve) => {\n                            this.targetQueue.push({\n                                method: prop,\n                                args,\n                                resolve,\n                            });\n                        });\n                    };\n                }\n            },\n        });\n    }\n    async setRealTarget(target) {\n        this.target = target;\n        for (const item of this.onQueue) {\n            this.target.on[item.method](...item.args);\n        }\n        for (const item of this.targetQueue) {\n            item.resolve(await this.target[item.method](...item.args));\n        }\n    }\n}\n", "import { getDevtoolsGlobalHook, getTarget, isProxyAvailable } from './env.js';\nimport { HOOK_SETUP } from './const.js';\nimport { ApiProxy } from './proxy.js';\nexport * from './api/index.js';\nexport * from './plugin.js';\nexport * from './time.js';\nexport function setupDevtoolsPlugin(pluginDescriptor, setupFn) {\n    const descriptor = pluginDescriptor;\n    const target = getTarget();\n    const hook = getDevtoolsGlobalHook();\n    const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;\n    if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {\n        hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);\n    }\n    else {\n        const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;\n        const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];\n        list.push({\n            pluginDescriptor: descriptor,\n            setupFn,\n            proxy,\n        });\n        if (proxy) {\n            setupFn(proxy.proxiedTarget);\n        }\n    }\n}\n", "const characterMap: Record<string, string> = {\n  À: 'A',\n  Á: 'A',\n  Â: 'A',\n  Ã: 'A',\n  Ä: 'A',\n  Å: 'A',\n  Ấ: 'A',\n  Ắ: 'A',\n  Ẳ: 'A',\n  Ẵ: 'A',\n  Ặ: 'A',\n  Æ: 'AE',\n  Ầ: 'A',\n  Ằ: 'A',\n  Ȃ: 'A',\n  Ç: 'C',\n  Ḉ: 'C',\n  È: 'E',\n  É: 'E',\n  Ê: 'E',\n  Ë: 'E',\n  Ế: 'E',\n  Ḗ: 'E',\n  Ề: 'E',\n  Ḕ: 'E',\n  Ḝ: 'E',\n  Ȇ: 'E',\n  Ì: 'I',\n  Í: 'I',\n  Î: 'I',\n  Ï: 'I',\n  Ḯ: 'I',\n  Ȋ: 'I',\n  Ð: 'D',\n  Ñ: 'N',\n  Ò: 'O',\n  Ó: 'O',\n  Ô: 'O',\n  Õ: 'O',\n  Ö: 'O',\n  Ø: 'O',\n  Ố: 'O',\n  Ṍ: 'O',\n  Ṓ: 'O',\n  Ȏ: 'O',\n  Ù: 'U',\n  Ú: 'U',\n  Û: 'U',\n  Ü: 'U',\n  Ý: 'Y',\n  à: 'a',\n  á: 'a',\n  â: 'a',\n  ã: 'a',\n  ä: 'a',\n  å: 'a',\n  ấ: 'a',\n  ắ: 'a',\n  ẳ: 'a',\n  ẵ: 'a',\n  ặ: 'a',\n  æ: 'ae',\n  ầ: 'a',\n  ằ: 'a',\n  ȃ: 'a',\n  ç: 'c',\n  ḉ: 'c',\n  è: 'e',\n  é: 'e',\n  ê: 'e',\n  ë: 'e',\n  ế: 'e',\n  ḗ: 'e',\n  ề: 'e',\n  ḕ: 'e',\n  ḝ: 'e',\n  ȇ: 'e',\n  ì: 'i',\n  í: 'i',\n  î: 'i',\n  ï: 'i',\n  ḯ: 'i',\n  ȋ: 'i',\n  ð: 'd',\n  ñ: 'n',\n  ò: 'o',\n  ó: 'o',\n  ô: 'o',\n  õ: 'o',\n  ö: 'o',\n  ø: 'o',\n  ố: 'o',\n  ṍ: 'o',\n  ṓ: 'o',\n  ȏ: 'o',\n  ù: 'u',\n  ú: 'u',\n  û: 'u',\n  ü: 'u',\n  ý: 'y',\n  ÿ: 'y',\n  Ā: 'A',\n  ā: 'a',\n  Ă: 'A',\n  ă: 'a',\n  Ą: 'A',\n  ą: 'a',\n  Ć: 'C',\n  ć: 'c',\n  Ĉ: 'C',\n  ĉ: 'c',\n  Ċ: 'C',\n  ċ: 'c',\n  Č: 'C',\n  č: 'c',\n  C̆: 'C',\n  c̆: 'c',\n  Ď: 'D',\n  ď: 'd',\n  Đ: 'D',\n  đ: 'd',\n  Ē: 'E',\n  ē: 'e',\n  Ĕ: 'E',\n  ĕ: 'e',\n  Ė: 'E',\n  ė: 'e',\n  Ę: 'E',\n  ę: 'e',\n  Ě: 'E',\n  ě: 'e',\n  Ĝ: 'G',\n  Ǵ: 'G',\n  ĝ: 'g',\n  ǵ: 'g',\n  Ğ: 'G',\n  ğ: 'g',\n  Ġ: 'G',\n  ġ: 'g',\n  Ģ: 'G',\n  ģ: 'g',\n  Ĥ: 'H',\n  ĥ: 'h',\n  Ħ: 'H',\n  ħ: 'h',\n  Ḫ: 'H',\n  ḫ: 'h',\n  Ĩ: 'I',\n  ĩ: 'i',\n  Ī: 'I',\n  ī: 'i',\n  Ĭ: 'I',\n  ĭ: 'i',\n  Į: 'I',\n  į: 'i',\n  İ: 'I',\n  ı: 'i',\n  Ĳ: 'IJ',\n  ĳ: 'ij',\n  Ĵ: 'J',\n  ĵ: 'j',\n  Ķ: 'K',\n  ķ: 'k',\n  Ḱ: 'K',\n  ḱ: 'k',\n  K̆: 'K',\n  k̆: 'k',\n  Ĺ: 'L',\n  ĺ: 'l',\n  Ļ: 'L',\n  ļ: 'l',\n  Ľ: 'L',\n  ľ: 'l',\n  Ŀ: 'L',\n  ŀ: 'l',\n  Ł: 'l',\n  ł: 'l',\n  Ḿ: 'M',\n  ḿ: 'm',\n  M̆: 'M',\n  m̆: 'm',\n  Ń: 'N',\n  ń: 'n',\n  Ņ: 'N',\n  ņ: 'n',\n  Ň: 'N',\n  ň: 'n',\n  ŉ: 'n',\n  N̆: 'N',\n  n̆: 'n',\n  Ō: 'O',\n  ō: 'o',\n  Ŏ: 'O',\n  ŏ: 'o',\n  Ő: 'O',\n  ő: 'o',\n  Œ: 'OE',\n  œ: 'oe',\n  P̆: 'P',\n  p̆: 'p',\n  Ŕ: 'R',\n  ŕ: 'r',\n  Ŗ: 'R',\n  ŗ: 'r',\n  Ř: 'R',\n  ř: 'r',\n  R̆: 'R',\n  r̆: 'r',\n  Ȓ: 'R',\n  ȓ: 'r',\n  Ś: 'S',\n  ś: 's',\n  Ŝ: 'S',\n  ŝ: 's',\n  Ş: 'S',\n  Ș: 'S',\n  ș: 's',\n  ş: 's',\n  Š: 'S',\n  š: 's',\n  Ţ: 'T',\n  ţ: 't',\n  ț: 't',\n  Ț: 'T',\n  Ť: 'T',\n  ť: 't',\n  Ŧ: 'T',\n  ŧ: 't',\n  T̆: 'T',\n  t̆: 't',\n  Ũ: 'U',\n  ũ: 'u',\n  Ū: 'U',\n  ū: 'u',\n  Ŭ: 'U',\n  ŭ: 'u',\n  Ů: 'U',\n  ů: 'u',\n  Ű: 'U',\n  ű: 'u',\n  Ų: 'U',\n  ų: 'u',\n  Ȗ: 'U',\n  ȗ: 'u',\n  V̆: 'V',\n  v̆: 'v',\n  Ŵ: 'W',\n  ŵ: 'w',\n  Ẃ: 'W',\n  ẃ: 'w',\n  X̆: 'X',\n  x̆: 'x',\n  Ŷ: 'Y',\n  ŷ: 'y',\n  Ÿ: 'Y',\n  Y̆: 'Y',\n  y̆: 'y',\n  Ź: 'Z',\n  ź: 'z',\n  Ż: 'Z',\n  ż: 'z',\n  Ž: 'Z',\n  ž: 'z',\n  ſ: 's',\n  ƒ: 'f',\n  Ơ: 'O',\n  ơ: 'o',\n  Ư: 'U',\n  ư: 'u',\n  Ǎ: 'A',\n  ǎ: 'a',\n  Ǐ: 'I',\n  ǐ: 'i',\n  Ǒ: 'O',\n  ǒ: 'o',\n  Ǔ: 'U',\n  ǔ: 'u',\n  Ǖ: 'U',\n  ǖ: 'u',\n  Ǘ: 'U',\n  ǘ: 'u',\n  Ǚ: 'U',\n  ǚ: 'u',\n  Ǜ: 'U',\n  ǜ: 'u',\n  Ứ: 'U',\n  ứ: 'u',\n  Ṹ: 'U',\n  ṹ: 'u',\n  Ǻ: 'A',\n  ǻ: 'a',\n  Ǽ: 'AE',\n  ǽ: 'ae',\n  Ǿ: 'O',\n  ǿ: 'o',\n  Þ: 'TH',\n  þ: 'th',\n  Ṕ: 'P',\n  ṕ: 'p',\n  Ṥ: 'S',\n  ṥ: 's',\n  X́: 'X',\n  x́: 'x',\n  Ѓ: 'Г',\n  ѓ: 'г',\n  Ќ: 'К',\n  ќ: 'к',\n  A̋: 'A',\n  a̋: 'a',\n  E̋: 'E',\n  e̋: 'e',\n  I̋: 'I',\n  i̋: 'i',\n  Ǹ: 'N',\n  ǹ: 'n',\n  Ồ: 'O',\n  ồ: 'o',\n  Ṑ: 'O',\n  ṑ: 'o',\n  Ừ: 'U',\n  ừ: 'u',\n  Ẁ: 'W',\n  ẁ: 'w',\n  Ỳ: 'Y',\n  ỳ: 'y',\n  Ȁ: 'A',\n  ȁ: 'a',\n  Ȅ: 'E',\n  ȅ: 'e',\n  Ȉ: 'I',\n  ȉ: 'i',\n  Ȍ: 'O',\n  ȍ: 'o',\n  Ȑ: 'R',\n  ȑ: 'r',\n  Ȕ: 'U',\n  ȕ: 'u',\n  B̌: 'B',\n  b̌: 'b',\n  Č̣: 'C',\n  č̣: 'c',\n  Ê̌: 'E',\n  ê̌: 'e',\n  F̌: 'F',\n  f̌: 'f',\n  Ǧ: 'G',\n  ǧ: 'g',\n  Ȟ: 'H',\n  ȟ: 'h',\n  J̌: 'J',\n  ǰ: 'j',\n  Ǩ: 'K',\n  ǩ: 'k',\n  M̌: 'M',\n  m̌: 'm',\n  P̌: 'P',\n  p̌: 'p',\n  Q̌: 'Q',\n  q̌: 'q',\n  Ř̩: 'R',\n  ř̩: 'r',\n  Ṧ: 'S',\n  ṧ: 's',\n  V̌: 'V',\n  v̌: 'v',\n  W̌: 'W',\n  w̌: 'w',\n  X̌: 'X',\n  x̌: 'x',\n  Y̌: 'Y',\n  y̌: 'y',\n  A̧: 'A',\n  a̧: 'a',\n  B̧: 'B',\n  b̧: 'b',\n  Ḑ: 'D',\n  ḑ: 'd',\n  Ȩ: 'E',\n  ȩ: 'e',\n  Ɛ̧: 'E',\n  ɛ̧: 'e',\n  Ḩ: 'H',\n  ḩ: 'h',\n  I̧: 'I',\n  i̧: 'i',\n  Ɨ̧: 'I',\n  ɨ̧: 'i',\n  M̧: 'M',\n  m̧: 'm',\n  O̧: 'O',\n  o̧: 'o',\n  Q̧: 'Q',\n  q̧: 'q',\n  U̧: 'U',\n  u̧: 'u',\n  X̧: 'X',\n  x̧: 'x',\n  Z̧: 'Z',\n  z̧: 'z',\n}\n\nconst chars = Object.keys(characterMap).join('|')\nconst allAccents = new RegExp(chars, 'g')\n\nexport function removeAccents(str: string) {\n  return str.replace(allAccents, match => {\n    return characterMap[match]!\n  })\n}\n", "/**\n * @name match-sorter\n * @license MIT license.\n * @copyright (c) 2099 Kent C. Dodds\n * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)\n */\n\n// This is a fork of match-sorter. Instead of offering\n// a unified API for filtering and sorting in a single pass,\n// match-sorter-utils provides the lower-level utilities of\n// ranking items and comparing ranks in a way that can\n// be incrementally applied to a system rather than\n// all-at-once.\n\n// 1. Use the rankItem function to rank an item\n// 2. Use the resulting rankingInfo.passed to filter\n// 3. Use the resulting rankingInfo.rank to sort\n\n// For bundling purposes (mainly remove-accents not being esm safe/ready),\n// we've also hard-coded remove-accents into this source.\n// The remove-accents package is still included as a dependency\n// for attribution purposes, but it will not be imported and bundled.\n\nimport { removeAccents } from './remove-accents'\n\nexport type AccessorAttributes = {\n  threshold?: Ranking\n  maxRanking: Ranking\n  minRanking: Ranking\n}\n\nexport interface RankingInfo {\n  rankedValue: any\n  rank: Ranking\n  accessorIndex: number\n  accessorThreshold: Ranking | undefined\n  passed: boolean\n}\n\nexport interface AccessorOptions<TItem> {\n  accessor: AccessorFn<TItem>\n  threshold?: Ranking\n  maxRanking?: Ranking\n  minRanking?: Ranking\n}\n\nexport type AccessorFn<TItem> = (item: TItem) => string | Array<string>\n\nexport type Accessor<TItem> = AccessorFn<TItem> | AccessorOptions<TItem>\n\nexport interface RankItemOptions<TItem = unknown> {\n  accessors?: ReadonlyArray<Accessor<TItem>>\n  threshold?: Ranking\n  keepDiacritics?: boolean\n}\n\nexport const rankings = {\n  CASE_SENSITIVE_EQUAL: 7,\n  EQUAL: 6,\n  STARTS_WITH: 5,\n  WORD_STARTS_WITH: 4,\n  CONTAINS: 3,\n  ACRONYM: 2,\n  MATCHES: 1,\n  NO_MATCH: 0,\n} as const\n\nexport type Ranking = (typeof rankings)[keyof typeof rankings]\n\n/**\n * Gets the highest ranking for value for the given item based on its values for the given keys\n * @param {*} item - the item to rank\n * @param {String} value - the value to rank against\n * @param {Object} options - options to control the ranking\n * @return {{rank: Number, accessorIndex: Number, accessorThreshold: Number}} - the highest ranking\n */\nexport function rankItem<TItem>(\n  item: TItem,\n  value: string,\n  options?: RankItemOptions<TItem>\n): RankingInfo {\n  options = options || {}\n\n  options.threshold = options.threshold ?? rankings.MATCHES\n\n  if (!options.accessors) {\n    // if keys is not specified, then we assume the item given is ready to be matched\n    const rank = getMatchRanking(item as unknown as string, value, options)\n    return {\n      // ends up being duplicate of 'item' in matches but consistent\n      rankedValue: item,\n      rank,\n      accessorIndex: -1,\n      accessorThreshold: options.threshold,\n      passed: rank >= options.threshold,\n    }\n  }\n\n  const valuesToRank = getAllValuesToRank(item, options.accessors)\n\n  const rankingInfo: RankingInfo = {\n    rankedValue: item,\n    rank: rankings.NO_MATCH as Ranking,\n    accessorIndex: -1,\n    accessorThreshold: options.threshold,\n    passed: false,\n  }\n\n  for (let i = 0; i < valuesToRank.length; i++) {\n    const rankValue = valuesToRank[i]!\n\n    let newRank = getMatchRanking(rankValue.itemValue, value, options)\n\n    const {\n      minRanking,\n      maxRanking,\n      threshold = options.threshold,\n    } = rankValue.attributes\n\n    if (newRank < minRanking && newRank >= rankings.MATCHES) {\n      newRank = minRanking\n    } else if (newRank > maxRanking) {\n      newRank = maxRanking\n    }\n\n    newRank = Math.min(newRank, maxRanking) as Ranking\n\n    if (newRank >= threshold && newRank > rankingInfo.rank) {\n      rankingInfo.rank = newRank\n      rankingInfo.passed = true\n      rankingInfo.accessorIndex = i\n      rankingInfo.accessorThreshold = threshold\n      rankingInfo.rankedValue = rankValue.itemValue\n    }\n  }\n\n  return rankingInfo\n}\n\n/**\n * Gives a rankings score based on how well the two strings match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Object} options - options for the match (like keepDiacritics for comparison)\n * @returns {Number} the ranking for how well stringToRank matches testString\n */\nfunction getMatchRanking<TItem>(\n  testString: string,\n  stringToRank: string,\n  options: RankItemOptions<TItem>\n): Ranking {\n  testString = prepareValueForComparison(testString, options)\n  stringToRank = prepareValueForComparison(stringToRank, options)\n\n  // too long\n  if (stringToRank.length > testString.length) {\n    return rankings.NO_MATCH\n  }\n\n  // case sensitive equals\n  if (testString === stringToRank) {\n    return rankings.CASE_SENSITIVE_EQUAL\n  }\n\n  // Lower casing before further comparison\n  testString = testString.toLowerCase()\n  stringToRank = stringToRank.toLowerCase()\n\n  // case insensitive equals\n  if (testString === stringToRank) {\n    return rankings.EQUAL\n  }\n\n  // starts with\n  if (testString.startsWith(stringToRank)) {\n    return rankings.STARTS_WITH\n  }\n\n  // word starts with\n  if (testString.includes(` ${stringToRank}`)) {\n    return rankings.WORD_STARTS_WITH\n  }\n\n  // contains\n  if (testString.includes(stringToRank)) {\n    return rankings.CONTAINS\n  } else if (stringToRank.length === 1) {\n    // If the only character in the given stringToRank\n    //   isn't even contained in the testString, then\n    //   it's definitely not a match.\n    return rankings.NO_MATCH\n  }\n\n  // acronym\n  if (getAcronym(testString).includes(stringToRank)) {\n    return rankings.ACRONYM\n  }\n\n  // will return a number between rankings.MATCHES and\n  // rankings.MATCHES + 1 depending  on how close of a match it is.\n  return getClosenessRanking(testString, stringToRank)\n}\n\n/**\n * Generates an acronym for a string.\n *\n * @param {String} string the string for which to produce the acronym\n * @returns {String} the acronym\n */\nfunction getAcronym(string: string): string {\n  let acronym = ''\n  const wordsInString = string.split(' ')\n  wordsInString.forEach(wordInString => {\n    const splitByHyphenWords = wordInString.split('-')\n    splitByHyphenWords.forEach(splitByHyphenWord => {\n      acronym += splitByHyphenWord.substr(0, 1)\n    })\n  })\n  return acronym\n}\n\n/**\n * Returns a score based on how spread apart the\n * characters from the stringToRank are within the testString.\n * A number close to rankings.MATCHES represents a loose match. A number close\n * to rankings.MATCHES + 1 represents a tighter match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @returns {Number} the number between rankings.MATCHES and\n * rankings.MATCHES + 1 for how well stringToRank matches testString\n */\nfunction getClosenessRanking(\n  testString: string,\n  stringToRank: string\n): Ranking {\n  let matchingInOrderCharCount = 0\n  let charNumber = 0\n  function findMatchingCharacter(\n    matchChar: undefined | string,\n    string: string,\n    index: number\n  ) {\n    for (let j = index, J = string.length; j < J; j++) {\n      const stringChar = string[j]\n      if (stringChar === matchChar) {\n        matchingInOrderCharCount += 1\n        return j + 1\n      }\n    }\n    return -1\n  }\n  function getRanking(spread: number) {\n    const spreadPercentage = 1 / spread\n    const inOrderPercentage = matchingInOrderCharCount / stringToRank.length\n    const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage\n    return ranking as Ranking\n  }\n  const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0)\n  if (firstIndex < 0) {\n    return rankings.NO_MATCH\n  }\n  charNumber = firstIndex\n  for (let i = 1, I = stringToRank.length; i < I; i++) {\n    const matchChar = stringToRank[i]\n    charNumber = findMatchingCharacter(matchChar, testString, charNumber)\n    const found = charNumber > -1\n    if (!found) {\n      return rankings.NO_MATCH\n    }\n  }\n\n  const spread = charNumber - firstIndex\n  return getRanking(spread)\n}\n\n/**\n * Sorts items that have a rank, index, and accessorIndex\n * @param {Object} a - the first item to sort\n * @param {Object} b - the second item to sort\n * @return {Number} -1 if a should come first, 1 if b should come first, 0 if equal\n */\nexport function compareItems<TItem>(a: RankingInfo, b: RankingInfo): number {\n  return a.rank === b.rank ? 0 : a.rank > b.rank ? -1 : 1\n}\n\n/**\n * Prepares value for comparison by stringifying it, removing diacritics (if specified)\n * @param {String} value - the value to clean\n * @param {Object} options - {keepDiacritics: whether to remove diacritics}\n * @return {String} the prepared value\n */\nfunction prepareValueForComparison<TItem>(\n  value: string,\n  { keepDiacritics }: RankItemOptions<TItem>\n): string {\n  // value might not actually be a string at this point (we don't get to choose)\n  // so part of preparing the value for comparison is ensure that it is a string\n  value = `${value}` // toString\n  if (!keepDiacritics) {\n    value = removeAccents(value)\n  }\n  return value\n}\n\n/**\n * Gets value for key in item at arbitrarily nested keypath\n * @param {Object} item - the item\n * @param {Object|Function} key - the potentially nested keypath or property callback\n * @return {Array} - an array containing the value(s) at the nested keypath\n */\nfunction getItemValues<TItem>(\n  item: TItem,\n  accessor: Accessor<TItem>\n): Array<string> {\n  let accessorFn = accessor as AccessorFn<TItem>\n\n  if (typeof accessor === 'object') {\n    accessorFn = accessor.accessor\n  }\n\n  const value = accessorFn(item)\n\n  // because `value` can also be undefined\n  if (value == null) {\n    return []\n  }\n\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  return [String(value)]\n}\n\n/**\n * Gets all the values for the given keys in the given item and returns an array of those values\n * @param item - the item from which the values will be retrieved\n * @param keys - the keys to use to retrieve the values\n * @return objects with {itemValue, attributes}\n */\nfunction getAllValuesToRank<TItem>(\n  item: TItem,\n  accessors: ReadonlyArray<Accessor<TItem>>\n) {\n  const allValues: Array<{\n    itemValue: string\n    attributes: AccessorAttributes\n  }> = []\n  for (let j = 0, J = accessors.length; j < J; j++) {\n    const accessor = accessors[j]!\n    const attributes = getAccessorAttributes(accessor)\n    const itemValues = getItemValues(item, accessor)\n    for (let i = 0, I = itemValues.length; i < I; i++) {\n      allValues.push({\n        itemValue: itemValues[i]!,\n        attributes,\n      })\n    }\n  }\n  return allValues\n}\n\nconst defaultKeyAttributes = {\n  maxRanking: Infinity as Ranking,\n  minRanking: -Infinity as Ranking,\n}\n/**\n * Gets all the attributes for the given accessor\n * @param accessor - the accessor from which the attributes will be retrieved\n * @return object containing the accessor's attributes\n */\nfunction getAccessorAttributes<TItem>(\n  accessor: Accessor<TItem>\n): AccessorAttributes {\n  if (typeof accessor === 'function') {\n    return defaultKeyAttributes\n  }\n  return { ...defaultKeyAttributes, ...accessor }\n}\n", "import type { Query } from '@tanstack/query-core'\n\ntype SortFn = (a: Query, b: Query) => number\n\nenum QueryState {\n  Fetching = 0,\n  Fresh,\n  Stale,\n  Inactive,\n  Paused,\n}\n\nexport function getQueryState(query: Query): QueryState {\n  if (query.state.fetchStatus === 'fetching') {\n    return QueryState.Fetching\n  }\n  if (query.state.fetchStatus === 'paused') {\n    return QueryState.Paused\n  }\n  if (!query.getObserversCount()) {\n    return QueryState.Inactive\n  }\n  if (query.isStale()) {\n    return QueryState.Stale\n  }\n\n  return QueryState.Fresh\n}\n\nexport function getQueryStateLabel(query: Query): string {\n  const queryState = getQueryState(query)\n\n  if (queryState === QueryState.Fetching) {\n    return 'fetching'\n  }\n  if (queryState === QueryState.Paused) {\n    return 'paused'\n  }\n  if (queryState === QueryState.Stale) {\n    return 'stale'\n  }\n  if (queryState === QueryState.Inactive) {\n    return 'inactive'\n  }\n\n  return 'fresh'\n}\n\nexport function getQueryStatusFg(query: Query): number {\n  const queryState = getQueryState(query)\n\n  if (queryState === QueryState.Stale) {\n    return 0x000000\n  }\n\n  return 0xffffff\n}\n\nexport function getQueryStatusBg(query: Query): number {\n  const queryState = getQueryState(query)\n\n  if (queryState === QueryState.Fetching) {\n    return 0x006bff\n  }\n  if (queryState === QueryState.Paused) {\n    return 0x8c49eb\n  }\n  if (queryState === QueryState.Stale) {\n    return 0xffb200\n  }\n  if (queryState === QueryState.Inactive) {\n    return 0x3f4e60\n  }\n\n  return 0x008327\n}\n\nconst queryHashSort: SortFn = (a, b) => a.queryHash.localeCompare(b.queryHash)\n\nconst dateSort: SortFn = (a, b) =>\n  a.state.dataUpdatedAt < b.state.dataUpdatedAt ? 1 : -1\n\nconst statusAndDateSort: SortFn = (a, b) => {\n  if (getQueryState(a) === getQueryState(b)) {\n    return dateSort(a, b)\n  }\n\n  return getQueryState(a) > getQueryState(b) ? 1 : -1\n}\n\nexport const sortFns: Record<string, SortFn> = {\n  'Status > Last Updated': statusAndDateSort,\n  'Query Hash': queryHashSort,\n  'Last Updated': dateSort,\n}\n", "import { setupDevtoolsPlugin } from '@vue/devtools-api'\nimport { rankItem } from '@tanstack/match-sorter-utils'\nimport { onlineManager } from '@tanstack/query-core'\nimport {\n  getQueryStateLabel,\n  getQueryStatusBg,\n  getQueryStatusFg,\n  sortFns,\n} from './utils'\nimport type { CustomInspectorNode } from '@vue/devtools-api'\nimport type { Query, QueryCacheNotifyEvent } from '@tanstack/query-core'\nimport type { QueryClient } from '../queryClient'\n\nconst pluginId = 'vue-query'\nconst pluginName = 'Vue Query'\n\nexport function setupDevtools(app: any, queryClient: QueryClient) {\n  setupDevtoolsPlugin(\n    {\n      id: pluginId,\n      label: pluginName,\n      packageName: 'vue-query',\n      homepage: 'https://tanstack.com/query/latest',\n      logo: 'https://raw.githubusercontent.com/TanStack/query/main/packages/vue-query/media/vue-query.svg',\n      app,\n      settings: {\n        baseSort: {\n          type: 'choice',\n          component: 'button-group',\n          label: 'Sort Cache Entries',\n          options: [\n            {\n              label: 'ASC',\n              value: 1,\n            },\n            {\n              label: 'DESC',\n              value: -1,\n            },\n          ],\n          defaultValue: 1,\n        },\n        sortFn: {\n          type: 'choice',\n          label: 'Sort Function',\n          options: Object.keys(sortFns).map((key) => ({\n            label: key,\n            value: key,\n          })),\n          defaultValue: Object.keys(sortFns)[0]!,\n        },\n        onlineMode: {\n          type: 'choice',\n          component: 'button-group',\n          label: 'Online mode',\n          options: [\n            {\n              label: 'Online',\n              value: 1,\n            },\n            {\n              label: 'Offline',\n              value: 0,\n            },\n          ],\n          defaultValue: 1,\n        },\n      },\n    },\n    (api) => {\n      const initialSettings = api.getSettings()\n      onlineManager.setOnline(Boolean(initialSettings.onlineMode.valueOf()))\n\n      const queryCache = queryClient.getQueryCache()\n\n      api.addInspector({\n        id: pluginId,\n        label: pluginName,\n        icon: 'api',\n        nodeActions: [\n          {\n            icon: 'file_download',\n            tooltip: 'Refetch',\n            action: (queryHash: string) => {\n              queryCache.get(queryHash)?.fetch()\n            },\n          },\n          {\n            icon: 'alarm',\n            tooltip: 'Invalidate',\n            action: (queryHash: string) => {\n              const query = queryCache.get(queryHash) as Query\n              queryClient.invalidateQueries(query)\n            },\n          },\n          {\n            icon: 'settings_backup_restore',\n            tooltip: 'Reset',\n            action: (queryHash: string) => {\n              queryCache.get(queryHash)?.reset()\n            },\n          },\n          {\n            icon: 'delete',\n            tooltip: 'Remove',\n            action: (queryHash: string) => {\n              const query = queryCache.get(queryHash) as Query\n              queryCache.remove(query)\n            },\n          },\n          {\n            icon: 'hourglass_empty',\n            tooltip: 'Force loading',\n            action: (queryHash: string) => {\n              const query = queryCache.get(queryHash) as Query\n\n              query.setState({\n                data: undefined,\n                status: 'pending',\n              })\n            },\n          },\n          {\n            icon: 'error_outline',\n            tooltip: 'Force error',\n            action: (queryHash: string) => {\n              const query = queryCache.get(queryHash) as Query\n\n              query.setState({\n                data: undefined,\n                status: 'error',\n                error: new Error('Unknown error from devtools'),\n              })\n            },\n          },\n        ],\n      })\n\n      api.addTimelineLayer({\n        id: pluginId,\n        label: pluginName,\n        color: 0xffd94c,\n      })\n\n      queryCache.subscribe((event) => {\n        api.sendInspectorTree(pluginId)\n        api.sendInspectorState(pluginId)\n\n        const queryEvents: Array<QueryCacheNotifyEvent['type']> = [\n          'added',\n          'removed',\n          'updated',\n        ]\n\n        if (queryEvents.includes(event.type)) {\n          api.addTimelineEvent({\n            layerId: pluginId,\n            event: {\n              title: event.type,\n              subtitle: event.query.queryHash,\n              time: api.now(),\n              data: {\n                queryHash: event.query.queryHash,\n                ...event,\n              },\n            },\n          })\n        }\n      })\n\n      api.on.setPluginSettings((payload) => {\n        if (payload.key === 'onlineMode') {\n          onlineManager.setOnline(Boolean(payload.newValue))\n        }\n      })\n\n      api.on.getInspectorTree((payload) => {\n        if (payload.inspectorId === pluginId) {\n          const queries = queryCache.getAll()\n          const settings = api.getSettings()\n\n          const filtered = payload.filter\n            ? queries.filter(\n                (item) => rankItem(item.queryHash, payload.filter).passed,\n              )\n            : [...queries]\n\n          const sorted = filtered.sort(\n            (a, b) => sortFns[settings.sortFn]!(a, b) * settings.baseSort,\n          )\n\n          const nodes: Array<CustomInspectorNode> = sorted.map((query) => {\n            const stateLabel = getQueryStateLabel(query)\n\n            return {\n              id: query.queryHash,\n              label: query.queryHash,\n              tags: [\n                {\n                  label: `${stateLabel} [${query.getObserversCount()}]`,\n                  textColor: getQueryStatusFg(query),\n                  backgroundColor: getQueryStatusBg(query),\n                },\n              ],\n            }\n          })\n          payload.rootNodes = nodes\n        }\n      })\n\n      api.on.getInspectorState((payload) => {\n        if (payload.inspectorId === pluginId) {\n          const query = queryCache.get(payload.nodeId)\n\n          if (!query) {\n            return\n          }\n\n          payload.state = {\n            ' Query Details': [\n              {\n                key: 'Query key',\n                value: query.queryHash,\n              },\n              {\n                key: 'Query status',\n                value: getQueryStateLabel(query),\n              },\n              {\n                key: 'Observers',\n                value: query.getObserversCount(),\n              },\n              {\n                key: 'Last Updated',\n                value: new Date(query.state.dataUpdatedAt).toLocaleTimeString(),\n              },\n            ],\n            'Data Explorer': [\n              {\n                key: 'Data',\n                value: query.state.data,\n              },\n            ],\n            'Query Explorer': [\n              {\n                key: 'Query',\n                value: query,\n              },\n            ],\n          }\n        }\n      })\n    },\n  )\n}\n", "import { isVue2 } from 'vue-demi'\nimport { isServer } from '@tanstack/query-core'\n\nimport { QueryClient } from './queryClient'\nimport { getClientKey } from './utils'\nimport { setupDevtools } from './devtools/devtools'\nimport type { QueryClientConfig } from './types'\n\ntype ClientPersister = (client: QueryClient) => [() => void, Promise<void>]\n\ninterface CommonOptions {\n  enableDevtoolsV6Plugin?: boolean\n  queryClientKey?: string\n  clientPersister?: ClientPersister\n  clientPersisterOnSuccess?: (client: QueryClient) => void\n}\n\ninterface ConfigOptions extends CommonOptions {\n  queryClientConfig?: QueryClientConfig\n}\n\ninterface ClientOptions extends CommonOptions {\n  queryClient?: QueryClient\n}\n\nexport type VueQueryPluginOptions = ConfigOptions | ClientOptions\n\nexport const VueQueryPlugin = {\n  install: (app: any, options: VueQueryPluginOptions = {}) => {\n    const clientKey = getClientKey(options.queryClientKey)\n    let client: QueryClient\n\n    if ('queryClient' in options && options.queryClient) {\n      client = options.queryClient\n    } else {\n      const clientConfig =\n        'queryClientConfig' in options ? options.queryClientConfig : undefined\n      client = new QueryClient(clientConfig)\n    }\n\n    if (!isServer) {\n      client.mount()\n    }\n\n    let persisterUnmount = () => {\n      // noop\n    }\n\n    if (options.clientPersister) {\n      if (client.isRestoring) {\n        client.isRestoring.value = true\n      }\n      const [unmount, promise] = options.clientPersister(client)\n      persisterUnmount = unmount\n      promise.then(() => {\n        if (client.isRestoring) {\n          client.isRestoring.value = false\n        }\n        options.clientPersisterOnSuccess?.(client)\n      })\n    }\n\n    const cleanup = () => {\n      client.unmount()\n      persisterUnmount()\n    }\n\n    if (app.onUnmount) {\n      app.onUnmount(cleanup)\n    } else {\n      const originalUnmount = app.unmount\n      app.unmount = function vueQueryUnmount() {\n        cleanup()\n        originalUnmount()\n      }\n    }\n\n    if (isVue2) {\n      app.mixin({\n        beforeCreate() {\n          // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/master/src/apis/inject.ts#L30\n          if (!this._provided) {\n            const provideCache = {}\n            Object.defineProperty(this, '_provided', {\n              get: () => provideCache,\n              set: (v) => Object.assign(provideCache, v),\n            })\n          }\n\n          this._provided[clientKey] = client\n\n          if (process.env.NODE_ENV === 'development') {\n            if (this === this.$root && options.enableDevtoolsV6Plugin) {\n              setupDevtools(this, client)\n            }\n          }\n        },\n      })\n    } else {\n      app.provide(clientKey, client)\n\n      if (process.env.NODE_ENV === 'development') {\n        if (options.enableDevtoolsV6Plugin) {\n          setupDevtools(app, client)\n        }\n      }\n    }\n  },\n}\n", "import type { DataTag, DefaultError, QueryKey } from '@tanstack/query-core'\nimport type {\n  DefinedInitialQueryOptions,\n  UndefinedInitialQueryOptions,\n} from './useQuery'\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): DefinedInitialQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TQueryFnData, TError>\n}\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UndefinedInitialQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TQueryFnData, TError>\n}\n\nexport function queryOptions(options: unknown) {\n  return options\n}\n", "import type {\n  DataTag,\n  DefaultError,\n  InfiniteData,\n  NonUndefinedGuard,\n  QueryKey,\n} from '@tanstack/query-core'\nimport type { UseInfiniteQueryOptions } from './useInfiniteQuery'\n\nexport type UndefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = UseInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  initialData?: undefined\n}\n\nexport type DefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = UseInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  initialData:\n    | NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>\n    | (() => NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>)\n}\n\nexport function infiniteQueryOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UndefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n): UndefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  queryKey: DataTag<TQueryKey, InfiniteData<TQueryFnData>, TError>\n}\n\nexport function infiniteQueryOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: DefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n): DefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  queryKey: DataTag<TQueryKey, InfiniteData<TQueryFnData>, TError>\n}\n\nexport function infiniteQueryOptions(options: unknown) {\n  return options\n}\n", "import {\n  computed,\n  getCurrentScope,\n  onScopeDispose,\n  reactive,\n  readonly,\n  shallowReactive,\n  shallowReadonly,\n  toRefs,\n  watch,\n} from 'vue-demi'\nimport { shouldThrowError } from '@tanstack/query-core'\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref, updateState } from './utils'\nimport type { Ref } from 'vue-demi'\nimport type {\n  DefaultedQueryObserverOptions,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { QueryClient } from './queryClient'\nimport type { UseQueryOptions } from './useQuery'\nimport type { UseInfiniteQueryOptions } from './useInfiniteQuery'\nimport type { MaybeRefOrGetter } from './types'\n\nexport type UseBaseQueryReturnType<\n  TData,\n  TError,\n  TResult = QueryObserverResult<TData, TError>,\n> = {\n  [K in keyof TResult]: K extends\n    | 'fetchNextPage'\n    | 'fetchPreviousPage'\n    | 'refetch'\n    ? TResult[K]\n    : Ref<Readonly<TResult>[K]>\n} & {\n  suspense: () => Promise<TResult>\n}\n\ntype UseQueryOptionsGeneric<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> =\n  | UseQueryOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n  | UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n  TPageParam,\n>(\n  Observer: typeof QueryObserver,\n  options: MaybeRefOrGetter<\n    UseQueryOptionsGeneric<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >\n  >,\n  queryClient?: QueryClient,\n): UseBaseQueryReturnType<TData, TError> {\n  if (process.env.NODE_ENV === 'development') {\n    if (!getCurrentScope()) {\n      console.warn(\n        'vue-query composable like \"useQuery()\" should only be used inside a \"setup()\" function or a running effect scope. They might otherwise lead to memory leaks.',\n      )\n    }\n  }\n\n  const client = queryClient || useQueryClient()\n\n  const defaultedOptions = computed(() => {\n    let resolvedOptions = options\n    if (typeof resolvedOptions === 'function') {\n      resolvedOptions = resolvedOptions()\n    }\n    const clonedOptions = cloneDeepUnref(resolvedOptions as any)\n\n    if (typeof clonedOptions.enabled === 'function') {\n      clonedOptions.enabled = clonedOptions.enabled()\n    }\n\n    const defaulted: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    > = client.defaultQueryOptions(clonedOptions)\n\n    defaulted._optimisticResults = client.isRestoring?.value\n      ? 'isRestoring'\n      : 'optimistic'\n\n    return defaulted\n  })\n\n  const observer = new Observer(client, defaultedOptions.value)\n  // @ts-expect-error\n  const state = defaultedOptions.value.shallow\n    ? shallowReactive(observer.getCurrentResult())\n    : reactive(observer.getCurrentResult())\n\n  let unsubscribe = () => {\n    // noop\n  }\n\n  if (client.isRestoring) {\n    watch(\n      client.isRestoring,\n      (isRestoring) => {\n        if (!isRestoring) {\n          unsubscribe()\n          unsubscribe = observer.subscribe((result) => {\n            updateState(state, result)\n          })\n        }\n      },\n      { immediate: true },\n    )\n  }\n\n  const updater = () => {\n    observer.setOptions(defaultedOptions.value)\n    updateState(state, observer.getCurrentResult())\n  }\n\n  watch(defaultedOptions, updater)\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  // fix #5910\n  const refetch = (...args: Parameters<(typeof state)['refetch']>) => {\n    updater()\n    return state.refetch(...args)\n  }\n\n  const suspense = () => {\n    return new Promise<QueryObserverResult<TData, TError>>(\n      (resolve, reject) => {\n        let stopWatch = () => {\n          // noop\n        }\n        const run = () => {\n          if (defaultedOptions.value.enabled !== false) {\n            // fix #6133\n            observer.setOptions(defaultedOptions.value)\n            const optimisticResult = observer.getOptimisticResult(\n              defaultedOptions.value,\n            )\n            if (optimisticResult.isStale) {\n              stopWatch()\n              observer\n                .fetchOptimistic(defaultedOptions.value)\n                .then(resolve, (error: TError) => {\n                  if (\n                    shouldThrowError(defaultedOptions.value.throwOnError, [\n                      error,\n                      observer.getCurrentQuery(),\n                    ])\n                  ) {\n                    reject(error)\n                  } else {\n                    resolve(observer.getCurrentResult())\n                  }\n                })\n            } else {\n              stopWatch()\n              resolve(optimisticResult)\n            }\n          }\n        }\n\n        run()\n\n        stopWatch = watch(defaultedOptions, run)\n      },\n    )\n  }\n\n  // Handle error boundary\n  watch(\n    () => state.error,\n    (error) => {\n      if (\n        state.isError &&\n        !state.isFetching &&\n        shouldThrowError(defaultedOptions.value.throwOnError, [\n          error as TError,\n          observer.getCurrentQuery(),\n        ])\n      ) {\n        throw error\n      }\n    },\n  )\n\n  // @ts-expect-error\n  const readonlyState = defaultedOptions.value.shallow\n    ? shallowReadonly(state)\n    : readonly(state)\n\n  const object: any = toRefs(readonlyState)\n  for (const key in state) {\n    if (typeof state[key as keyof typeof state] === 'function') {\n      object[key] = state[key as keyof typeof state]\n    }\n  }\n\n  object.suspense = suspense\n  object.refetch = refetch\n\n  return object as UseBaseQueryReturnType<TData, TError>\n}\n", "import { QueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type {\n  DefaultError,\n  DefinedQueryObserverResult,\n  Enabled,\n  InitialDataFunction,\n  NonUndefinedGuard,\n  QueryKey,\n  QueryObserverOptions,\n} from '@tanstack/query-core'\nimport type { UseBaseQueryReturnType } from './useBaseQuery'\nimport type {\n  DeepUnwrapRef,\n  MaybeRef,\n  MaybeRefDeep,\n  MaybeRefOrGetter,\n  ShallowOption,\n} from './types'\nimport type { QueryClient } from './queryClient'\n\nexport type UseQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = MaybeRef<\n  {\n    [Property in keyof QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >]: Property extends 'enabled'\n      ?\n          | MaybeRefOrGetter<boolean | undefined>\n          | (() => Enabled<\n              TQueryFnData,\n              TError,\n              TQueryData,\n              DeepUnwrapRef<TQueryKey>\n            >)\n      : MaybeRefDeep<\n          QueryObserverOptions<\n            TQueryFnData,\n            TError,\n            TData,\n            TQueryData,\n            DeepUnwrapRef<TQueryKey>\n          >[Property]\n        >\n  } & ShallowOption\n>\n\nexport type UndefinedInitialQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = UseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey> & {\n  initialData?:\n    | undefined\n    | InitialDataFunction<NonUndefinedGuard<TQueryFnData>>\n    | NonUndefinedGuard<TQueryFnData>\n}\n\nexport type DefinedInitialQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = UseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey> & {\n  initialData:\n    | NonUndefinedGuard<TQueryFnData>\n    | (() => NonUndefinedGuard<TQueryFnData>)\n}\n\nexport type UseQueryReturnType<TData, TError> = UseBaseQueryReturnType<\n  TData,\n  TError\n>\n\nexport type UseQueryDefinedReturnType<TData, TError> = UseBaseQueryReturnType<\n  TData,\n  TError,\n  DefinedQueryObserverResult<TData, TError>\n>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryDefinedReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: MaybeRefOrGetter<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>\n  >,\n  queryClient?: QueryClient,\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: MaybeRefOrGetter<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>\n  >,\n  queryClient?: QueryClient,\n):\n  | UseQueryReturnType<TData, TError>\n  | UseQueryDefinedReturnType<TData, TError> {\n  return useBaseQuery(QueryObserver, options, queryClient)\n}\n", "import { QueriesObserver } from '@tanstack/query-core'\nimport {\n  computed,\n  getCurrentScope,\n  onScopeDispose,\n  readonly,\n  shallowReadonly,\n  shallowRef,\n  unref,\n  watch,\n} from 'vue-demi'\n\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref } from './utils'\nimport type { Ref } from 'vue-demi'\nimport type {\n  DefaultError,\n  DefinedQueryObserverResult,\n  QueriesObserverOptions,\n  QueryFunction,\n  QueryKey,\n  QueryObserverResult,\n  ThrowOnError,\n} from '@tanstack/query-core'\nimport type { UseQueryOptions } from './useQuery'\nimport type { QueryClient } from './queryClient'\nimport type { DeepUnwrapRef, MaybeRefDeep, ShallowOption } from './types'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// `placeholderData` function does not have a parameter\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = UseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\n// Widen the type of the symbol to enable type inference even if skipToken is not immutable.\ntype SkipTokenForUseQueries = symbol\n\ntype GetUseQueryOptionsForUseQueries<T> =\n  // Part 1: if UseQueryOptions are already being sent through, then just return T\n  T extends UseQueryOptions\n    ? DeepUnwrapRef<T>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n      T extends {\n          queryFnData: infer TQueryFnData\n          error?: infer TError\n          data: infer TData\n        }\n      ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n      : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n        ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n        : T extends { data: infer TData; error?: infer TError }\n          ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n          : // Part 3: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n            T extends [infer TQueryFnData, infer TError, infer TData]\n            ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n            : T extends [infer TQueryFnData, infer TError]\n              ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n              : T extends [infer TQueryFnData]\n                ? UseQueryOptionsForUseQueries<TQueryFnData>\n                : // Part 4: responsible for inferring and enforcing type if no explicit parameter was provided\n                  T extends {\n                      queryFn?:\n                        | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                        | SkipTokenForUseQueries\n                      select?: (data: any) => infer TData\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? UseQueryOptionsForUseQueries<\n                      TQueryFnData,\n                      unknown extends TError ? DefaultError : TError,\n                      unknown extends TData ? TQueryFnData : TData,\n                      TQueryKey\n                    >\n                  : T extends {\n                        queryFn?:\n                          | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                          | SkipTokenForUseQueries\n                        throwOnError?: ThrowOnError<any, infer TError, any, any>\n                      }\n                    ? UseQueryOptionsForUseQueries<\n                        TQueryFnData,\n                        TError,\n                        TQueryFnData,\n                        TQueryKey\n                      >\n                    : // Fallback\n                      UseQueryOptionsForUseQueries\n\n// A defined initialData setting should return a DefinedQueryObserverResult rather than QueryObserverResult\ntype GetDefinedOrUndefinedQueryResult<T, TData, TError = unknown> = T extends {\n  initialData?: infer TInitialData\n}\n  ? unknown extends TInitialData\n    ? QueryObserverResult<TData, TError>\n    : TInitialData extends TData\n      ? DefinedQueryObserverResult<TData, TError>\n      : TInitialData extends () => infer TInitialDataResult\n        ? unknown extends TInitialDataResult\n          ? QueryObserverResult<TData, TError>\n          : TInitialDataResult extends TData\n            ? DefinedQueryObserverResult<TData, TError>\n            : QueryObserverResult<TData, TError>\n        : QueryObserverResult<TData, TError>\n  : QueryObserverResult<TData, TError>\n\ntype GetUseQueryResult<T> =\n  // Part 1: if using UseQueryOptions then the types are already set\n  T extends UseQueryOptions<\n    infer TQueryFnData,\n    infer TError,\n    infer TData,\n    any,\n    any\n  >\n    ? GetDefinedOrUndefinedQueryResult<\n        T,\n        undefined extends TData ? TQueryFnData : TData,\n        unknown extends TError ? DefaultError : TError\n      >\n    : // Part 2: responsible for mapping explicit type parameter to function result, if object\n      T extends { queryFnData: any; error?: infer TError; data: infer TData }\n      ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n      : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n        ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n        : T extends { data: infer TData; error?: infer TError }\n          ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n          : // Part 3: responsible for mapping explicit type parameter to function result, if tuple\n            T extends [any, infer TError, infer TData]\n            ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n            : T extends [infer TQueryFnData, infer TError]\n              ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n              : T extends [infer TQueryFnData]\n                ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData>\n                : // Part 4: responsible for mapping inferred type to results, if no explicit parameter was provided\n                  T extends {\n                      queryFn?:\n                        | QueryFunction<infer TQueryFnData, any>\n                        | SkipTokenForUseQueries\n                      select?: (data: any) => infer TData\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? GetDefinedOrUndefinedQueryResult<\n                      T,\n                      unknown extends TData ? TQueryFnData : TData,\n                      unknown extends TError ? DefaultError : TError\n                    >\n                  : T extends {\n                        queryFn?:\n                          | QueryFunction<infer TQueryFnData, any>\n                          | SkipTokenForUseQueries\n                        throwOnError?: ThrowOnError<any, infer TError, any, any>\n                      }\n                    ? GetDefinedOrUndefinedQueryResult<\n                        T,\n                        TQueryFnData,\n                        unknown extends TError ? DefaultError : TError\n                      >\n                    : // Fallback\n                      QueryObserverResult\n\n/**\n * UseQueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type UseQueriesOptions<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryOptionsForUseQueries>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryOptionsForUseQueries<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? UseQueriesOptions<\n            [...Tails],\n            [...TResults, GetUseQueryOptionsForUseQueries<Head>],\n            [...TDepth, 1]\n          >\n        : ReadonlyArray<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                UseQueryOptionsForUseQueries<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                UseQueryOptionsForUseQueries<\n                  TQueryFnData,\n                  TError,\n                  TData,\n                  TQueryKey\n                >\n              >\n            : // Fallback\n              Array<UseQueryOptionsForUseQueries>\n\n/**\n * UseQueriesResults reducer recursively maps type param to results\n */\nexport type UseQueriesResults<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<QueryObserverResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryResult<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? UseQueriesResults<\n            [...Tails],\n            [...TResults, GetUseQueryResult<Head>],\n            [...TDepth, 1]\n          >\n        : { [K in keyof T]: GetUseQueryResult<T[K]> }\n\ntype UseQueriesOptionsArg<T extends Array<any>> = readonly [\n  ...UseQueriesOptions<T>,\n]\n\nexport function useQueries<\n  T extends Array<any>,\n  TCombinedResult = UseQueriesResults<T>,\n>(\n  {\n    queries,\n    ...options\n  }: ShallowOption & {\n    queries:\n      | (() => MaybeRefDeep<UseQueriesOptionsArg<T>>)\n      | MaybeRefDeep<UseQueriesOptionsArg<T>>\n      | MaybeRefDeep<\n          readonly [\n            ...{ [K in keyof T]: GetUseQueryOptionsForUseQueries<T[K]> },\n          ]\n        >\n    combine?: (result: UseQueriesResults<T>) => TCombinedResult\n  },\n  queryClient?: QueryClient,\n): Readonly<Ref<TCombinedResult>> {\n  if (process.env.NODE_ENV === 'development') {\n    if (!getCurrentScope()) {\n      console.warn(\n        'vue-query composable like \"useQuery()\" should only be used inside a \"setup()\" function or a running effect scope. They might otherwise lead to memory leaks.',\n      )\n    }\n  }\n\n  const client = queryClient || useQueryClient()\n\n  const defaultedQueries = computed(() => {\n    const resolvedQueries =\n      typeof queries === 'function'\n        ? (queries as () => MaybeRefDeep<UseQueriesOptionsArg<T>>)()\n        : queries\n    // Only unref the top level array.\n    const queriesRaw = unref(resolvedQueries) as ReadonlyArray<any>\n\n    // Unref the rest for each element in the top level array.\n    return queriesRaw.map((queryOptions) => {\n      const clonedOptions = cloneDeepUnref(queryOptions)\n\n      if (typeof clonedOptions.enabled === 'function') {\n        clonedOptions.enabled = queryOptions.enabled()\n      }\n\n      const defaulted = client.defaultQueryOptions(clonedOptions)\n      defaulted._optimisticResults = client.isRestoring?.value\n        ? 'isRestoring'\n        : 'optimistic'\n\n      return defaulted\n    })\n  })\n\n  const observer = new QueriesObserver<TCombinedResult>(\n    client,\n    defaultedQueries.value,\n    options as QueriesObserverOptions<TCombinedResult>,\n  )\n\n  const getOptimisticResult = () => {\n    const [results, getCombinedResult] = observer.getOptimisticResult(\n      defaultedQueries.value,\n      (options as QueriesObserverOptions<TCombinedResult>).combine,\n    )\n\n    return getCombinedResult(\n      results.map((result, index) => {\n        return {\n          ...result,\n          refetch: async (...args: Array<any>) => {\n            const [{ [index]: query }] = observer.getOptimisticResult(\n              defaultedQueries.value,\n              (options as QueriesObserverOptions<TCombinedResult>).combine,\n            )\n\n            return query!.refetch(...args)\n          },\n        }\n      }),\n    )\n  }\n\n  const state = shallowRef(getOptimisticResult())\n\n  let unsubscribe = () => {\n    // noop\n  }\n\n  if (client.isRestoring) {\n    watch(\n      client.isRestoring,\n      (isRestoring) => {\n        if (!isRestoring) {\n          unsubscribe()\n          unsubscribe = observer.subscribe(() => {\n            state.value = getOptimisticResult()\n          })\n\n          state.value = getOptimisticResult()\n        }\n      },\n      { immediate: true },\n    )\n  }\n\n  watch(defaultedQueries, (queriesValue) => {\n    observer.setQueries(\n      queriesValue,\n      options as QueriesObserverOptions<TCombinedResult>,\n    )\n    state.value = getOptimisticResult()\n  })\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return options.shallow\n    ? shallowReadonly(state)\n    : (readonly(state) as Readonly<Ref<TCombinedResult>>)\n}\n", "import { InfiniteQueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type {\n  DefinedInitialDataInfiniteOptions,\n  UndefinedInitialDataInfiniteOptions,\n} from './infiniteQueryOptions'\nimport type {\n  DefaultError,\n  InfiniteData,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n  QueryKey,\n  QueryObserver,\n} from '@tanstack/query-core'\n\nimport type { UseBaseQueryReturnType } from './useBaseQuery'\n\nimport type {\n  DeepUnwrapRef,\n  MaybeRef,\n  MaybeRefDeep,\n  MaybeRefOrGetter,\n  ShallowOption,\n} from './types'\nimport type { QueryClient } from './queryClient'\n\nexport type UseInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = MaybeRef<\n  {\n    [Property in keyof InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >]: Property extends 'enabled'\n      ? MaybeRefOrGetter<\n          InfiniteQueryObserverOptions<\n            TQueryFnData,\n            TError,\n            TData,\n            DeepUnwrapRef<TQueryKey>,\n            TPageParam\n          >[Property]\n        >\n      : MaybeRefDeep<\n          InfiniteQueryObserverOptions<\n            TQueryFnData,\n            TError,\n            TData,\n            DeepUnwrapRef<TQueryKey>,\n            TPageParam\n          >[Property]\n        >\n  } & ShallowOption\n>\n\nexport type UseInfiniteQueryReturnType<TData, TError> = UseBaseQueryReturnType<\n  TData,\n  TError,\n  InfiniteQueryObserverResult<TData, TError>\n>\n\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: MaybeRefOrGetter<\n    DefinedInitialDataInfiniteOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >\n  >,\n  queryClient?: QueryClient,\n): UseInfiniteQueryReturnType<TData, TError>\n\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: MaybeRefOrGetter<\n    UndefinedInitialDataInfiniteOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >\n  >,\n  queryClient?: QueryClient,\n): UseInfiniteQueryReturnType<TData, TError>\n\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: MaybeRefOrGetter<\n    UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>\n  >,\n  queryClient?: QueryClient,\n): UseInfiniteQueryReturnType<TData, TError>\n\nexport function useInfiniteQuery(\n  options: MaybeRefOrGetter<UseInfiniteQueryOptions>,\n  queryClient?: QueryClient,\n) {\n  return useBaseQuery(\n    InfiniteQueryObserver as typeof QueryObserver,\n    options,\n    queryClient,\n  )\n}\n", "import {\n  computed,\n  getCurrentScope,\n  onScopeDispose,\n  reactive,\n  readonly,\n  shallowReactive,\n  shallowReadonly,\n  toRefs,\n  watch,\n} from 'vue-demi'\nimport { MutationObserver, shouldThrowError } from '@tanstack/query-core'\nimport { cloneDeepUnref, updateState } from './utils'\nimport { useQueryClient } from './useQueryClient'\nimport type { ToRefs } from 'vue-demi'\nimport type {\n  DefaultError,\n  DistributiveOmit,\n  MutateFunction,\n  MutateOptions,\n  MutationObserverOptions,\n  MutationObserverResult,\n} from '@tanstack/query-core'\nimport type { MaybeRefDeep, ShallowOption } from './types'\nimport type { QueryClient } from './queryClient'\n\ntype MutationResult<TData, TError, TVariables, TOnMutateResult> =\n  DistributiveOmit<\n    MutationObserverResult<TData, TError, TVariables, TOnMutateResult>,\n    'mutate' | 'reset'\n  >\n\ntype UseMutationOptionsBase<TData, TError, TVariables, TOnMutateResult> =\n  MutationObserverOptions<TData, TError, TVariables, TOnMutateResult> &\n    ShallowOption\n\nexport type UseMutationOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TOnMutateResult = unknown,\n> =\n  | MaybeRefDeep<\n      UseMutationOptionsBase<TData, TError, TVariables, TOnMutateResult>\n    >\n  | (() => MaybeRefDeep<\n      UseMutationOptionsBase<TData, TError, TVariables, TOnMutateResult>\n    >)\n\ntype MutateSyncFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TOnMutateResult = unknown,\n> = (\n  ...options: Parameters<\n    MutateFunction<TData, TError, TVariables, TOnMutateResult>\n  >\n) => void\n\nexport type UseMutationReturnType<\n  TData,\n  TError,\n  TVariables,\n  TOnMutateResult,\n  TResult = MutationResult<TData, TError, TVariables, TOnMutateResult>,\n> = ToRefs<Readonly<TResult>> & {\n  mutate: MutateSyncFunction<TData, TError, TVariables, TOnMutateResult>\n  mutateAsync: MutateFunction<TData, TError, TVariables, TOnMutateResult>\n  reset: MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TOnMutateResult\n  >['reset']\n}\n\nexport function useMutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TOnMutateResult = unknown,\n>(\n  mutationOptions: UseMutationOptions<\n    TData,\n    TError,\n    TVariables,\n    TOnMutateResult\n  >,\n  queryClient?: QueryClient,\n): UseMutationReturnType<TData, TError, TVariables, TOnMutateResult> {\n  if (process.env.NODE_ENV === 'development') {\n    if (!getCurrentScope()) {\n      console.warn(\n        'vue-query composable like \"useQuery()\" should only be used inside a \"setup()\" function or a running effect scope. They might otherwise lead to memory leaks.',\n      )\n    }\n  }\n\n  const client = queryClient || useQueryClient()\n  const options = computed(() => {\n    const resolvedOptions =\n      typeof mutationOptions === 'function'\n        ? mutationOptions()\n        : mutationOptions\n    return client.defaultMutationOptions(cloneDeepUnref(resolvedOptions))\n  })\n  const observer = new MutationObserver(client, options.value)\n  const state = options.value.shallow\n    ? shallowReactive(observer.getCurrentResult())\n    : reactive(observer.getCurrentResult())\n\n  const unsubscribe = observer.subscribe((result) => {\n    updateState(state, result)\n  })\n\n  const mutate = (\n    variables: TVariables,\n    mutateOptions?: MutateOptions<TData, TError, TVariables, TOnMutateResult>,\n  ) => {\n    observer.mutate(variables, mutateOptions).catch(() => {\n      // This is intentional\n    })\n  }\n\n  watch(options, () => {\n    observer.setOptions(options.value)\n  })\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  const readonlyState = options.value.shallow\n    ? shallowReadonly(state)\n    : readonly(state)\n\n  const resultRefs = toRefs(readonlyState) as ToRefs<\n    Readonly<MutationResult<TData, TError, TVariables, TOnMutateResult>>\n  >\n\n  watch(\n    () => state.error,\n    (error) => {\n      if (\n        error &&\n        shouldThrowError(options.value.throwOnError, [error as TError])\n      ) {\n        throw error\n      }\n    },\n  )\n\n  return {\n    ...resultRefs,\n    mutate,\n    mutateAsync: state.mutate,\n    reset: state.reset,\n  }\n}\n", "import { getCurrentScope, onScopeDispose, ref, watchEffect } from 'vue-demi'\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref } from './utils'\nimport type { Ref } from 'vue-demi'\nimport type { QueryFilters as QF } from '@tanstack/query-core'\nimport type { MaybeRefDeep } from './types'\nimport type { QueryClient } from './queryClient'\n\nexport type QueryFilters = MaybeRefDeep<QF> | (() => MaybeRefDeep<QF>)\n\nexport function useIsFetching(\n  fetchingFilters: QueryFilters = {},\n  queryClient?: QueryClient,\n): Ref<number> {\n  if (process.env.NODE_ENV === 'development') {\n    if (!getCurrentScope()) {\n      console.warn(\n        'vue-query composable like \"useQuery()\" should only be used inside a \"setup()\" function or a running effect scope. They might otherwise lead to memory leaks.',\n      )\n    }\n  }\n\n  const client = queryClient || useQueryClient()\n\n  const isFetching = ref()\n\n  const listener = () => {\n    const resolvedFilters =\n      typeof fetchingFilters === 'function'\n        ? fetchingFilters()\n        : fetchingFilters\n    isFetching.value = client.isFetching(cloneDeepUnref(resolvedFilters))\n  }\n\n  const unsubscribe = client.getQueryCache().subscribe(listener)\n\n  watchEffect(listener)\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return isFetching\n}\n", "import {\n  computed,\n  getCurrentScope,\n  onScopeDispose,\n  shallowReadonly,\n  shallowRef,\n  watch,\n} from 'vue-demi'\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref } from './utils'\nimport type { Ref } from 'vue-demi'\nimport type {\n  MutationFilters as MF,\n  Mutation,\n  MutationState,\n} from '@tanstack/query-core'\nimport type { QueryClient } from './queryClient'\nimport type { MaybeRefDeep } from './types'\nimport type { MutationCache } from './mutationCache'\n\nexport type MutationFilters = MaybeRefDeep<MF>\n\nexport function useIsMutating(\n  filters: MutationFilters | (() => MutationFilters) = {},\n  queryClient?: QueryClient,\n): Ref<number> {\n  if (process.env.NODE_ENV === 'development') {\n    if (!getCurrentScope()) {\n      console.warn(\n        'vue-query composable like \"useQuery()\" should only be used inside a \"setup()\" function or a running effect scope. They might otherwise lead to memory leaks.',\n      )\n    }\n  }\n\n  const client = queryClient || useQueryClient()\n\n  const mutationState = useMutationState(\n    {\n      filters: computed(() => ({\n        ...cloneDeepUnref(typeof filters === 'function' ? filters() : filters),\n        status: 'pending' as const,\n      })),\n    },\n    client,\n  )\n  const length = computed(() => mutationState.value.length)\n\n  return length\n}\n\nexport type MutationStateOptions<TResult = MutationState> = {\n  filters?: MutationFilters\n  select?: (mutation: Mutation) => TResult\n}\n\nfunction getResult<TResult = MutationState>(\n  mutationCache: MutationCache,\n  options: MutationStateOptions<TResult>,\n): Array<TResult> {\n  return mutationCache\n    .findAll(options.filters)\n    .map(\n      (mutation): TResult =>\n        (options.select ? options.select(mutation) : mutation.state) as TResult,\n    )\n}\n\nexport function useMutationState<TResult = MutationState>(\n  options:\n    | MutationStateOptions<TResult>\n    | (() => MutationStateOptions<TResult>) = {},\n  queryClient?: QueryClient,\n): Readonly<Ref<Array<TResult>>> {\n  const resolvedOptions = computed(() => {\n    const newOptions = typeof options === 'function' ? options() : options\n    return {\n      filters: cloneDeepUnref(newOptions.filters),\n      select: newOptions.select,\n    }\n  })\n  const mutationCache = (queryClient || useQueryClient()).getMutationCache()\n  const state = shallowRef(getResult(mutationCache, resolvedOptions.value))\n  const unsubscribe = mutationCache.subscribe(() => {\n    state.value = getResult(mutationCache, resolvedOptions.value)\n  })\n\n  watch(resolvedOptions, () => {\n    state.value = getResult(mutationCache, resolvedOptions.value)\n  })\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return shallowReadonly(state)\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAI,SAAS;;;ACCN,IAAM,mBAAmB;AAEzB,SAAS,aAAa,KAAc;AACzC,QAAM,SAAS,MAAM,IAAI,GAAG,KAAK;AACjC,SAAO,GAAG,gBAAgB,GAAG,MAAM;AACrC;AAEO,SAAS,YACd,OACA,QACM;AACN,SAAO,KAAK,KAAK,EAAE,QAAQ,CAAC,QAAQ;AAClC,UAAM,GAAG,IAAI,OAAO,GAAG;EACzB,CAAC;AACH;AAIA,SAAS,WACP,OACA,WAKA,aAAqB,IACrB,eAAuB,GACpB;AACH,MAAI,WAAW;AACb,UAAM,SAAS,UAAU,OAAO,YAAY,YAAY;AACxD,QAAI,WAAW,UAAa,MAAM,KAAK,GAAG;AACxC,aAAO;IACT;AACA,QAAI,WAAW,QAAW;AACxB,aAAO;IACT;EACF;AAEA,MAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,WAAO,MAAM;MAAI,CAAC,KAAK,UACrB,WAAW,KAAK,WAAW,OAAO,KAAK,GAAG,eAAe,CAAC;IAC5D;EACF;AAEA,MAAI,OAAO,UAAU,YAAY,cAAc,KAAK,GAAG;AACrD,UAAM,UAAU,OAAO,QAAQ,KAAK,EAAE,IAAI,CAAC,CAAC,KAAK,GAAG,MAAM;MACxD;MACA,WAAW,KAAK,WAAW,KAAK,eAAe,CAAC;IAClD,CAAC;AACD,WAAO,OAAO,YAAY,OAAO;EACnC;AAEA,SAAO;AACT;AAEO,SAAS,UACd,OACA,WAKG;AACH,SAAO,WAAW,OAAO,SAAS;AACpC;AAEO,SAAS,eACd,KACA,eAAe,OACZ;AACH,SAAO,UAAU,KAAK,CAAC,KAAK,KAAK,UAAU;AAKzC,QAAI,UAAU,KAAK,QAAQ,YAAY;AACrC,aAAO,eAAe,KAAK,IAAI;IACjC;AAGA,QAAI,gBAAgB,WAAW,GAAG,GAAG;AAGnC,aAAO,eAAgB,IAAiB,GAAG,YAAY;IACzD;AAGA,QAAI,MAAM,GAAG,GAAG;AACd,aAAO,eAAe,MAAM,GAAG,GAAG,YAAY;IAChD;AAEA,WAAO;EACT,CAAC;AACH;AAGA,SAAS,cAAc,OAAiC;AACtD,MAAI,OAAO,UAAU,SAAS,KAAK,KAAK,MAAM,mBAAmB;AAC/D,WAAO;EACT;AAEA,QAAM,YAAY,OAAO,eAAe,KAAK;AAC7C,SAAO,cAAc,QAAQ,cAAc,OAAO;AACpD;AAEA,SAAS,WAAW,OAAmC;AACrD,SAAO,OAAO,UAAU;AAC1B;;;ACzGO,SAAS,eAAe,KAAK,IAAiB;AAEnD,MAAI,CAAC,oBAAoB,GAAG;AAC1B,UAAM,IAAI;MACR;IACF;EACF;AAEA,QAAM,MAAM,aAAa,EAAE;AAC3B,QAAM,cAAc,OAAoB,GAAG;AAE3C,MAAI,CAAC,aAAa;AAChB,UAAM,IAAI;MACR;IACF;EACF;AAEA,SAAO;AACT;;;ACbO,IAAMA,cAAN,cAAyB,WAAG;EACjC,KACE,SACgD;AAChD,WAAO,MAAM,KAAK,eAAe,OAAO,CAAC;EAC3C;EAEA,QAAQ,UAAsC,CAAC,GAAiB;AAC9D,WAAO,MAAM,QAAQ,eAAe,OAAO,CAAC;EAC9C;AACF;;;ACXO,IAAMC,iBAAN,cAA4B,cAAG;EACpC,KAME,SACkE;AAClE,WAAO,MAAM,KAAK,eAAe,OAAO,CAAC;EAC3C;EAEA,QAAQ,UAAyC,CAAC,GAAoB;AACpE,WAAO,MAAM,QAAQ,eAAe,OAAO,CAAC;EAC9C;AACF;;;ACYO,IAAMC,eAAN,cAA0B,YAAG;EAClC,YAAY,SAA4B,CAAC,GAAG;AAC1C,UAAM,iBAAiB;MACrB,gBAAgB,OAAO;MACvB,YAAY,OAAO,cAAc,IAAIC,YAAW;MAChD,eAAe,OAAO,iBAAiB,IAAIC,eAAc;IAC3D;AACA,UAAM,cAAc;AAGtB,SAAA,cAA6B,IAAI,KAAK;EAFtC;EAIA,WAAW,UAAsC,CAAC,GAAW;AAC3D,WAAO,MAAM,WAAW,eAAe,OAAO,CAAC;EACjD;EAEA,WAAW,UAAyC,CAAC,GAAW;AAC9D,WAAO,MAAM,WAAW,eAAe,OAAO,CAAC;EACjD;EAQA,aACE,UACmB;AACnB,WAAO,MAAM,aAAa,eAAe,QAAQ,CAAC;EACpD;EAoBA,gBAME,SAGgB;AAChB,WAAO,MAAM,gBAAgB,eAAe,OAAO,CAAC;EACtD;EAEA,eACE,SACsC;AACtC,WAAO,MAAM,eAAe,eAAe,OAAO,CAAC;EACrD;EAmBA,aACE,UACA,SACA,UAAwC,CAAC,GACb;AAC5B,WAAO,MAAM;MACX,eAAe,QAAQ;MACvB;MACA,eAAe,OAAO;IACxB;EACF;EAEA,eACE,SACA,SACA,UAAwC,CAAC,GACH;AACtC,WAAO,MAAM;MACX,eAAe,OAAO;MACtB;MACA,eAAe,OAAO;IACxB;EACF;EAEA,cACE,UACuC;AACvC,WAAO,MAAM,cAAc,eAAe,QAAQ,CAAC;EACrD;EASA,cAAc,UAAsC,CAAC,GAAS;AAC5D,WAAO,MAAM,cAAc,eAAe,OAAO,CAAC;EACpD;EAYA,aACE,UAAsC,CAAC,GACvC,UAAsC,CAAC,GACxB;AACf,WAAO,MAAM,aAAa,eAAe,OAAO,GAAG,eAAe,OAAO,CAAC;EAC5E;EAYA,cACE,UAAsC,CAAC,GACvC,UAAuC,CAAC,GACzB;AACf,WAAO,MAAM,cAAc,eAAe,OAAO,GAAG,eAAe,OAAO,CAAC;EAC7E;EAYA,kBACE,UAAiE,CAAC,GAClE,UAA2C,CAAC,GAC7B;AACf,UAAM,gBAAgB,eAAe,OAAO;AAC5C,UAAM,gBAAgB,eAAe,OAAO;AAE5C,UAAM;MACJ,EAAE,GAAG,eAAe,aAAa,OAAO;MACxC;IACF;AAEA,QAAI,cAAc,gBAAgB,QAAQ;AACxC,aAAO,QAAQ,QAAQ;IACzB;AAEA,UAAM,iBAAuD;MAC3D,GAAG;MACH,MAAM,cAAc,eAAe,cAAc,QAAQ;IAC3D;AAIA,WAAO,SAAS,EAAE,KAAK,MAAM;AAC3B,aAAO,MAAM,eAAe,gBAAgB,aAAa;IAC3D,CAAC;EACH;EAYA,eACE,UAA6C,CAAC,GAC9C,UAAwC,CAAC,GAC1B;AACf,WAAO,MAAM;MACX,eAAe,OAAO;MACtB,eAAe,OAAO;IACxB;EACF;EA4BA,WAOE,SAGgB;AAChB,WAAO,MAAM,WAAW,eAAe,OAAO,CAAC;EACjD;EAoBA,cAME,SAGe;AACf,WAAO,MAAM,cAAc,eAAe,OAAO,CAAC;EACpD;EAkCA,mBAOE,SAS0C;AAC1C,WAAO,MAAM,mBAAmB,eAAe,OAAO,CAAC;EACzD;EAkCA,sBAOE,SASe;AACf,WAAO,MAAM,sBAAsB,eAAe,OAAO,CAAC;EAC5D;EAEA,kBAAkB,SAA6C;AAC7D,UAAM,kBAAkB,eAAe,OAAO,CAAC;EACjD;EAEA,iBAME,UACA,SAGM;AACN,UAAM,iBAAiB,eAAe,QAAQ,GAAG,eAAe,OAAO,CAAC;EAC1E;EAEA,iBACE,UACsE;AACtE,WAAO,MAAM,iBAAiB,eAAe,QAAQ,CAAC;EACxD;EAEA,oBAME,aACA,SAGM;AACN,UAAM;MACJ,eAAe,WAAW;MAC1B,eAAe,OAAO;IACxB;EACF;EAEA,oBACE,aAC6C;AAC7C,WAAO,MAAM,oBAAoB,eAAe,WAAW,CAAC;EAC9D;AACF;;;AC5dO,SAAS,wBAAwB;AACpC,SAAO,UAAU,EAAE;AACvB;AACO,SAAS,YAAY;AAExB,SAAQ,OAAO,cAAc,eAAe,OAAO,WAAW,cACxD,SACA,OAAO,eAAe,cAClB,aACA,CAAC;AACf;AACO,IAAM,mBAAmB,OAAO,UAAU;;;ACX1C,IAAM,aAAa;AACnB,IAAM,2BAA2B;;;ACDxC,IAAI;AACJ,IAAI;AACG,SAAS,yBAAyB;AACrC,MAAI;AACJ,MAAI,cAAc,QAAW;AACzB,WAAO;AAAA,EACX;AACA,MAAI,OAAO,WAAW,eAAe,OAAO,aAAa;AACrD,gBAAY;AACZ,WAAO,OAAO;AAAA,EAClB,WACS,OAAO,eAAe,iBAAiB,KAAK,WAAW,gBAAgB,QAAQ,OAAO,SAAS,SAAS,GAAG,cAAc;AAC9H,gBAAY;AACZ,WAAO,WAAW,WAAW;AAAA,EACjC,OACK;AACD,gBAAY;AAAA,EAChB;AACA,SAAO;AACX;AACO,SAAS,MAAM;AAClB,SAAO,uBAAuB,IAAI,KAAK,IAAI,IAAI,KAAK,IAAI;AAC5D;;;ACpBO,IAAM,WAAN,MAAe;AAAA,EAClB,YAAY,QAAQ,MAAM;AACtB,SAAK,SAAS;AACd,SAAK,cAAc,CAAC;AACpB,SAAK,UAAU,CAAC;AAChB,SAAK,SAAS;AACd,SAAK,OAAO;AACZ,UAAM,kBAAkB,CAAC;AACzB,QAAI,OAAO,UAAU;AACjB,iBAAW,MAAM,OAAO,UAAU;AAC9B,cAAM,OAAO,OAAO,SAAS,EAAE;AAC/B,wBAAgB,EAAE,IAAI,KAAK;AAAA,MAC/B;AAAA,IACJ;AACA,UAAM,sBAAsB,mCAAmC,OAAO,EAAE;AACxE,QAAI,kBAAkB,OAAO,OAAO,CAAC,GAAG,eAAe;AACvD,QAAI;AACA,YAAM,MAAM,aAAa,QAAQ,mBAAmB;AACpD,YAAM,OAAO,KAAK,MAAM,GAAG;AAC3B,aAAO,OAAO,iBAAiB,IAAI;AAAA,IACvC,SACO,GAAG;AAAA,IAEV;AACA,SAAK,YAAY;AAAA,MACb,cAAc;AACV,eAAO;AAAA,MACX;AAAA,MACA,YAAY,OAAO;AACf,YAAI;AACA,uBAAa,QAAQ,qBAAqB,KAAK,UAAU,KAAK,CAAC;AAAA,QACnE,SACO,GAAG;AAAA,QAEV;AACA,0BAAkB;AAAA,MACtB;AAAA,MACA,MAAM;AACF,eAAO,IAAI;AAAA,MACf;AAAA,IACJ;AACA,QAAI,MAAM;AACN,WAAK,GAAG,0BAA0B,CAACC,WAAU,UAAU;AACnD,YAAIA,cAAa,KAAK,OAAO,IAAI;AAC7B,eAAK,UAAU,YAAY,KAAK;AAAA,QACpC;AAAA,MACJ,CAAC;AAAA,IACL;AACA,SAAK,YAAY,IAAI,MAAM,CAAC,GAAG;AAAA,MAC3B,KAAK,CAAC,SAAS,SAAS;AACpB,YAAI,KAAK,QAAQ;AACb,iBAAO,KAAK,OAAO,GAAG,IAAI;AAAA,QAC9B,OACK;AACD,iBAAO,IAAI,SAAS;AAChB,iBAAK,QAAQ,KAAK;AAAA,cACd,QAAQ;AAAA,cACR;AAAA,YACJ,CAAC;AAAA,UACL;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ,CAAC;AACD,SAAK,gBAAgB,IAAI,MAAM,CAAC,GAAG;AAAA,MAC/B,KAAK,CAAC,SAAS,SAAS;AACpB,YAAI,KAAK,QAAQ;AACb,iBAAO,KAAK,OAAO,IAAI;AAAA,QAC3B,WACS,SAAS,MAAM;AACpB,iBAAO,KAAK;AAAA,QAChB,WACS,OAAO,KAAK,KAAK,SAAS,EAAE,SAAS,IAAI,GAAG;AACjD,iBAAO,IAAI,SAAS;AAChB,iBAAK,YAAY,KAAK;AAAA,cAClB,QAAQ;AAAA,cACR;AAAA,cACA,SAAS,MAAM;AAAA,cAAE;AAAA,YACrB,CAAC;AACD,mBAAO,KAAK,UAAU,IAAI,EAAE,GAAG,IAAI;AAAA,UACvC;AAAA,QACJ,OACK;AACD,iBAAO,IAAI,SAAS;AAChB,mBAAO,IAAI,QAAQ,CAAC,YAAY;AAC5B,mBAAK,YAAY,KAAK;AAAA,gBAClB,QAAQ;AAAA,gBACR;AAAA,gBACA;AAAA,cACJ,CAAC;AAAA,YACL,CAAC;AAAA,UACL;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,MAAM,cAAc,QAAQ;AACxB,SAAK,SAAS;AACd,eAAW,QAAQ,KAAK,SAAS;AAC7B,WAAK,OAAO,GAAG,KAAK,MAAM,EAAE,GAAG,KAAK,IAAI;AAAA,IAC5C;AACA,eAAW,QAAQ,KAAK,aAAa;AACjC,WAAK,QAAQ,MAAM,KAAK,OAAO,KAAK,MAAM,EAAE,GAAG,KAAK,IAAI,CAAC;AAAA,IAC7D;AAAA,EACJ;AACJ;;;ACpGO,SAAS,oBAAoB,kBAAkB,SAAS;AAC3D,QAAM,aAAa;AACnB,QAAM,SAAS,UAAU;AACzB,QAAM,OAAO,sBAAsB;AACnC,QAAM,cAAc,oBAAoB,WAAW;AACnD,MAAI,SAAS,OAAO,yCAAyC,CAAC,cAAc;AACxE,SAAK,KAAK,YAAY,kBAAkB,OAAO;AAAA,EACnD,OACK;AACD,UAAM,QAAQ,cAAc,IAAI,SAAS,YAAY,IAAI,IAAI;AAC7D,UAAM,OAAO,OAAO,2BAA2B,OAAO,4BAA4B,CAAC;AACnF,SAAK,KAAK;AAAA,MACN,kBAAkB;AAAA,MAClB;AAAA,MACA;AAAA,IACJ,CAAC;AACD,QAAI,OAAO;AACP,cAAQ,MAAM,aAAa;AAAA,IAC/B;AAAA,EACJ;AACJ;;;AC1BA,IAAMC,eAAuC;EAC3CC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,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",
  "names": ["QueryCache", "MutationCache", "QueryClient", "QueryCache", "MutationCache", "pluginId", "characterMap", "À", "Á", "Â", "Ã", "Ä", "Å", "Ấ", "Ắ", "Ẳ", "Ẵ", "Ặ", "Æ", "Ầ", "Ằ", "Ȃ", "Ç", "Ḉ", "È", "É", "Ê", "Ë", "Ế", "Ḗ", "Ề", "Ḕ", "Ḝ", "Ȇ", "Ì", "Í", "Î", "Ï", "Ḯ", "Ȋ", "Ð", "Ñ", "Ò", "Ó", "Ô", "Õ", "Ö", "Ø", "Ố", "Ṍ", "Ṓ", "Ȏ", "Ù", "Ú", "Û", "Ü", "Ý", "à", "á", "â", "ã", "ä", "å", "ấ", "ắ", "ẳ", "ẵ", "ặ", "æ", "ầ", "ằ", "ȃ", "ç", "ḉ", "è", "é", "ê", "ë", "ế", "ḗ", "ề", "ḕ", "ḝ", "ȇ", "ì", "í", "î", "ï", "ḯ", "ȋ", "ð", "ñ", "ò", "ó", "ô", "õ", "ö", "ø", "ố", "ṍ", "ṓ", "ȏ", "ù", "ú", "û", "ü", "ý", "ÿ", "Ā", "ā", "Ă", "ă", "Ą", "ą", "Ć", "ć", "Ĉ", "ĉ", "Ċ", "ċ", "Č", "č", "C̆", "c̆", "Ď", "ď", "Đ", "đ", "Ē", "ē", "Ĕ", "ĕ", "Ė", "ė", "Ę", "ę", "Ě", "ě", "Ĝ", "Ǵ", "ĝ", "ǵ", "Ğ", "ğ", "Ġ", "ġ", "Ģ", "ģ", "Ĥ", "ĥ", "Ħ", "ħ", "Ḫ", "ḫ", "Ĩ", "ĩ", "Ī", "ī", "Ĭ", "ĭ", "Į", "į", "İ", "ı", "Ĳ", "ĳ", "Ĵ", "ĵ", "Ķ", "ķ", "Ḱ", "ḱ", "K̆", "k̆", "Ĺ", "ĺ", "Ļ", "ļ", "Ľ", "ľ", "Ŀ", "ŀ", "Ł", "ł", "Ḿ", "ḿ", "M̆", "m̆", "Ń", "ń", "Ņ", "ņ", "Ň", "ň", "ŉ", "N̆", "n̆", "Ō", "ō", "Ŏ", "ŏ", "Ő", "ő", "Œ", "œ", "P̆", "p̆", "Ŕ", "ŕ", "Ŗ", "ŗ", "Ř", "ř", "R̆", "r̆", "Ȓ", "ȓ", "Ś", "ś", "Ŝ", "ŝ", "Ş", "Ș", "ș", "ş", "Š", "š", "Ţ", "ţ", "ț", "Ț", "Ť", "ť", "Ŧ", "ŧ", "T̆", "t̆", "Ũ", "ũ", "Ū", "ū", "Ŭ", "ŭ", "Ů", "ů", "Ű", "ű", "Ų", "ų", "Ȗ", "ȗ", "V̆", "v̆", "Ŵ", "ŵ", "Ẃ", "ẃ", "X̆", "x̆", "Ŷ", "ŷ", "Ÿ", "Y̆", "y̆", "Ź", "ź", "Ż", "ż", "Ž", "ž", "ſ", "ƒ", "Ơ", "ơ", "Ư", "ư", "Ǎ", "ǎ", "Ǐ", "ǐ", "Ǒ", "ǒ", "Ǔ", "ǔ", "Ǖ", "ǖ", "Ǘ", "ǘ", "Ǚ", "ǚ", "Ǜ", "ǜ", "Ứ", "ứ", "Ṹ", "ṹ", "Ǻ", "ǻ", "Ǽ", "ǽ", "Ǿ", "ǿ", "Þ", "þ", "Ṕ", "ṕ", "Ṥ", "ṥ", "X́", "x́", "Ѓ", "ѓ", "Ќ", "ќ", "A̋", "a̋", "E̋", "e̋", "I̋", "i̋", "Ǹ", "ǹ", "Ồ", "ồ", "Ṑ", "ṑ", "Ừ", "ừ", "Ẁ", "ẁ", "Ỳ", "ỳ", "Ȁ", "ȁ", "Ȅ", "ȅ", "Ȉ", "ȉ", "Ȍ", "ȍ", "Ȑ", "ȑ", "Ȕ", "ȕ", "B̌", "b̌", "Č̣", "č̣", "Ê̌", "ê̌", "F̌", "f̌", "Ǧ", "ǧ", "Ȟ", "ȟ", "J̌", "ǰ", "Ǩ", "ǩ", "M̌", "m̌", "P̌", "p̌", "Q̌", "q̌", "Ř̩", "ř̩", "Ṧ", "ṧ", "V̌", "v̌", "W̌", "w̌", "X̌", "x̌", "Y̌", "y̌", "A̧", "a̧", "B̧", "b̧", "Ḑ", "ḑ", "Ȩ", "ȩ", "Ɛ̧", "ɛ̧", "Ḩ", "ḩ", "I̧", "i̧", "Ɨ̧", "ɨ̧", "M̧", "m̧", "O̧", "o̧", "Q̧", "q̧", "U̧", "u̧", "X̧", "x̧", "Z̧", "z̧", "chars", "Object", "keys", "join", "allAccents", "RegExp", "removeAccents", "str", "replace", "match", "rankings", "CASE_SENSITIVE_EQUAL", "EQUAL", "STARTS_WITH", "WORD_STARTS_WITH", "CONTAINS", "ACRONYM", "MATCHES", "NO_MATCH", "rankItem", "item", "value", "options", "_options$threshold", "threshold", "accessors", "rank", "getMatchRanking", "rankedValue", "accessorIndex", "accessorThreshold", "passed", "valuesToRank", "getAllValuesToRank", "rankingInfo", "i", "length", "rankValue", "newRank", "itemValue", "minRanking", "maxRanking", "attributes", "Math", "min", "testString", "stringToRank", "prepareValueForComparison", "toLowerCase", "startsWith", "includes", "getAcronym", "getClosenessRanking", "string", "acronym", "wordsInString", "split", "forEach", "wordInString", "splitByHyphenWords", "splitByHyphenWord", "substr", "matchingInOrderCharCount", "charNumber", "findMatchingCharacter", "matchChar", "index", "j", "J", "stringChar", "getRanking", "spread", "spreadPercentage", "inOrderPercentage", "ranking", "firstIndex", "I", "found", "prepareValueForComparison", "value", "_ref", "keepDiacritics", "removeAccents", "getItemValues", "item", "accessor", "accessorFn", "Array", "isArray", "String", "getAllValuesToRank", "accessors", "allValues", "j", "J", "length", "attributes", "getAccessorAttributes", "itemValues", "i", "I", "push", "itemValue", "defaultKeyAttributes", "maxRanking", "Infinity", "minRanking", "QueryClient", "queryOptions"]
}
