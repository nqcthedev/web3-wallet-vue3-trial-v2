import "./chunk-RE6MNG7U.js";
import {
  AppKit,
  PACKAGE_VERSION,
  WcConstantsUtil
} from "./chunk-YAZ5GO2H.js";
import "./chunk-FM7CJL5I.js";
import "./chunk-3ZU5H2LN.js";
import "./chunk-2VDYVRPE.js";
import {
  AlertController
} from "./chunk-VXPZBJVA.js";
import "./chunk-4Z2ZRXRP.js";
import "./chunk-H5SMHTBZ.js";
import {
  AssetController,
  AssetUtil,
  ChainController,
  ConnectionController,
  ConnectionControllerUtil,
  ConnectorController,
  CoreHelperUtil,
  OptionsController,
  ProviderController,
  StorageUtil,
  getPreferredAccountType
} from "./chunk-J5D4ZCFA.js";
import {
  ConstantsUtil
} from "./chunk-E52V435I.js";
import "./chunk-TM3FN7TW.js";
import "./chunk-ZMNNWV57.js";
import {
  onMounted,
  onUnmounted,
  reactive,
  ref
} from "./chunk-DUJS4OLK.js";
import "./chunk-PK3FUKRV.js";
import "./chunk-DOW7LSSZ.js";
import "./chunk-4X65JDLI.js";
import "./chunk-UU24B44V.js";
import "./chunk-Z6GLK4M2.js";
import "./chunk-KR3SNR3Q.js";
import "./chunk-XIJ6CS2S.js";
import "./chunk-HXNQWV53.js";
import "./chunk-DI52DQAC.js";

// node_modules/@reown/appkit-controllers/dist/esm/exports/vue.js
function useAppKitAccount(options) {
  const chainNamespace = ref(options?.namespace || ChainController.state.activeChain);
  const chains = ref(ChainController.state.chains);
  const state = ref({
    allAccounts: [],
    address: void 0,
    caipAddress: void 0,
    status: void 0,
    isConnected: false,
    embeddedWalletInfo: void 0
  });
  function updateState(_chains, _chainNamespace) {
    const activeConnectorId = StorageUtil.getConnectedConnectorId(_chainNamespace);
    const authConnector = _chainNamespace ? ConnectorController.getAuthConnector(_chainNamespace) : void 0;
    const activeChainNamespace = _chainNamespace || ChainController.state.activeChain;
    const accountState = activeChainNamespace ? _chains.get(activeChainNamespace)?.accountState : void 0;
    state.value.address = CoreHelperUtil.getPlainAddress(accountState?.caipAddress);
    state.value.caipAddress = accountState?.caipAddress;
    state.value.status = accountState?.status;
    state.value.isConnected = Boolean(accountState?.caipAddress);
    state.value.embeddedWalletInfo = authConnector && activeConnectorId === ConstantsUtil.CONNECTOR_ID.AUTH ? {
      user: accountState?.user,
      authProvider: accountState?.socialProvider ?? "email",
      accountType: getPreferredAccountType(activeChainNamespace),
      isSmartAccountDeployed: Boolean(accountState?.smartAccountDeployed)
    } : void 0;
  }
  const unsubscribeActiveChain = ChainController.subscribeKey("activeChain", (val) => {
    chainNamespace.value = options?.namespace || val;
    updateState(chains.value, chainNamespace.value);
  });
  const unsubscribeChains = ChainController.subscribe((val) => {
    chains.value = val["chains"];
    updateState(chains.value, chainNamespace.value);
  });
  onMounted(() => {
    updateState(chains.value, chainNamespace.value);
  });
  onUnmounted(() => {
    unsubscribeChains();
    unsubscribeActiveChain();
  });
  return state;
}
function useDisconnect() {
  async function disconnect(props) {
    await ConnectionController.disconnect(props);
  }
  return { disconnect };
}
function useAppKitConnections(namespace) {
  const state = ref({
    connections: [],
    recentConnections: []
  });
  const unsubscribe = [];
  function formatConnection(connection) {
    const connector = ConnectorController.getConnectorById(connection.connectorId);
    const name = ConnectorController.getConnectorName(connector?.name);
    const icon = AssetUtil.getConnectorImage(connector);
    const networkImage = AssetUtil.getNetworkImage(connection.caipNetwork);
    return {
      name,
      icon,
      networkIcon: networkImage,
      ...connection
    };
  }
  function updateConnections() {
    const chainNamespace = namespace ?? ChainController.state.activeChain;
    if (!chainNamespace) {
      state.value = {
        connections: [],
        recentConnections: []
      };
      return;
    }
    try {
      const { connections, recentConnections } = ConnectionControllerUtil.getConnectionsData(chainNamespace);
      state.value = {
        connections: connections.map(formatConnection),
        recentConnections: recentConnections.map(formatConnection)
      };
    } catch (error) {
      console.warn("Failed to get connections data:", error);
      state.value = {
        connections: [],
        recentConnections: []
      };
    }
  }
  unsubscribe.push(ConnectionController.subscribeKey("connections", () => {
    updateConnections();
  }));
  unsubscribe.push(ConnectorController.subscribeKey("connectors", () => {
    updateConnections();
  }));
  unsubscribe.push(AssetController.subscribeKey("connectorImages", () => {
    updateConnections();
  }));
  unsubscribe.push(AssetController.subscribeKey("networkImages", () => {
    updateConnections();
  }));
  unsubscribe.push(ChainController.subscribeKey("activeChain", () => {
    updateConnections();
  }));
  onMounted(() => {
    updateConnections();
  });
  onUnmounted(() => {
    unsubscribe.forEach((unsubscribe2) => unsubscribe2());
  });
  const isMultiWalletEnabled = Boolean(OptionsController.state.remoteFeatures?.multiWallet);
  if (!isMultiWalletEnabled) {
    AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.CONNECTIONS_HOOK, "info");
    return ref({
      connections: [],
      recentConnections: []
    });
  }
  return state;
}
function useAppKitConnection(props) {
  const { namespace, onSuccess, onError } = props;
  const unsubscribe = [];
  const state = ref({
    connection: void 0,
    isPending: false,
    switchConnection: () => Promise.resolve(void 0),
    deleteConnection: () => ({})
  });
  const forceUpdateCounter = ref(0);
  function updateConnection() {
    const chainNamespace = namespace ?? ChainController.state.activeChain;
    if (!chainNamespace) {
      state.value.connection = void 0;
      state.value.isPending = false;
      return;
    }
    const activeConnectorIds = ConnectorController.state.activeConnectorIds || {};
    const connections = ConnectionController.state.connections || /* @__PURE__ */ new Map();
    const connectorId = activeConnectorIds[chainNamespace];
    const connList = connections.get(chainNamespace);
    const connection = connList?.find((c) => c.connectorId.toLowerCase() === connectorId?.toLowerCase());
    state.value.connection = connection;
    state.value.isPending = ConnectionController.state.isSwitchingConnection || false;
  }
  async function switchConnection({ connection: _connection, address }) {
    const chainNamespace = namespace ?? ChainController.state.activeChain;
    if (!chainNamespace) {
      console.warn("No namespace found for switchConnection");
      return;
    }
    try {
      ConnectionController.setIsSwitchingConnection(true);
      await ConnectionController.switchConnection({
        connection: _connection,
        address,
        namespace: chainNamespace,
        onChange({ address: newAddress, namespace: newNamespace, hasSwitchedAccount, hasSwitchedWallet }) {
          onSuccess?.({
            address: newAddress,
            namespace: newNamespace,
            hasSwitchedAccount,
            hasSwitchedWallet,
            hasDeletedWallet: false
          });
        }
      });
    } catch (err) {
      const error = err instanceof Error ? err : new Error("Something went wrong");
      onError?.(error);
    } finally {
      ConnectionController.setIsSwitchingConnection(false);
    }
  }
  function deleteConnection({ address, connectorId }) {
    const chainNamespace = namespace ?? ChainController.state.activeChain;
    if (!chainNamespace) {
      console.warn("No namespace found for deleteConnection");
      return;
    }
    StorageUtil.deleteAddressFromConnection({ connectorId, address, namespace: chainNamespace });
    ConnectionController.syncStorageConnections();
    onSuccess?.({
      address,
      namespace: chainNamespace,
      hasSwitchedAccount: false,
      hasSwitchedWallet: false,
      hasDeletedWallet: true
    });
    forceUpdateCounter.value += 1;
  }
  state.value.switchConnection = switchConnection;
  state.value.deleteConnection = deleteConnection;
  unsubscribe.push(ConnectionController.subscribeKey("connections", () => {
    updateConnection();
  }));
  unsubscribe.push(ConnectionController.subscribeKey("isSwitchingConnection", () => {
    updateConnection();
  }));
  unsubscribe.push(ConnectorController.subscribeKey("activeConnectorIds", () => {
    updateConnection();
  }));
  unsubscribe.push(ChainController.subscribeKey("activeChain", () => {
    updateConnection();
  }));
  onMounted(() => {
    updateConnection();
  });
  onUnmounted(() => {
    unsubscribe.forEach((unsubscribe2) => unsubscribe2());
  });
  const isMultiWalletEnabled = Boolean(OptionsController.state.remoteFeatures?.multiWallet);
  if (!isMultiWalletEnabled) {
    AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.CONNECTION_HOOK, "info");
    return ref({
      connection: void 0,
      isPending: false,
      switchConnection: () => Promise.resolve(void 0),
      deleteConnection: () => ({})
    });
  }
  return state;
}

// node_modules/@reown/appkit/dist/esm/src/library/vue/index.js
var modal = void 0;
function getAppKit(appKit) {
  if (appKit) {
    modal = appKit;
  }
}
function useAppKitProvider(chainNamespace) {
  const walletProvider = ref(ProviderController.state.providers[chainNamespace]);
  const walletProviderType = ref(ProviderController.state.providerIds[chainNamespace]);
  const unsubscribe = ProviderController.subscribe((newState) => {
    walletProvider.value = newState.providers[chainNamespace];
    walletProviderType.value = newState.providerIds[chainNamespace];
  });
  onUnmounted(() => {
    unsubscribe?.();
  });
  return reactive({
    walletProvider,
    walletProviderType
  });
}
function useAppKitTheme() {
  if (!modal) {
    throw new Error('Please call "createAppKit" before using "useAppKitTheme" hook');
  }
  function setThemeMode(themeMode2) {
    if (themeMode2) {
      modal?.setThemeMode(themeMode2);
    }
  }
  function setThemeVariables(themeVariables2) {
    if (themeVariables2) {
      modal?.setThemeVariables(themeVariables2);
    }
  }
  const themeMode = ref(modal.getThemeMode());
  const themeVariables = ref(modal.getThemeVariables());
  const unsubscribe = modal?.subscribeTheme((state) => {
    themeMode.value = state.themeMode;
    themeVariables.value = state.themeVariables;
  });
  onUnmounted(() => {
    unsubscribe?.();
  });
  return reactive({
    setThemeMode,
    setThemeVariables,
    themeMode,
    themeVariables
  });
}
function useAppKit() {
  if (!modal) {
    throw new Error('Please call "createAppKit" before using "useAppKit" composable');
  }
  async function open(options) {
    return modal?.open(options);
  }
  async function close() {
    await modal?.close();
  }
  return reactive({
    open,
    close
  });
}
function useWalletInfo(namespace) {
  if (!modal) {
    throw new Error('Please call "createAppKit" before using "useAppKit" composable');
  }
  const walletInfo = ref(modal.getWalletInfo(namespace));
  const unsubscribe = modal.subscribeWalletInfo((newValue) => {
    walletInfo.value = newValue;
  }, namespace);
  onUnmounted(() => {
    unsubscribe?.();
  });
  return reactive({ walletInfo });
}
function useAppKitState() {
  if (!modal) {
    throw new Error('Please call "createAppKit" before using "useAppKitState" composable');
  }
  const initial = modal.getState();
  const initialRemoteFeatures = modal.getRemoteFeatures();
  const open = ref(initial.open);
  const remoteFeatures = ref(initialRemoteFeatures);
  const selectedNetworkId = ref(initial.selectedNetworkId);
  const unsubscribe = modal?.subscribeState((next) => {
    open.value = next.open;
    selectedNetworkId.value = next.selectedNetworkId;
  });
  onUnmounted(() => {
    unsubscribe?.();
  });
  return reactive({ open, remoteFeatures, selectedNetworkId });
}
function useAppKitEvents() {
  if (!modal) {
    throw new Error('Please call "createAppKit" before using "useAppKitEvents" composable');
  }
  const event = reactive(modal.getEvent());
  const unsubscribe = modal?.subscribeEvents((next) => {
    event.data = next.data;
    event.timestamp = next.timestamp;
  });
  onUnmounted(() => {
    unsubscribe?.();
  });
  return event;
}

// node_modules/@reown/appkit/dist/esm/src/utils/BalanceUtil.js
async function _internalFetchBalance(appKit) {
  if (!appKit) {
    throw new Error("AppKit not initialized when  fetchBalance was called.");
  }
  return await updateBalance(appKit);
}
async function updateBalance(appKit) {
  const address = appKit.getAddress();
  const chainNamespace = appKit.getActiveChainNamespace();
  const chainId = appKit.getCaipNetwork()?.id;
  if (!address || !chainNamespace || !chainId) {
    return {
      data: void 0,
      error: "Not able to retrieve balance",
      isSuccess: false,
      isError: true
    };
  }
  const balance = await appKit.updateNativeBalance(address, chainId, chainNamespace);
  return {
    data: balance,
    error: balance ? null : "No balance found",
    isSuccess: Boolean(balance),
    isError: !balance
  };
}

// node_modules/@reown/appkit/dist/esm/exports/vue.js
var modal2 = void 0;
function createAppKit(options) {
  if (!modal2) {
    modal2 = new AppKit({
      ...options,
      sdkVersion: CoreHelperUtil.generateSdkVersion(options.adapters ?? [], "html", PACKAGE_VERSION)
    });
    getAppKit(modal2);
  }
  return modal2;
}
function useAppKitNetwork() {
  const state = ref({
    caipNetwork: ChainController.state.activeCaipNetwork,
    chainId: ChainController.state.activeCaipNetwork?.id,
    caipNetworkId: ChainController.state.activeCaipNetwork?.caipNetworkId,
    switchNetwork: async (network) => {
      await modal2?.switchNetwork(network);
    }
  });
  const unsubscribe = ChainController.subscribeKey("activeCaipNetwork", (val) => {
    state.value.caipNetwork = val;
    state.value.chainId = val?.id;
    state.value.caipNetworkId = val?.caipNetworkId;
  });
  onUnmounted(() => {
    unsubscribe();
  });
  return state;
}
function useAppKitBalance() {
  async function fetchBalance() {
    return await _internalFetchBalance(modal2);
  }
  return {
    fetchBalance
  };
}
export {
  AppKit,
  CoreHelperUtil,
  WcConstantsUtil,
  createAppKit,
  getAppKit,
  useAppKit,
  useAppKitAccount,
  useAppKitBalance,
  useAppKitConnection,
  useAppKitConnections,
  useAppKitEvents,
  useAppKitNetwork,
  useAppKitProvider,
  useAppKitState,
  useAppKitTheme,
  useDisconnect,
  useWalletInfo
};
//# sourceMappingURL=@reown_appkit_vue.js.map
